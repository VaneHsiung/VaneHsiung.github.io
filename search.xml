<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01Java程序语言概述</title>
    <url>/2021/04/26/01Java%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>1996 年 Java 第一次发布。</p>
<a id="more"></a>

<h3 id="Java-程序设计平台"><a href="#Java-程序设计平台" class="headerlink" title="Java 程序设计平台"></a>Java 程序设计平台</h3><p>Java 是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、 跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。</p>
<h3 id="Java“-白皮书”-的关键术语"><a href="#Java“-白皮书”-的关键术语" class="headerlink" title="Java“ 白皮书” 的关键术语"></a>Java“ 白皮书” 的关键术语</h3><h5 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h5><p>Java 语法简单：Java剔除了 C++ 中许多很少使用、 难以理解、 易混淆的特性；</p>
<p>Java体积小：Java 的目标之一是支持开发能够在小型机器上独立运行的软件。如Java Micro Edition。</p>
<h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><p>面向对象设计是一种程序设计技术，它将重点放在数椐（即对象）和对象的接口上。</p>
<h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>Java 有一个丰富的例程库，用于处理像 HTTP 和 FIP 之类的 TCP/IP 协议。Java 应用程序能够通过 URL 打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。</p>
<h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><p>Java 投入了大量的精力进行早期的问题检测、 后期动态的（运行时）检测，并消除了容易出错的情况。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>Java 就设计成能够防范各种攻击，其中包括：运行时堆栈溢出、破坏自己的进程空间之外的内存、未经授权读写文件。</p>
<h5 id="体系结构中立"><a href="#体系结构中立" class="headerlink" title="体系结构中立"></a>体系结构中立</h5><p>编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码， 只要有Java 运行时系统， 这些编译后的代码可以在许多处理器上运行。</p>
<h5 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h5><p>数据类型具有固定的大小，二进制数据以固定的格式进行存储和传输，字符串用标准的 Unicode 格式存储。</p>
<h5 id="解释型"><a href="#解释型" class="headerlink" title="解释型"></a>解释型</h5><p>Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码。</p>
<h5 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h5><p>性能就是“ 适用性更强”。</p>
<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>Java 是第一个支持并发程序设计的主流语言。</p>
<h5 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h5><p>Java 它能够适应不断发展的环境，库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。</p>
<h3 id="Java-applet-与-Internet"><a href="#Java-applet-与-Internet" class="headerlink" title="Java applet 与 Internet"></a>Java applet 与 Internet</h3><p>在网页中运行的 Java 程序称为 applet。它可以对用户命令做出响应， 改变外观，在运行它的计算机与提供它的计算机之间传递数据。</p>
<h3 id="Java-发展简史"><a href="#Java-发展简史" class="headerlink" title="Java 发展简史"></a>Java 发展简史</h3><p>1991 年，由 Patrick Naughton 和 James Gosling 以 C++ 为基础设计的一个可移植语言 “Oka”。</p>
<p>1992 年， Green 项目发布了它的第一个产品，称之为“ *7”。这个产品具有非常智能的远程控制。</p>
<p>1995 年 5 月 23 日在 SunWorld 上展示的 HotJava 浏览器具有在网页中执行内嵌代码的能力。 这一“ 技术印证”引发了人们延续至今的对 Java 的狂热追逐。</p>
<p>1996 年年初，Sun 发布了 Java 1.0，人们很快地意识到 Java1.0 不能用来进行真正的应用开发。</p>
<p>1997 年 Java 1.1 弥补了 1.0 的大多明显的缺陷，大大改进了反射能力，并为 GUI 编程增加了新的事件处理模型。</p>
<p>1998 年 12 月 Java 1.2 发布，这个版本取代了早期玩具式的GUI,  Sun 公司市场部将其名称改为更加吸引人的“ Java 2 标准版软件开发工具箱 1.2 版”。除了“ 标准版’”之外，Sun 还推出了两个其他的版本：一个是用于手机等嵌人式设备的”微型版”；另一个是用于服务器端处理的“ 企业版”。</p>
<p>2000  Java1.3 和 2002 年 Java 1.4 版本对最初的 Java 2 版本做出了某些改进， 扩展了标准类库，提高系统性能。在此期间， Java applet 采用低调姿态，并淡化了客户的应用，但 Java 却成为服务器端应用的首选平台。</p>
<p>2004 年 Java 5.0 版是自 1.1 版以来第一个对 Java 语言做出重大改进的版本，这个版本添加了泛型类型，以及 “ for each” 循环、 自动装箱和注解。</p>
<p>2006 年年末发布版本 6，改进了性能，并增强了类库。</p>
<p>2009 年 Oracle 收购 Sun Microsystems，Java 的开发停滞了很长一段时间。</p>
<p>2011 年 Oracle 发布了 Java 7, 其中只做了一些简单的改进。</p>
<p>2014 年 Java 8 发布，在近 20 年中这个版本有了最大的改变。Java 8 提供了一种“ 函数式” 编程方式，可以很容易地表述并发执行的计算。 </p>
<h3 id="关-于-Java-的常见误解"><a href="#关-于-Java-的常见误解" class="headerlink" title="关 于 Java 的常见误解"></a>关 于 Java 的常见误解</h3><h5 id="Java-是一种非常容易学习的程序设计语言"><a href="#Java-是一种非常容易学习的程序设计语言" class="headerlink" title="Java 是一种非常容易学习的程序设计语言"></a>Java 是一种非常容易学习的程序设计语言</h5><p>像 Java 这种功能强大的语言大都不太容易学习。必须将编写玩具式程序的轻松和开发实际项目的艰难区分开来。要想 Java 解决实际问题，必须学习如何使用 Java 类库将 Java 语言应用到实际中去。</p>
<h5 id="Java-将成为适用于所有平台的通用性编程语言"><a href="#Java-将成为适用于所有平台的通用性编程语言" class="headerlink" title="Java 将成为适用于所有平台的通用性编程语言"></a>Java 将成为适用于所有平台的通用性编程语言</h5><p>从理论上讲， 这是完全有可能的。 但在实际中， 某些领域其他语言有更出色的表现， 比如，Objective C 和 Swift 在 iOS 设备上就有着无可取代的地位， 浏览器中的处理几乎完全由 JavaScript 掌控。 Windows 程序通常都用 C++ 或 C# 编写。 Java 在服务器端编程和跨平台客户端应用领域则很有优势 。</p>
<h5 id="Java-只不过是另外一种程序设计语言"><a href="#Java-只不过是另外一种程序设计语言" class="headerlink" title="Java 只不过是另外一种程序设计语言"></a>Java 只不过是另外一种程序设计语言</h5><p>很多程序设计人员喜欢 Java 胜过 C、 C++ 或 C#。程序设计语言的成功更多地取决于其支撑系统的能力， 而不是优美的语法。人们主要关注：是否提供了易于实现某些功能的易用、 便捷和标准的库？ 是否有开发工具提供商能建立强大的编程和调试环境？ 语言和工具集是否能够与其他计算基础架构整合在一起？ Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。</p>
<h5 id="Java-是专用的，应该避免使用"><a href="#Java-是专用的，应该避免使用" class="headerlink" title="Java 是专用的，应该避免使用"></a>Java 是专用的，应该避免使用</h5><p>最初创建 Java 时，Sun 为销售者和最终用户提供了免费许可。2007 年 Sun 声称 Java 未来的版本将在 General Public License (GPL) 下提供。Oracle —直致力于保持 Java开源。根据 GPL, 任何人都可以得到专利许可， 允许其使用和修改 Java, 不过仅限于桌面和服务器平台。如果你想在嵌人式系统中使用 Java, 就需要另外一个不同的许可，这很可能需要付费。</p>
<h5 id="Java-是解释型的，-因此对于关键的应用程序速度太慢了"><a href="#Java-是解释型的，-因此对于关键的应用程序速度太慢了" class="headerlink" title="Java 是解释型的， 因此对于关键的应用程序速度太慢了"></a>Java 是解释型的， 因此对于关键的应用程序速度太慢了</h5><p>现在 Java 虚拟机使用了即时编译器， 因此采用 Java 编写的 “ 热点” 代码其运行速度与 C++ 相差无几， 有些情况下甚至更快。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>02Java程序设计环境</title>
    <url>/2021/04/26/02Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="安-装-Java-幵发工具包"><a href="#安-装-Java-幵发工具包" class="headerlink" title="安 装 Java 幵发工具包"></a>安 装 Java 幵发工具包</h3><p>Oracle 公司为 Linux 、 Mac OS X、Solaris 和 Windows 提供了 Java 开发工具包（ JDK ) 的<br>最新、 最完整的版本。</p>
<h5 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h5><p>要想下载 Java 开发具包，可以访问 Oracle 网站</p>
<table>
<thead>
<tr>
<th>术语表</th>
<th align="left">缩写</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td>Java Development Kit</td>
<td align="left">JDK</td>
<td align="left">编写 Java 程序的程序员使用的软件</td>
</tr>
<tr>
<td>Java Runtime Environment</td>
<td align="left">JRE</td>
<td align="left">运行 Java 程序的用户使用的软件</td>
</tr>
<tr>
<td>Server JRE</td>
<td align="left"></td>
<td align="left">在服务器上运行 Java 程序的软件</td>
</tr>
<tr>
<td>Standard Edition</td>
<td align="left">SE</td>
<td align="left">用于桌面或简单服务器应用的 Java 平台</td>
</tr>
<tr>
<td>Enterprise Edition</td>
<td align="left">EE</td>
<td align="left">用于复杂服务器应用的 Java 平台</td>
</tr>
<tr>
<td>Micro Edition</td>
<td align="left">ME</td>
<td align="left">用于手机和其他小型设备的 Java 平台</td>
</tr>
<tr>
<td>Java FX</td>
<td align="left"></td>
<td align="left">用于图形化用户界面的一个替代工具包</td>
</tr>
<tr>
<td>OpenJDK</td>
<td align="left"></td>
<td align="left">JavaSE 的 一个免费开源实现</td>
</tr>
<tr>
<td>Java 2</td>
<td align="left">J2</td>
<td align="left">用于描述1998 年 〜 2006 年之间的 Java 版本</td>
</tr>
<tr>
<td>Software Development Kit</td>
<td align="left">SDK</td>
<td align="left">用于描述 1998 年 ~ 2006 年之间的 JDK</td>
</tr>
<tr>
<td>Update</td>
<td align="left">u</td>
<td align="left">Oracle 的术语， 表示 bug 修正版本</td>
</tr>
<tr>
<td>NetBeans</td>
<td align="left"></td>
<td align="left">Oracle 的集成开发环境</td>
</tr>
</tbody></table>
<h5 id="设置-JDK"><a href="#设置-JDK" class="headerlink" title="设置 JDK"></a>设置 JDK</h5><p>安装目录最好不要接受路径名中包含空格的默认位置。将如 java/bin 目录增加到执行路径中。</p>
<h5 id="安装库源文件和文档"><a href="#安装库源文件和文档" class="headerlink" title="安装库源文件和文档"></a>安装库源文件和文档</h5><p>src.zip 文件中包含了所有公共类库的源代码。</p>
<p>安装库源文件：</p>
<ol>
<li>确保 JDK 已经安装， 并且 jdk/bin 目录在执行路径中。</li>
<li>在主目录中建立一个目录 javasrc。</li>
<li>在 jdk 目录下找到文件 src.zip。</li>
<li>将 src.zip 文件解压缩到 javasrc 目录。</li>
</ol>
<p>安装文档：</p>
<ol>
<li>下载文档压缩文件。这个文件名为 jdk-version-docs-all.zip。</li>
<li>解压缩这个文件，将 doc 目录重命名为一个更有描述性的名字， 如 javadoc。</li>
<li>在浏览器中导航到 javadoc/api/index.html, 将这个页面增加到书签。</li>
</ol>
<h3 id="使用命令行工具"><a href="#使用命令行工具" class="headerlink" title="使用命令行工具"></a>使用命令行工具</h3><p>通过自己执行基本步骤， 你可以更好地理解开发环境的后台工作。</p>
<p>javac 程序是一个 Java 编译器。它将 java 文件编译 class 文件。java 程序启动 Java 虚拟机。虚拟机执行编译器放在 class 文件中的字节码。</p>
<p>注意：</p>
<ol>
<li>如果手工输人源程序， 一定要注意大小写。</li>
<li>编译器需要一个文件名 （Welcome.java), 而运行程序时，只需要指定类名 （Welcome)。</li>
</ol>
<h3 id="使用集成开发环境"><a href="#使用集成开发环境" class="headerlink" title="使用集成开发环境"></a>使用集成开发环境</h3><p>可以免费得到一些很棒的开发环境， 如 Eclipse、NetBeans 和 Intell IDEA 程序。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>08泛型程序设计</title>
    <url>/2021/04/26/08%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>泛型正是我们需要的程序设计手段。使用泛型机制编写的程序代码要比那些杂乱地使用Object 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。</p>
<a id="more"></a>

<h3 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h3><p>泛型程序设计（Generic programming) 意味着编写的代码可以被很多不同类型的对象所重用。</p>
<h5 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h5><p>在Java 中增加范型类之前， 泛型程序设计是用继承实现的。ArrayList 类只维护一个Object 引用的数组。这种方法有两个问题，当获取一个值时必须进行强制类型转换；此外，这里没有错误检査，可以向数组列表中添加任何类的对象。</p>
<p>泛型提供了一个更好的解决方案： 类型参数（ type parameters )。ArrayList 类有一个类型参数用来指示元素的类型：<br><code>ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;()</code><br>在Java SE 7 及以后的版本中， 构造函数中可以省略泛型类型：<br><code>ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;()；</code><br>省略的类型可以从变量的类型推断得出。</p>
<h5 id="谁想成为泛型程序员"><a href="#谁想成为泛型程序员" class="headerlink" title="谁想成为泛型程序员"></a>谁想成为泛型程序员</h5><p>一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途。</p>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p>一个泛型类（ generic class ) 就是具有一个或多个类型变量的类。</p>
<p>类引人一个类型变量T，用尖括号(&lt; &gt;) 括起来，并放在类名的后面。泛型类可以有多个类型变量。类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。</p>
<p>在Java 库中， 使用变量E 表示集合的元素类型， K 和V 分别表示表的关键字与值的类型。T ( 需要时还可以用临近的字母U 和S) 表示“ 任意类型”。</p>
<p>用具体的类型替换类型变量就可以实例化泛型类型。泛型类可看作普通类的工厂。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>可以定义一个带有类型参数的方法。类型变量放在修饰符的后面，返回类型的前面。泛型方法可以定义在普通类中，也可以定义在泛型类中。当调用一个泛型方法时，在方法名前的尖括号中放人具体的类型，大多数情况下，方法调用中可以省略类型参数。</p>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时，类或方法需要对类型变量加以约束。可以通过对类型变量T 设置限定（bound) 实现这一点：<br><code>public static &lt;T extends Comparable&gt; T min(T[] a) ...</code></p>
<p>下面的记法：<br><code>&lt;T extends BoundingType&gt;</code><br>表示T 应该是绑定类型的子类型（subtype)。T 和绑定类型可以是类， 也可以是接口。一个类型变量或通配符可以有多个限定， 限定类型用“ &amp;” 分隔，而逗号用来分隔类型变量。在Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。</p>
<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><p>虚拟机没有泛型类型对象——所有对象都属于普通类。</p>
<h5 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h5><p>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型（ raw type )。原始类型的名字就是删去类型参数后的泛型类型名。擦除（ erased) 类型变量， 原始类型用第一个限定的类型变量来替换， 如果没有给定限定就用Object 替换。编译器在必要时要向接口插入强制类型转换，为了提高效率， 应该将标签（ tagging) 接口（即没有方法的接口）放在边界列表的末尾。</p>
<h5 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h5><p>当程序调用泛型方法时， 如果擦除返回类型， 编译器插入强制类型转换。当存取一个泛型域时也要插人强制类型转换。</p>
<h5 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h5><p>类型擦除也会出现在泛型方法中。</p>
<p>使用set方法时，问题在于类型擦除与多态发生了冲突，要解决这个问题， 就需要编译器在子类中生成一个桥方法（bridge method)：虚拟机用对象变量调用set方法，这个对象是SubClass 类型的， 因而将会调用SubClass.setMethod(Object) 方法，这个方法是合成的桥方法。它调用SubClass.setMethod(SpecificClass)， 这正是我们所期望的操作效果。</p>
<p>使用get方法时，假设SubClass方法也覆盖了getSecond 方法，在SubClass类中，有两个getSecond 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SpecificClass <span class="title">getSecond</span><span class="params">()</span> <span class="comment">// defined in Datelnterval</span></span></span><br><span class="line"><span class="function">Object <span class="title">getSecond</span><span class="params">()</span> <span class="comment">// overrides the method defined in Pair to call the first method</span></span></span><br></pre></td></tr></table></figure>
<p>不能这样编写Java 代码。但是， 在虚拟机中，用参数类型和返回类型确定一个方法。因此， 编译器可能产生两个仅返回类型不同的方法字节码， 虚拟机能够正确地处理这一情况。</p>
<p>桥方法不仅用于泛型类型。在一个方法覆盖另一个方法时可以指定一个更严格的返回类型，称为具有协变的返回类型（covariant return types)。</p>
<p>要记住有关Java 泛型转换的事实：</p>
<ul>
<li>虚拟机中没有泛型， 只有普通的类和方法。</li>
<li>所有的类型参数都用它们的限定类型替换。</li>
<li>桥方法被合成来保持多态。</li>
<li>为保持类型安全性，必要时插人强制类型转换。</li>
</ul>
<h5 id="调用遗留代码"><a href="#调用遗留代码" class="headerlink" title="调用遗留代码"></a>调用遗留代码</h5><p>设计Java 泛型类型时， 主要目标是允许泛型代码和遗留代码之间能够互操作。</p>
<p>由一个参数化类型得到一个对象。可以将它赋给一个遗留类型变量，这样做会看到一个警告。<br>由一个遗留的类得到一个原始类型的对象。可以将它赋给一个参数化的类型变量， 当然，这样做会看到一个警告。</p>
<p>在查看了警告之后，可以利用注解（ annotation ) 使之消失。注释必须放在生成这个警告的代码所在的方法之前，或者，可以标注整个方法：<br>@SuppressWarnings(“unchecked”)<br>这个注解会关闭对方法中所有代码的检査。</p>
<h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>大多数限制都是由类型擦除引起的。</p>
<h5 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h5><p>不能用类型参数代替基本类型。因此， 没有<code>Pair&lt;double&gt;</code>, 只有<code>Pair&lt;Double&gt;</code>。当然,其原因是类型擦除。擦除之后， Pair 类含有Object 类型的域， 而Object 不能存储double值。</p>
<h5 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h5><p>虚拟机中的对象总有一个特定的非泛型类型。因此， 所有的类型查询只产生原始类型。为提醒这一风险， 试图查询一个对象是否属于某个泛型类型时， 倘若使用instanceof 会得到一个编译器错误， 如果使用强制类型转换会得到一个警告。同样的道理， getClass 方法总是返回原始类型。</p>
<h5 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h5><p>不能用new实例化参数化类型的数组。<code>Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10] ;</code>数组会记住它的元素类型， 如果试图存储其他类型的元素， 就会抛出一个ArrayStoreException 异常，不过对于泛型类型， 擦除会使这种机制无效。只是不允许创建这些数组， 而声明类型为<code>Pair&lt;String&gt;[]</code> 的变量仍是合法的。</p>
<p>可以声明通配类型的数组， 然后进行类型转换：<br><code>Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</code><br>结果将是不安全的。</p>
<p>如果需要收集参数化类型对象， 只有一种安全而有效的方法：<br>使用ArrayList:<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code></p>
<h5 id="Varargs-警告"><a href="#Varargs-警告" class="headerlink" title="Varargs 警告"></a>Varargs 警告</h5><p>向参数个数可变的方法传递一个泛型类型的实例。为了调用这个方法，Java 虚拟机必须建立一个<code>Pair&lt;String&gt;</code> 数组， 这就违反了前面的规则。不过，对于这种情况， 规则有所放松， 你只会得到一个警告，而不是错误。</p>
<p>可以采用两种方法来抑制这个警告。一种方法是为包含addAll 调用的方法增加注解@SuppressWamings(“unchecked”)。 或者在Java SE 7 中， 还可以用@SafeVarargs 直接标注<br>addAll 方法。</p>
<h5 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h5><p>不能使用像new T(…)，new T[…] 或T.class 这样的表达式中的类型变量。类型擦除将T 改变成Object, 而且， 本意肯定不希望调用new Object()。Java SE 8 之后，最好的解决办法是让调用者提供一个构造器表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(), constr.get())；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较传统的解决方法是通过反射调用Class.newlnstance 方法来构造泛型对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cl.newInstance(), cl.newInstance())；</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>
<p>Class 类本身是泛型。例如， String.class 是一个<code>Class&lt;String&gt;</code> 的实例（事实上，它是唯一的实例)。 因此，makePair 方法能够推断出pair 的类型。</p>
<h5 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h5><p>如果数组仅仅作为一个类的私有实例域， 就可以将这个数组声明为Object[]，并且在获取元素时进行类型转换。</p>
<p>如果方法返回T[ ] 数组， 最好让用户提供一个数组构造器表达式：<br>String[] ss = ArrayAlg.minmax(String[]::new，”Tom” , “Dick”, “Harry”)；<br>minmax 方法使用这个参数生成一个有正确类型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(IntFunction&lt;TD&gt; constr, T... a)</span><br><span class="line">&#123;</span><br><span class="line">	T[] mm = constr.apply(<span class="number">2</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较老式的方法是利用反射， 调用Array.newlnstance:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a) &#123;</span><br><span class="line">	T[] mm = (T[]) Array.newlnstance(a.getClass().getComponentType(), <span class="number">2</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h5><p>不能在静态域或方法中引用类型变量。</p>
<h5 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h5><p>既不能抛出也不能捕获泛型类对象。实际上， 甚至泛型类扩展Throwable 都是不合法的。不过， 在异常规范中使用类型变量是允许的。</p>
<h5 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h5><p>关键在于以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWamings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> (T) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h5><p>当泛型类型被擦除时， 无法创建引发冲突的条件。</p>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p>无论S 与T 有什么联系，通常， <code>Pair&lt;S&gt;</code> 与<code>Pair&lt;T&gt;</code>没有什么联系。</p>
<p>永远可以将参数化类型转换为一个原始类型。</p>
<p>泛型类可以扩展或实现其他的泛型类。</p>
<h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><h5 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h5><p>通配符类型中， 允许类型参数变化。</p>
<p>通配符类型<br>Pair&lt;? extends Employee&gt;<br>表示任何泛型Pair 类型， 它的类型参数是Employee 的子类，</p>
<h5 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h5><p>超类型限定（supertypebound)：<br>? super Manager<br>这个通配符限制为Manager 的所有超类型。</p>
<p>直观地讲，带有超类型限定的通配符可以向泛型对象写人，带有子类型限定的通配符可以从泛型对象读取。</p>
<h5 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h5><p>Pair&lt;?&gt; 和Pair 本质的不同在于： 可以用任意Object 对象调用原始Pair 类的setObject方法。</p>
<h5 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h5><p>通配符不是类型变量， 因此， 不能在编写代码中使用“ ？” 作为一种类型。</p>
<p>解决方案是写一个辅助方法，辅助方法是一个泛型方法，然后在通配符方法中调用辅助方法。在这种情况下，辅助方法的类型变量捕获通配符。</p>
<p>通配符捕获只有在有许多限制的情况下才是合法的。编译器必须能够确信通配符表达的是单个、确定的类型。</p>
<h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><h5 id="泛型Class-类"><a href="#泛型Class-类" class="headerlink" title="泛型Class 类"></a>泛型Class 类</h5><p>Class类是泛型的。类型参数十分有用， 这是因为它允许<code>Class&lt;T&gt;</code> 方法的返回类型更加具有针对性。下面<code>Class&lt;T&gt;</code> 中的方法就使用了类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructors&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructors&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="使用Class-lt-T-gt-参数进行类型匹配"><a href="#使用Class-lt-T-gt-参数进行类型匹配" class="headerlink" title="使用Class&lt;T&gt; 参数进行类型匹配"></a>使用<code>Class&lt;T&gt;</code> 参数进行类型匹配</h5><p>匹配泛型方法中的<code>Class&lt;T&gt;</code> 参数的类型变量很有实用价值。</p>
<h5 id="虚拟机中的泛型类型信息"><a href="#虚拟机中的泛型类型信息" class="headerlink" title="虚拟机中的泛型类型信息"></a>虚拟机中的泛型类型信息</h5><p>擦除的类仍然保留一些泛型祖先的微弱记忆。但是，不会知道对于特定的对象或方法调用， 如何解释类型参数。</p>
<p>为了表达泛型类型声明， 使用java.lang.reflect 包中提供的接口Type。这个接口包含下列子类型：</p>
<ul>
<li>Class 类，描述具体类型。</li>
<li>TypeVariable 接口， 描述类型变量（如T extends Comparable&lt;? super T&gt;) 。</li>
<li>WildcardType 接口， 描述通配符（如？super T)。</li>
<li>ParameterizedType 接口， 描述泛型类或接口类型（如Comparable&lt;? super T&gt;)。</li>
<li>GenericArrayType 接口， 描述泛型数组（如T[ ])。</li>
</ul>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>11事件处理</title>
    <url>/2021/04/26/11%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="事件处理基础"><a href="#事件处理基础" class="headerlink" title="事件处理基础"></a>事件处理基础</h3><p>在 AWT 所知的事件范围内， 完全可以控制事件从事件源( event source) 到事件监听器（event listener) 的传递过程， 并将任何对象指派给事件监听器。不过事实上，应该选择一个能够便于响应事件的对象。这种称为事件委托模型（event delegation model) 。</p>
<p>事件源有一些向其注册事件监听器的方法。当某个事件源产生事件时， 事件源会向为事件注册的所有事件监听器对象发送一个通告。</p>
<p> Java 将事件的相关信息封装在一个事件对象（event object)中。在 Java 中，所有的事件对象都最终派生于java.util.EventObject 类。</p>
<p>AWT 事件处理机制的概要：</p>
<ul>
<li>监听器对象是一个实现了特定监听器接口（listener interface) 的类的实例。</li>
<li>事件源是一个能够注册监听器对象并发送事件对象的对象。</li>
<li>当事件发生时，事件源将事件对象传递给所有注册的监听器。</li>
<li>监听器对象将利用事件对象中的信息决定如何对事件做出响应。</li>
</ul>
<p>为了实现 ActionListener 接口，监听器类必须有一个被称为 actionPerformed 的方法，该方法接收一个 ActionEvent 对象参数。只要用户触发事件，事件源对象就会创建一个 ActionEvent 对象， 然后调用 listener.actionPerformed (event) 传递事件对象。</p>
<h5 id="简洁地指定监听器"><a href="#简洁地指定监听器" class="headerlink" title="简洁地指定监听器"></a>简洁地指定监听器</h5><p>lambda 表达式。匿名类。内部类。</p>
<p>创建实现了 ActionListener接口的事件源容器 ， 然后这个容器再设置自身作为监听器。</p>
<p>EventHandler 类可以用下面的调用创建这样一个监听器：<br>EventHandler.create (ActionListener.class, frame , “loadData”);<br>它使用反射来调用方法。出于这个原因， EventHandler.create 调用的第二个参数必须属于一个公有类。否则，反射机制就无法确定和调用目标方法。</p>
<h5 id="改变观感"><a href="#改变观感" class="headerlink" title="改变观感"></a>改变观感</h5><p>在默认情况下，Swing 程序使用 Metal 观感，可以采用两种方式改变观感。</p>
<p>第一种方式是在 Java 安装的子目录 jre/lib 下有一个文件 swing.properties。在这个文件中，将属性swing.defaultlaf 设置为所希望的观感类名。Metal 和 Nimbus 观感位于 javax.swing 包中。其他的观感包位于 com.sun.java 包中， 并且不是在每个 Java 实现中都提供。采用这种方式开启观感时必须重新启动程序。Swing 程序只在启动时读取一次 swing.properties 文件。</p>
<p>第二种方式是动态地改变观感。这需要调用静态的 UIManager.setLookAndFeel 方法，并提供所想要的观感类名， 然后再调用静态方法 SwingUtilities.updateComponentTreeUI 来刷新全部的组件集。这里需要向这个方法提供一个组件，并由此找到其他的所有组件。<br>UIManager.setLookAndFeel (className) ;<br>SwingUtilities.updateComponentTreeUI(frame);</p>
<p>使用匿名内部类来定义这个监听器。 要特别注意向 SwingUtilities.updateComponentTreeUI 传递 PlafFrame.this。而在一个 lambda 表达式中， this 就指示外围的对象。</p>
<h5 id="适配器类"><a href="#适配器类" class="headerlink" title="适配器类"></a>适配器类</h5><p>窗口监听器必须是实现 WindowListener 接口的类的一个对象。在 WindowListener 接口中包含 7 个方法。当发生窗口事件时，框架将调用这些方法响应 7 个不同的事件。在 Windows 下，通常将 iconified (图标化）称为minimized (最小化)。下面是完整的 WindowListener 接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface WindowListener &#123;</span><br><span class="line">	void windowOpened(WindowEvent e);</span><br><span class="line">	void windowClosing(WindowEvent e):</span><br><span class="line">	void windowClosed(WindowEvent e);</span><br><span class="line">	void windowIconified(WindowEvent e);</span><br><span class="line">	void windowDeiconified(WindowEvent e);</span><br><span class="line">	void windowActivated(WindowEvent e);</span><br><span class="line">	void windowDeactivated(WindowEvent e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够查看窗口是否被最大化， 需要实现 WindowStateListener 并覆盖 windowStateChanged 方法。</p>
<p>在 Java 中， 实现一个接口的任何类都必须实现其中的所有方法，在这里， 意味着需要实现 7 个方法。当然，可以这样定义实现这个接口的类：实现一个方法，其他 6个方法不做任何事情。书写 6 个没有任何操作的方法代码显然是一种乏味的工作。鉴于简化的目的，每个含有多个方法的 AWT 监听器接口都配有一个适配器（adapter) 类，这个类实现了接口中的所有方法， 但每个方法没有做任何事情。这意味着适配器类自动地满足了 Java 实现相关监听器接口的技术需求。可以通过扩展适配器类来指定对某些事件的响应动作，而不必实现接口中的每个方法。</p>
<p>最简练的代码是将适配器类定义为框架的匿名内部类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.addWindowListener(newWindowAdapter()&#123;</span><br><span class="line">	public void windowClosing(WindowEvent e) &#123;</span><br><span class="line">		if (user agrees)</span><br><span class="line">			System.exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>Swing 包提供了一种非常实用的机制来封装命令，并将它们连接到多个事件源，这就是Action 接口。</p>
<p>Action 接口包含下列方法：<br>void actionPerformed(ActionEvent event)<br>Action 接口扩展于 ActionListener 接口</p>
<p>void setEnabled(boolean b)<br>boolean isEnabled()<br>启用或禁用这个动作，并检査这个动作当前是否启用。当一个连接到菜单或工具栏上的动作被禁用时， 这个选项就会变成灰色。</p>
<p>void putValue(String key, Object value)<br>Object getValue(String key)<br>putValue 和 getvalue 方法允许存储和检索动作对象中的任意名 / 值。有两个重要的预定义字符串：Action.NAME 和 Action.SMALL_ICON，用于将动作的名字和图标存储到一个动作对象中。如果动作对象添加到菜单或工具栏上，它的名称和图标就会被自动地提取出来， 并显示在菜单项或工具栏项中。</p>
<p>预定义动作表名称:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>动作名称，显示在按钮和菜单上</td>
</tr>
<tr>
<td>SMALL_ICON</td>
<td>存储小图标的地方；显示在按钮、菜单项或工具栏中</td>
</tr>
<tr>
<td>SHORT-DESCRIPTION</td>
<td>图标的简要说明；显示在工具提示中</td>
</tr>
<tr>
<td>LONG_DESCRIPTION</td>
<td>图标的详细说明；使用在在线帮助中。没有 Swing 组件使用这个值</td>
</tr>
<tr>
<td>MNEONIC_KEY</td>
<td>快捷键缩写；显示在菜单项中</td>
</tr>
<tr>
<td>ACCELERATOR_KEY</td>
<td>存储加速击键的地方；Swing 组件不使用这个值</td>
</tr>
<tr>
<td>ACTION_COMMAND_KEY</td>
<td>历史遗留；仅在旧版本的 registerKeyboardAction 方法中使用</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>可能有用的综合属性；Swing 组件不使用这个值</td>
</tr>
</tbody></table>
<p>void addPropertyChangeListener(PropertyChangeListener listener)<br>void removePropertyChangeListener(PropertyChangeListener listener)<br>让其他对象在动作对象的属性发生变化时得到通告，尤其是菜单或工具栏触发的动作。</p>
<p>有一个类实现了这个接口除 actionPerformed 方法之外的所有方法，它就是 AbstractAction。这个类存储了所有名 / 值对， 并管理着属性变更监听器。</p>
<p>为了将动作与击键关联起来， 首先需要生成 Keystroke 类对象。这是一个很有用的类， 它封装了对键的说明。要想生成一个 Keystroke 对象，要调用 Keystroke 类中的静态 getKeyStroke 方法：<br>Keystroke ctrlBKey = Keystroke.getKeyStroke(“Ctrl B”);<br>keyboard focus是指当用户敲击键盘时， 这个动作会被发送给拥有焦点的组件。有时并不希望将击键发送给拥有焦点的组件。Swing 设计者给出了一种很便捷的解决方案。每个 JComponent 有三个输入映射（imputmap，) 每一个映射的 Keystroke 对象都与动作关联。三个输人映射对应着三个不同的条件。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>激活动作</th>
</tr>
</thead>
<tbody><tr>
<td>WHEN_FOCUSED</td>
<td>当这个组件拥有键盘焦点时</td>
</tr>
<tr>
<td>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</td>
<td>当这个组件包含了拥有键盘焦点的组件时</td>
</tr>
<tr>
<td>WHEN_IN_FOCUSED_WINDOW</td>
<td>当这个组件被包含在一个拥有键盘焦点组件的窗口中时</td>
</tr>
</tbody></table>
<p>按键处理将按照下列顺序检査这些映射：</p>
<ol>
<li>检查具有输入焦点组件的 WHEN_FOCUSED 映射。如果这个按键存在， 将执行对应的动作。如果动作已启用，则停止处理。</li>
<li>从具有输人焦点的组件开始， 检査其父组件的 WHEN_ANCESTOR_OF_FOCUSED_COMPONENT 映射。一旦找到按键对应的映射， 就执行对应的动作。如果动作已启用， 将停止处理。</li>
<li>査看具有输人焦点的窗口中的所有可视的和启用的组件， 这个按键被注册到 WHEN_IN_FOCUSED_WINDOW 映射中。给这些组件（按照按键注册的顺序）一个执行对应动作的机会。一旦第一个启用的动作被执行， 就停止处理。</li>
</ol>
<p>可以使用 getlnputMap 方法从组件中得到输人映射:<br>InputMap imap = panel.getInputMap(JComponent.WHEN_FOCUSED);</p>
<p>InputMap 不能直接地将 Keystroke 对象映射到 Action 对象。而是先映射到任意对象上，然后由 ActionMap 类实现将对象映射到动作上的第 2 个映射。这样很容易实现来自不同输入映射的按键共享一个动作的目的。<br>imap.put(KeyStroke.getKeyStroke(“ctrl Y”), “panel.yellow”)；<br>ActionMap amap = panel.getActionMap();<br>amap.put(“panel.yellow”, yellowAction);</p>
<p>使用字符串 none 表示空动作。这样可以轻松地取消一个按键动作：<br>imap.put(KeyStroke.getKeyStroke(“ctrl C”), “none”);</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>当用户点击鼠标按钮时， 将会调用三个监听器方法： 鼠标第一次被按下时调用 mousePressed ; 鼠标被释放时调用mouseReleased； 最后调用 mouseClicked。用 MouseEvent 类对象作为参数， 调用 getX 和 getY 方法可以获得鼠标被按下时鼠标指针所在的 x 和 y 坐标。 要想区分单击、 双击和三击，需要使用 getClickCount方法。</p>
<p>可以采用位掩码来测试已经设置了哪个修饰符。在最初的 API 中，有两个按钮的掩码与两个键盘修饰符的掩码一样， 即：<br>BUH0N2_MASK == ALT_MASK<br>BUTT0N3_MASK = META_MASK<br>这样做是为了能够让用户使用仅有一个按钮的鼠标通过按下修饰符键来模拟按下其他鼠标键的操作。然而， 在 Java SE 1.4中， 建议使用一种不同的方式。有下列掩码：<br>BUTT0N1_D0WN_MASK<br>BUTT0N2_D0WN_MASK<br>BUTT0N3_D0WN_MASK<br>SHIFT_DOWN_MASK<br>CTRL_DOWN_MASK<br>ALT_DOWN_MASK<br>ALT_CRAPH_DOWN_MASK<br>META_DOWN_MASK<br>getModifiersEx方法能够准确地报告鼠标事件的鼠标按钮和键盘修饰符。</p>
<p>有两个独立的接口 MouseListener 和 MouseMotionListener。这样做有利于提高效率。当用户移动鼠标时，只关心鼠标点击 (clicks) 的监听器就不会被多余的鼠标移动 (moves) 所困扰。</p>
<p>捕获鼠标动作事件， 以便在光标位于一个小方块之上时变成另外一种形状（十字)。实现这项操作需要使用 Cursor 类中的 getPredefinedCursor 方法。还可以利用 Toolkit 类中的 createCustomCursor 方法自定义光标类型。</p>
<p>mouseEntered 和 mouseExited。这两个方法是在鼠标进入或移出组件时被调用。</p>
<h3 id="AWT-事件继承层次"><a href="#AWT-事件继承层次" class="headerlink" title="AWT 事件继承层次"></a>AWT 事件继承层次</h3><p>所有的事件都是由 java.util 包中的 EventObject 类扩展而来的（公共超类不是 Event, 它是旧事件模型中的事件类名。尽管现在不赞成使用旧的事件模型，但这些类仍然保留在 Java 库中。)EventObject 类有一个子类 AWTEvent，它是所有 AWT 事件类的父类。有些 Swing 组件将生成其他事件类型的事件对象；它们都直接扩展于 EventObject, 而不是 AWTEvent。</p>
<p>AWT事件类的继承关系图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventObject &lt;- AWTEvent &lt;- ActionEvent, AdiustmentEvent, ComponentEvent, ItemEvent</span><br><span class="line">ComponentEvent &lt;- FocusEvent, InputEvent, PaintEvent, WindowEvent</span><br><span class="line">InputEvent &lt;- KeyEvent, MouseEvent</span><br><span class="line">MouseEvent &lt;- MouseWheelEvent</span><br></pre></td></tr></table></figure>
<p>事件对象封装了事件源与监听器彼此通信的事件信息。在必要的时候， 可以对传递给监听器对象的事件对象进行分析。</p>
<p>对于有些 AWT 事件类来说，Java 程序员并不会实际地使用它们。</p>
<h5 id="语义事件和底层事件"><a href="#语义事件和底层事件" class="headerlink" title="语义事件和底层事件"></a>语义事件和底层事件</h5><p>AWT 将事件分为底层（ low-level) 事件和语义（semantic ) 事件。语义事件是表示用户动作的事件。底层事件是形成那些事件的事件。调节滚动条是一种语义事件， 但拖动鼠标是底层事件。</p>
<p>下面是 java.awt.event 包中最常用的语义事件类：</p>
<ul>
<li>ActionEvent (对应按钮点击、 菜单选择、 选择列表项或在文本框中 ENTER );</li>
<li>AdjustmentEvent (用户调节滚动条；)</li>
<li>ItemEvent (用户从复选框或列表框中选择一项）。</li>
</ul>
<p>常用的 5 个底层事件类是：</p>
<ul>
<li>KeyEvent (一个键被按下或释放；)</li>
<li>MouseEvent ( 鼠标键被按下、 释放、 移动或拖动；)</li>
<li>MouseWheelEvent ( 鼠标滚轮被转动；)</li>
<li>FocusEvent (某个组件获得焦点或失去焦点；)</li>
<li>WindowEvent ( 窗口状态被改变）。</li>
</ul>
<p>下列接口将监听这些事件：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>方法</th>
<th>参数/访问方法</th>
<th>事件源</th>
</tr>
</thead>
<tbody><tr>
<td>ActionListener</td>
<td>actionPerformed</td>
<td>ActionEvent:getActionCommand、getModifiers</td>
<td>AbstractButton、JComboBox、JTextField、Timer</td>
</tr>
<tr>
<td>AdjustmentListener</td>
<td>adjustmentValueChanged</td>
<td>AdjustmentEvnet:getAdjustable、getAdjustmentType、getValue</td>
<td>JScrollbar</td>
</tr>
<tr>
<td>ItemListener</td>
<td>itemStateChanged</td>
<td>ItemEvent:getItem、getItemSelectable、getStateChange</td>
<td>AbstractButton、JcomboxBox</td>
</tr>
<tr>
<td>FocusListener</td>
<td>focusGained、FocusLost</td>
<td>FocusEvent:isTemporary</td>
<td>Component</td>
</tr>
<tr>
<td>KeyListener</td>
<td>keyPress、keyReleased、keyTyped</td>
<td>KeyEvent:getKeyChar、getKeyCode、getKeyModifiersText、getKeyText、isActionKey</td>
<td>Component</td>
</tr>
<tr>
<td>MouseListener</td>
<td>mousePress、mouseReleased、mouseEntered、mouseExited、mouseClicked</td>
<td>MouseEvent:getClickCount、getX、getY、getPoint、translatePoint</td>
<td>Component</td>
</tr>
<tr>
<td>MouseMotionListener</td>
<td>mouseDragged、mouseMoved</td>
<td>MouseEvent</td>
<td>Component</td>
</tr>
<tr>
<td>MouseWheelListener</td>
<td>mouseWheelMoved</td>
<td>MouseWheelEvent:getWheelRotation、getScrollAmount</td>
<td>Component</td>
</tr>
<tr>
<td>WindowListener</td>
<td>windowClosing、windowOpened、windowIconified、windowDeiconified、windowClosed、windowActivated、windowDeactivated</td>
<td>WindowEvent:getWindow</td>
<td>Window</td>
</tr>
<tr>
<td>WindowFocusListener</td>
<td>windowGainedFocus、windowLostFocus</td>
<td>WindowEvent:getOppositeWindow</td>
<td>Window</td>
</tr>
<tr>
<td>WindowStateListener</td>
<td>windowStateChanged</td>
<td>WindowEvent:getOldState、getNewState</td>
<td>Window</td>
</tr>
</tbody></table>
<p>下面是常用的适配器类：<br>FocusAdapter<br>MouseMotionAdapter<br>KeyAdapter<br>WindowAdapter<br>MouseAdapter</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Conversation</title>
    <url>/2020/11/21/Conversation/</url>
    <content><![CDATA[<img data-src="/2020/11/21/Conversation/The%20Silent%20League.jpg" class="" title="The Silent League">

<blockquote class="blockquote-center">
<p>Just a little conversation<br>About give me your picture<br>On the cover of a magazine<br>On the cover of a magazine<br>Just a little conversation<br>But how long it might take one?<br>To get along with such thing?<br>To get along with such thing?<br>But everybody knows<br>It’s easier to fall apart<br>Just a little conversation<br>About give me your picture<br>On the cover of a magazine<br>On the cover of a magazine</p>

</blockquote>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=3716423&auto=0&height=32"></iframe>]]></content>
      <tags>
        <tag>Songs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Deploy</title>
    <url>/2020/11/24/Linux-Deploy/</url>
    <content><![CDATA[<p>这是一篇旧文章，做个记录。</p>
<a id="more"></a>

<h3 id="通过-Linux-Deploy-在-Android-上安装-Linux"><a href="#通过-Linux-Deploy-在-Android-上安装-Linux" class="headerlink" title="通过 Linux Deploy 在 Android 上安装 Linux"></a>通过 Linux Deploy 在 Android 上安装 Linux</h3><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>一个 Root 了的 Android 手机</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnVzeWJveC5uZXQv">Busy Box<i class="fa fa-external-link-alt"></i></span>：Linux Deploy 支撑软件。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lZWZpay9saW51eGRlcGxveS9yZWxlYXNlcw==">Linux deploy<i class="fa fa-external-link-alt"></i></span>：Linux 系统支撑软件。</p>
<h5 id="安装-Busy-Box"><a href="#安装-Busy-Box" class="headerlink" title="安装 Busy Box"></a>安装 Busy Box</h5><p>点击安装，等待程序自行运行，在界面中输出 <code>## END</code> 后退出程序。</p>
<h5 id="Linux-deploy"><a href="#Linux-deploy" class="headerlink" title="Linux deploy"></a>Linux deploy</h5><ul>
<li>点击左图左上角部分，选择 <strong>设置</strong>，在设置界面中找到PATH变量，赋予其值 <code>/system/xbin</code>。</li>
<li>建议开启 <strong>锁定Wifi</strong> 功能。</li>
<li>接着退回主界面，点击右下角部分。</li>
<li><strong>发行版</strong> 看个人喜好选择，Debian 系（Debian，Kaili，Ubuntu）较热门。</li>
<li><strong>架构</strong> 默认。</li>
<li><strong>源</strong> 默认。如果下的慢的话，就仿照默认的源换为国内的源，如 <span class="exturl" data-url="aHR0cDovL21pcnJvcnMudXN0Yy5lZHUuY24v">USTC MIRRORS<i class="fa fa-external-link-alt"></i></span>，但是不要特意去换源，官方的源用的了的话官方的源最好。</li>
<li><strong>安装路径</strong> ：安装在手机自带的存储空间中，则在路径开头加上<code>$&#123;ENV_DIR&#125;</code>；安装在 <strong>sdcard</strong> 中，加上<code>$&#123;EXTERNAL_STORAGE&#125;</code>。</li>
<li><strong>文件系统</strong> ：推荐 <code>ext4</code>。</li>
<li><strong>用户名</strong> 和 <strong>密码</strong> 自定义。</li>
<li><strong>DNS</strong> 默认。</li>
<li><strong>本地化</strong> ：简体中文可以选择 <code>zh_CN.UTF-8</code>，建议选择 <code>en_US.UTF-8</code> 。</li>
<li><strong>挂载列表</strong>：添加访问手机内容的目录，<strong>手机目录：挂载点</strong>，如 <code>/sdcard:/mnt</code>，之后会自动挂载。</li>
<li>**开启<code>SSH</code>**。</li>
<li><strong>图形界面功能</strong>，需要的话就选 <code>XFce</code> 为桌面，XFce`是轻量级桌面环境。</li>
<li>退出系统设置界面，点击主界面右上角，选择安装。<br>  等待程序自行安装Linux系统，开始时会自动创造一个4G左右大小的img文件，这个是默认的大小，你可以根据你手机的容量自定义，创造文件需要一点时间，屏幕会很安静，再然后会安装各种东西，屏幕会输出很多信息，根据你的源的速度，等待时间不等，看到 <code>&lt;&lt;&lt;deploy</code> 则安装完毕。如果中间没有 <code>failed</code> 则安装成功。安装失败的话就需要重新安装，换个快一点的网，或者好一点的源。</li>
<li> <strong>注意：安装完毕后要先点击停止按钮，再按启动按钮</strong>。这个很重要，不然你就得重装了。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>Andorid 端用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nvbm5lY3Rib3QvY29ubmVjdGJvdC9yZWxlYXNlcw==">ConnectBox<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Windows用  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vcHV0dHkvbGF0ZXN0Lmh0bWw=">putty<i class="fa fa-external-link-alt"></i></span> ，图形界面用 <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVhbHZuYy5jb20vZW4vY29ubmVjdC9kb3dubG9hZC92aWV3ZXIv">VNC Viewer<i class="fa fa-external-link-alt"></i></span>。VNC Viewer 直接搜主机IP就行，VNC Server 在你选择安装图形界面功能时就自动安装了，不需要再安装 vnc4server。</p>
</li>
<li><p>Linux 输入<code>ssh username@hostname</code>就行。</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>安装后如果用 vnc viewer 只有一个点的话，可以换一个发行版，我尝试的 CentOS 有这个问题。</p>
</li>
<li><p>Linux连的时候出现 <code>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</code>：</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R + 输入服务器的IP</span><br></pre></td></tr></table></figure></li>
<li><p>altarch 架构的手机 CentOS 系统换源</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp CentOS-7-armhfp.repo CentOS-Base.repo</span><br><span class="line">mv CentOS-7-armhfp.repo CentOS-7-armhfp.repo.backup</span><br><span class="line">vi CentOS-Base.repo</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/centos-altarch/7.6.1810/os/armhfp/</span><br><span class="line">yum makecache</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如果你之前没有安装VNC的话，现在又想装：</strong></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install tigervnc-server</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title>Microservices</title>
    <url>/2020/11/26/Microservices/</url>
    <content><![CDATA[<p>定义：“微服务架构”这个术语描述这样一种特定的软件设计方法，即以若干组可独立部署的服务的方式进行软件应用系统的设计。</p>
<a id="more"></a>

<h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>一个单体应用系统（即服务端应用系统，一个单个可执行的逻辑程序）是以一个单个单元的方式来构建的。处理用户请求的所有逻辑都运行在一个单个的进程内。通过精心设计，就能在开发人员的笔记本电脑上运行和测试这样的应用系统，并且使用一个部署流水线来确保变更被很好地进行了测试，然后部署到生产环境中。但是渐渐地，特别是随着越来越多的应用系统正被部署到云端，软件变更受到了很大的限制，应用系统的一个很小的部分的一处变更，也需要将整个单体应用系统进行重新构建和部署。这导致了微服务架构风格的诞生：以构建一组小型服务的方式来构建应用系统。</p>
<h5 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h5><p>一个单体应用，往往将应用所有功能都打包在一起：</p>


<p>当用户访问量变大导致一台服务器无法支撑时，就加服务器加负载均衡：</p>


<p>之后把静态文件独立出来，通过 CDN 等进行加速，提升单体应用的整体响应：</p>


<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统的。其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务我们仅做最低限度的集中管理。</p>


<h5 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h5><p>微服务架构，核心是为了解决应用微服务之后的服务治理问题。</p>
<p>第一个问题就是服务发现问题，解决方法是服务注册中心：</p>


<p>第二个问题是服务配置管理的问题，解决方案是配置中心：</p>


<p>以上是应用内部的服务治理，当客户端或外部应用调用服务的时候就需要使用到服务网关提供统一的服务入口，最终形成典型微服务架构：</p>


<h3 id="微服务架构的九大特性"><a href="#微服务架构的九大特性" class="headerlink" title="微服务架构的九大特性"></a>微服务架构的九大特性</h3><p>不存在微服务架构风格的正式定义。但是可以描述所见到的能够被贴上微服务标签的那些架构的共性。</p>
<h5 id="特性一：“组件化”与“多服务”"><a href="#特性一：“组件化”与“多服务”" class="headerlink" title="特性一：“组件化”与“多服务”"></a>特性一：“组件化”与“多服务”</h5><p>微服务架构也会使用软件库，但其将自身软件进行组件化的主要方法是将软件分解为诸多服务。</p>
<ul>
<li>组件定义：一个组件就是一个可以独立更换和升级的软件单元。</li>
<li>软件库定义：它能被链接到一段程序，且能通过内存中的函数来进行调用。是进程内的组件。</li>
<li>服务：是进程外的组件，它们通过诸如web service请求或远程过程调用这样的机制来进行通信。</li>
</ul>
<p>以使用服务（而不是以软件库）的方式来实现组件化的原因是：</p>
<ul>
<li>服务可被独立部署。如果一个应用系统由在单个进程中的多个软件库所组成，那么对任一组件做一处修改，都不得不重新部署整个应用系统。但是如果该应用系统被分解为多个服务，那么对于一个服务的多处修改，仅需要重新部署这一个服务。</li>
<li>能获得更加显式的组件接口。通过使用显式的远程调用机制，服务能更容易地避免客户端破坏组件的封装，从而导致组件间出现过度紧密的耦合。</li>
</ul>
<p>不足：</p>
<ul>
<li>比起进程内调用，远程调用更加昂贵。</li>
<li>如果需要修改组件间的职责分配，那么当跨越进程边界时，这种组件行为的改动会更加难以实现。</li>
</ul>
<h5 id="特性二：围绕“业务功能”组织团队"><a href="#特性二：围绕“业务功能”组织团队" class="headerlink" title="特性二：围绕“业务功能”组织团队"></a>特性二：围绕“业务功能”组织团队</h5><p>康威定律：</p>
<blockquote><p>任何设计（广义上的）系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致。</p>
<footer><strong>Melvyn Conway</strong></footer></blockquote>

<p>当在寻求将一个大型应用系统分解成几部分时，公司管理层往往会聚焦在技术层面上。这会导致组建用户界面团队、服务器端团队和数据库团队。</p>


<p>当团队沿着这些技术线分开后，即使要实现软件一个简单的变更，也会导致跨团队的项目时延和预算审批。在这种情况下，聪明的团队会进行局部优化，直接把代码逻辑塞到他们能访问到的任意应用系统中。</p>
<p>微服务根据业务功能来将系统分解为若干服务。这些服务针对该业务领域提供多层次广泛的软件实现，包括用户界面、持久性存储以及任何对外的协作性操作。因此，团队是跨职能的。</p>


<h5 id="特性三：“做产品”而不是“做项目”"><a href="#特性三：“做产品”而不是“做项目”" class="headerlink" title="特性三：“做产品”而不是“做项目”"></a>特性三：“做产品”而不是“做项目”</h5><p>项目模型：目标是交付某一块软件。一旦完工后，软件就被移交给维护团队，构建该软件的项目团队就会被解散。</p>
<p>微服务模型（产品理念）：一个团队在一个产品的整个生命周期中都应该保持对其拥有。这会使开发人员每天都会关注软件是如何在生产环境下运行的，并且增进他们与用户的联系，因为他们必须承担某些支持工作。</p>
<h5 id="特性四：“智能端点”与“傻瓜管道”"><a href="#特性四：“智能端点”与“傻瓜管道”" class="headerlink" title="特性四：“智能端点”与“傻瓜管道”"></a>特性四：“智能端点”与“傻瓜管道”</h5><p>当在不同的进程之间构建各种通信结构时，许多产品和方法强调将大量的智能特性纳入通信机制本身。</p>
<p>微服务社区主张智能端点和傻瓜管道。使用微服务所构建的各个应用的目标，都是尽可能地实现“高内聚和低耦合”——他们拥有自己的领域逻辑，并且更多地是像经典Unix的“过滤器”那样来工作。这些应用通过使用一些简单的REST风格的协议来进行编制，而不去使用复杂的协议。</p>
<p>微服务最常用的两种协议是：带有资源API的HTTP“请求－响应”协议，和轻量级的消息发送协议。对于前一种协议的最佳表述是：</p>
<blockquote><p>Be of the web, not behind the web</p>
<footer><strong>Ian Robinson</strong></footer></blockquote>

<h5 id="特性五：“去中心化”地治理技术"><a href="#特性五：“去中心化”地治理技术" class="headerlink" title="特性五：“去中心化”地治理技术"></a>特性五：“去中心化”地治理技术</h5><p>使用中心化的方式来对开发进行治理，其中一个后果，就是趋向于在单一技术平台上制定标准。我们更喜欢根据工作的不同来选用合理的工具。</p>
<h5 id="特性六：“去中心化”地管理数据"><a href="#特性六：“去中心化”地管理数据" class="headerlink" title="特性六：“去中心化”地管理数据"></a>特性六：“去中心化”地管理数据</h5><p>去中心化地管理数据，其表现形式多种多样。从最抽象的层面看，这意味着各个系统对客观世界所构建的概念模型，将彼此各不相同。微服务趋向使用“实战检验”的标准而非“强制执行”的标准。</p>
<p>如同在概念模型上进行去中心化的决策一样，微服务也在数据存储上进行去中心化的决策。单体应用在逻辑上各自使用一个单独的数据库来持久化数据，但是各家企业往往喜欢一系列单体应用共用一个单独的数据库。微服务更喜欢让每一个服务来管理其自有数据库。这种方法被称作“多语种持久化”。</p>


<h5 id="特性七：“基础设施”自动化"><a href="#特性七：“基础设施”自动化" class="headerlink" title="特性七：“基础设施”自动化"></a>特性七：“基础设施”自动化</h5><p>基础设施自动化技术已经得到长足的发展。云的演进，特别是AWS的发展，已经降低了构建、部署和运维微服务的操作复杂性。</p>
<p>构建流水线：</p>


<p>部署在单块系统和微服务上没什么区别。然而，两者在运维领域的情况却截然不同：</p>


<h5 id="特性八：“容错”设计"><a href="#特性八：“容错”设计" class="headerlink" title="特性八：“容错”设计"></a>特性八：“容错”设计</h5><p>使用各个微服务来替代组件，其结果是各个应用程序需要设计成能够容忍这些服务所出现的故障。</p>
<p>因为各个服务可以在任何时候发生故障，所以两件事就变得很重要，即能够快速地检测出故障，且在可能的情况下能够自动恢复服务。</p>
<h5 id="特性九：“演进式”设计"><a href="#特性九：“演进式”设计" class="headerlink" title="特性九：“演进式”设计"></a>特性九：“演进式”设计</h5><p>微服务的从业者们将服务的分解，视作一个额外的工具，来让应用开发人员能够控制应用系统中的变化，而无须减少变化的发生。</p>
<p>要将软件系统分解为各个组件时，决定切分应用系统时应该遵循的原则是：一个组件的关键属性，是具有独立更换和升级的特点。</p>
<p>这种强调可更换性的特点，是模块化设计一般性原则的一个特例，通过“变化模式”来驱动进行模块化的实现。将那些同时发生变化的东西，放到同一个模块中；很少发生变化的部分，放到不同的服务中。如果发现需要同时反复变更两个服务，这就是它们需要被合并信号。</p>
<h3 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h3><ul>
<li>Spring Cloud</li>
</ul>


<ul>
<li>Dubbo</li>
</ul>


<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2FydGljbGVzL21pY3Jvc2VydmljZXMuaHRtbA==">Microservices<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83MjkzYjE0ODAyOGY=">微服务入门这一篇就够了<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>04对象与类</title>
    <url>/2021/04/26/04%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><p>Java 是完全面向对象的， 必须熟悉 OOP 才能够编写 Java 程序。</p>
<p>面向对象的程序是由对象组成的， 每个对象包含对用户公开的特定功能部分和隐藏的实现部分。OOP 中， 不必关心对象的具体实现，只要能够满足用户的需求即可。</p>
<p>传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程， 就要开始考虑存储数据的方式。而 OOP 却调换了这个次序， 将数据放在第一位，然后再考虑操作数据的算法。</p>
<a id="more"></a>

<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>类（ class) 是构造对象的模板或蓝图。由类构造（construct) 对象的过程称为创建类的实例 （instance )。</p>
<p>封装（ encapsulation , 有时称为数据隐藏） 是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（ instance field ), 操纵数据的过程称为方法（ method ）。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（ state )。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性的关键。 这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据， 其他对象就不会知道或介意所发生的变化。</p>
<p>继承（inheritance）是通过扩展一个类来建立另外一个类的过程，这会让用户自定义 Java 类变得轻而易举。在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>对象的三个主要特性：<br>对象的行为（behavior)—可以对对象施加哪些方法？<br>对象的状态（state )—当施加那些方法时，对象如何响应？<br>对象标识（identity )—如何辨别具有相同行为与状态的不同对象？</p>
<p>作为一个类的实例， 每个对象的标识永远是不同的，状态常常也存在着差异。</p>
<h5 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h5><p>对于学习 OOP 的初学者来说：首先从设计类开始，然后再往每个类中添加方法。</p>
<p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。</p>
<h5 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h5><p>在类之间， 最常见的关系有：</p>
<ol>
<li><p>依赖（“ uses-a”）<br>如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应该尽可能地将相互依赖的类减至最少。用软件工程的术语来说，就是让类之间的耦合度最小。</p>
</li>
<li><p>聚合（“ has-a”）<br>聚合关系意味着类 A 的对象包含类 B 的对象。</p>
</li>
<li><p>继承（“ is-a”）<br>继承是一种用于表示特殊与一般关系的。一般而言， 如果类 A 扩展类 B, 类 A 不但包含从类 B 继承的方法，还会拥有一些额外的功能。</p>
</li>
</ol>
<h3 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h3><p>在 Java 中， 没有类就无法做任何事情。但并不是所有的类都具有面向对象特征。</p>
<h5 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h5><p>要想使用对象，就必须首先构造对象， 并指定其初始状态。</p>
<p>在 Java 程序设计语言中， 使用构造器（constructor ) 构造新实例。构造器是一种特殊的方法， 用来构造并初始化对象。构造器的名字应该与类名相同。要想构造一个对象， 需要在构造器前面加上new 操作符。</p>
<p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。</p>
<p>局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。</p>
<p>为什么用类描述时间， 而不像其他语言那样用一个内置的 （ built-in）类型？因为内置类型的适应性不好；如果使用类， 这些设计任务就交给了类库的设计者。如果类设计的不完善， 其他的操作员可以很容易地编写自己的类， 以便增强或替代（ replace) 系统提供的类。</p>
<h5 id="Java-类库中的-LocalDate-类"><a href="#Java-类库中的-LocalDate-类" class="headerlink" title="Java 类库中的 LocalDate 类"></a>Java 类库中的 LocalDate 类</h5><p>Date 类的实例有一个状态，即特定的时间点。是用距离一个固定时间点的毫秒数（可正可负） 表示的， 这个点就是所谓的纪元（epoch), 它 是 UTC 时间 1970 年 1 月 1 日 00:00:00。</p>
<p>类库设计者决定将保存时间与给时间点命名分开。所以标准 Java 类库分别包含了两个类：一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。</p>
<p>LocalDate 类使用静态工厂方法 (factorymethod) 调用构造器 ：LocalDate.now()<br>可以提供年、 月和日来构造对应一个特定日期的对象：LocalDate.of(year, month, day)<br>用方法 getYear、 getMonthValue 和 getDayOfMonth得到年、月和日<br>plusDays 方法会得到距当前对象指定天数的一个新日期</p>
<p>最好不要使用废弃不用的方法， 因为将来的某个类库版本很有可能将它们完全删除。</p>
<h5 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h5><p>plusDays 方法会生成一个新的 LocalDate 对象，而不是改变原来的对象。</p>
<p>GregorianCalendar.add 方法是一个更改器方法 ( mutator method ) 调用这个方法后， 对象的状态会改变。</p>
<p>只访问对象而不修改对象的方法称为访问器方法。</p>
<h3 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h3><h5 id="Employee-类"><a href="#Employee-类" class="headerlink" title="Employee 类"></a>Employee 类</h5><p>在 Java 中， 最简单的类定义形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassName</span><br><span class="line">&#123;</span><br><span class="line">	field1</span><br><span class="line">	field2</span><br><span class="line">	...</span><br><span class="line">	constructor1</span><br><span class="line">	constructor2</span><br><span class="line">	...</span><br><span class="line">	method1</span><br><span class="line">	method2</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名必须与 public 类的名字相匹配。在一个源文件中， 只能有一个公有类，但可以有任意数目的非公有类。</p>
<h5 id="多个源文件的使用"><a href="#多个源文件的使用" class="headerlink" title="多个源文件的使用"></a>多个源文件的使用</h5><p>将可以有两种编译源程序的方法，一种是使用通配符调用 Java 编译器；或者直接编译包含main方法的文件，编译器就会自动地搜索需要的类并对它进行编译，如果 java 文件较已有的 class 文件版本新，Java 编译器就会自动地重新编译这个文件。</p>
<h5 id="剖析-Employee-类"><a href="#剖析-Employee-类" class="headerlink" title="剖析 Employee 类"></a>剖析 Employee 类</h5><p>关键字 public 意味着任何类的任何方法都可以调用这些方法。可以用 public 标记实例域，但破坏了封装，这是一种极为不提倡的做法 。</p>
<p>关键字 private 确保只有类自身的方法能够访问实例域， 而其他类的方法不能够读写这些域。</p>
<h5 id="从构造器开始"><a href="#从构造器开始" class="headerlink" title="从构造器开始"></a>从构造器开始</h5><p>构造器与类同名。在构造类的对象时， 构造器会运行，以便将实例域初始化为所希望的状态。</p>
<p>构造器与其他的方法有一个重要的不同，构造器总是伴随着 new 操作符的执行被调用，不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p>
<p>每个类可以有一个以上的构造器，构造器可以有 0 个、1 个或多个参数，构造器没有返回值。</p>
<p>不要在构造器中定义与实例域重名的局部变量。</p>
<h5 id="隐式参数与显式参数"><a href="#隐式参数与显式参数" class="headerlink" title="隐式参数与显式参数"></a>隐式参数与显式参数</h5><p>方法用于操作对象以及存取它们的实例域。</p>
<p>方法有两个参数。 第一个参数称为隐式 （implicit) 参数， 是出现在方法名前的对象。第二个参数位于方法名后面括号中的数值，这是一个显式 （explicit) 参 数 （ 有些人把隐式参数称为方法调用的目标或接收者)。</p>
<p>在每一个方法中， 关键字 this 表示隐式参数。</p>
<h5 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h5><p>应该提供下面三项内容： </p>
<ol>
<li>私有的数据域；</li>
<li>公有的域访问器方法；</li>
<li>公有的域更改器方法。</li>
</ol>
<p>好处：<br>可以改变内部实现，除了该类的方法之外，不会影响其他代码。<br>更改器方法可以执行错误检查，直接对域进行赋值将不会进行这些处理。</p>
<p>不要编写返回可变对象引用的访问器方法。一个外部对象变量a和一个对象b的私有域引用同一个对象c，对外部对象变量a调用c的更改器方法就可以改变对象b的私有域状态，而不是通过对象b的更改器方法。如果需要返回一个可变对象的引用， 应该首先对它进行克隆（clone )。对象 clone 是指存放在另一个位置上的对象副本。</p>
<h5 id="基于类的访问权限"><a href="#基于类的访问权限" class="headerlink" title="基于类的访问权限"></a>基于类的访问权限</h5><p>一个方法可以访问所属类的所有对象的私有数据。</p>
<h5 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h5><p>在实现一个类时，由于公有数据非常危险， 所以应该将所有的数据域都设置为私有的。</p>
<p>若将一个计算代码划分成若干个独立的辅助方法， 这些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密， 或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设计为 private 的，因为它不会被外部的其他类操作调用，可以随时将其更改或删去。</p>
<h5 id="final-实例域"><a href="#final-实例域" class="headerlink" title="final 实例域"></a>final 实例域</h5><p>可以将实例域定义为 final，构建对象时必须初始化这样的域，之后不能够再对它进行修改。</p>
<p>final 修饰符大都应用于基本 （primitive ) 类型域，或不可变（immutable) 类的域（如果类中的每个方法都不会改变其对象， 这种类就是不可变的类）。</p>
<p>对于可变的类，final 关键字只是表示存储在变量中的对象引用不会再指向其他类的对象，但这个对象可以更改。</p>
<h3 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><h5 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h5><p>如果将域定义为 static, 每个类中只有一个这样的域。即使没有一个对象， 静态域也存在。它属于类，而不属于任何独立的对象。静态域也称为类域。</p>
<h5 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h5><p>用 public static final 修饰静态常量（类常量）。</p>
<p>非 Java 语言实现的本地方法可以绕过 Java 语言的存取控制机制，修改静态常量。</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>静态方法是一种不能向对象施操作的方法。换句话说，没有隐式参数。静态方法可以访问自身类中的静态域。</p>
<p>可以使用对象调用静态方法。不过，这种方式很容易造成混淆，其原因是方法计算的结果与对象毫无关系。建议使用类名， 而不是对象来调用静态方法。</p>
<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>静态方法可用于静态工厂方法 (factory method) 来构造对象。</p>
<p>为什么不利用构造器而使用静态工厂方法呢？ 主要有两个原因：</p>
<ol>
<li>构造器无法重命名。但希望用不同名字构造对象。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而静态方法可以返回一个其他类对象。</li>
</ol>
<h5 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h5><p>启动程序时，静态的 main 方法将执行并创建程序所需要的对象。</p>
<p>每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。</p>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>按值调用 （call by value) 表示方法接收的是调用者提供的值。而按引用调用 （ call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值所对应的变量值。</p>
<p>Java 程序设计语言总是采用按值调用。方法得到的是参数值的一个拷贝。</p>
<p>方法参数共有两种类型：</p>
<ol>
<li>基本数据类型；</li>
<li>对象引用。（不要将引用变量的值与对象本身混淆，对象的引用与对象本身是两个东西）</li>
</ol>
<p>总结方法参数的使用情况：<br>一个方法不能修改一个基本数据类型的参数。<br>一个方法可以改变一个对象参数的状态。<br>一个方法不能让对象参数引用一个新的对象。</p>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>如果多个方法有相同的名字、 不同的参数，便产生了重载。</p>
<p>编译器挑选出具体执行哪个方法过程被称为重载解析（overloading resolution)。</p>
<p>Java 允许重载任何方法。要完整地描述一个方法，需要指出方法名以及参数类型，这叫做方法的签名（signature)。返回类型不是方法签名的一部分。</p>
<h5 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h5><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null，但是，这并不是一种良好的编程习惯。局部变量不会自动初始化。</p>
<h5 id="无参数的构造器"><a href="#无参数的构造器" class="headerlink" title="无参数的构造器"></a>无参数的构造器</h5><p>很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时， 其状态会设置为适当的默认值。</p>
<p>如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器，这个构造器将所有的实例域设置为默认值。</p>
<p>仅当类没有提供任何构造器的时候， 系统才会提供一个默认的构造器。</p>
<h5 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h5><p>通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p>
<p>在执行构造器之前，先执行域的赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。</p>
<h5 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h5><p>技巧：</p>
<ol>
<li>在每个参数前面加上一个前缀“a”；</li>
<li>它基于这样的事实：参数变量用同样的名字将实例域屏蔽起来。可以采用 this.var 的形式访问实例域。</li>
</ol>
<h5 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h5><p>如果构造器的第一个语句形如 this(…)， 这个构造器将调用同一个类的另一个构造器。采用这种方式使用 this 关键字非常有用， 这样对公共的构造器代码部分只编写一次即可。</p>
<h5 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h5><p>初始化数据域的方法： </p>
<ol>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块（initializationblock)。</li>
</ol>
<p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。先运行初始化块，然后才运行构造器的主体部分。但通常会直接将初始化代码放在构造器中。建议将初始化块放在域定义之后。</p>
<p>调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值；</li>
<li>按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块；</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体；</li>
<li>执行这个构造器的主体。</li>
</ol>
<p>可以使用一个静态的初始化块来对静态域进行初始化。将代码放在一个块中，并标记关键字 static。在类第一次加载的时候， 将会进行静态域的初始化。所有的静态初始化语句以及静态初始化块都将依照类定义的顺序执行。</p>
<p>在 JDK 6 之前， 都可以用 Java 编写一个没有 main 方法的“ Hello,World” 程序。当用 java 调用这个类时， 就会加栽这个类， 静态初始化块将会打印“ Hello,World”。在此之后，会显示一个消息指出main 未定义。 从 Java SE 7 以后，java 程序首先会检查是否有一个 main 方法。</p>
<h5 id="对象析构与-finalize-方法"><a href="#对象析构与-finalize-方法" class="headerlink" title="对象析构与 finalize 方法"></a>对象析构与 finalize 方法</h5><p>由于 Java 有自动的垃圾回收器，不需要人工回收内存， 所以 Java 不支持析构器。</p>
<p>某些对象使用了内存之外的其他资源，在这种情况下，当资源不再需要时， 将其回收和再利用将显得十分重要。可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个方法什么时候才能够调用。 System.mnFinalizersOnExit(true) 的方法能够确保 finalizer 方法在 Java 关闭前被调用。不过，这个方法并不安全，也不鼓励大家使用。有一种代替的方法是使用 Runtime.addShutdownHook 添加“ 关闭钓” （shutdown hook)。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Java 允许使用包（ package ）将类组织起来。</p>
<p>标准的 Java包具有一个层次结构。可以使用嵌套层次组织包。所有标准的 Java 包都处于java 和 javax 包层次中。</p>
<p>使用包的主要原因是确保类名的唯一性。假如建立了两个同名类，只要将这些类放置在不同的包中， 就不会产生冲突。为了保证包名的绝对唯一性， Sun 公司建议将公司的因特网域名以逆序的形式作为包名，并且对于不同的项目使用不同的子包。从编译器的角度来看， 嵌套的包之间没有任何关系。</p>
<h5 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h5><p>可以采用两种方式访问另一个包中的公有类：<br>第一种方式是在每个类名之前添加完整的包名。<br>更简单且更常用的方式是使用 import 语句，import 语句是一种引用包含在包中的类的简明描述。一旦使用了 import 语句，在使用类时，就不必写出包的全名了。</p>
<p>可以使用 import 语句导人一个特定的类或者整个包。import 语句应该位于源文件的顶部(但位于 package 语句的后面。只能使用星号（*) 导入一个包， 而不能使用 import java.* 或 import java.<em>.</em> 导入以 java 为前缀的所有包。</p>
<p>用 * 导入所需包在发生命名冲突的时候，可以采用增加一个特定的 import 语句来解决这个问题。如果这两个类都需要使用，就在每个类名的前面加上完整的包名。</p>
<p>在包中定位类是编译器 （ compiler) 的工作。类文件中的字节码使用完整的包名来引用其他类。</p>
<h5 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h5><p>import static 语句导人静态方法和静态域。</p>
<h5 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h5><p>要想将一个类放人包中， 就必须将包的名字放在源文件的开头，包中定义类的代码之前。</p>
<p>如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包( defaulf package ) 中，默认包是一个没有名字的包。</p>
<p>要将包中的文件放到与完整的包名匹配的子目录中。编译器将类文件也放在相同的目录结构中。</p>
<p>要从基目录编译和运行类。编译器对文件 （带有文件分隔符和扩展名 .java 的文件）进行操作。而 Java 解释器加载类（带有 . 分隔符 )。编译器在编译源文件的时候不检查目录结构，但如果包与目录不匹配，虚拟机就找不到类。</p>
<h5 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h5><p>标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。如果没有指定 public 或 private , 这个部分可以被同一个包中的所有方法访问。</p>
<p>默认情况下，包不是一个封闭的实体。也就是说， 任何人都可以向包中添加更多的类。可以通过包密封 ( package sealing) 机制来解决将各种包混杂在一起的问题。如果将一个包密封起来， 就不能再向这个包添加类了。</p>
<p>从 1.2 版开始， JDK 的实现者修改了类加载器， 明确地禁止加载用户自定义的、 包名以“ java.” 开始的类。</p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><p>类文件也可以存储在 JAR(Java 归档）文件中。在一个 JAR 文件中， 可以包含多个压缩形式的类文件和子目录， 这样既可以节省又可以改善性能。在程序中用到第三方( third-party ) 的库文件时，通常会给出一个或多个 JAR 文件。JAR 文件使用 ZIP 格式组织文件和子目录，可以使用所有 ZIP 实用程序查看 JAR 文件。</p>
<p>为了使类能够被多个程序共享，需要做到下面几点：</p>
<ol>
<li>把类放到一个目录中，这个目录是包树状结构的基目录；</li>
<li>将 JAR 文件放在一个目录中；</li>
<li>设置类路径（classpath)。类路径是所有包含类文件的路径的集合。</li>
</ol>
<p>类路径包括：</p>
<ol>
<li>基目录；</li>
<li>当前目录（.)；</li>
<li>JAR 文件。从 Java SE 6 开始，可以在 JAR 文件目录中指定通配符，但在 UNIX 中，禁止使用 * 以防止 shell 命令进一步扩展。运行时库文件（ rt.jar 和在 jre/lib 与 jre/lib/ext 目录下的一些其他的 JAR 文件） 会被自动地搜索， 所以不必将它们显式地列在类路径中。</li>
</ol>
<p>javac 编译器总是在当前的目录中查找文件， 但 Java 虚拟机仅在类路径中有“.”目录的时候才查看当前目录。</p>
<p>虚拟机要搜寻类文件。首先查看系统类文件。然后再按照类路径依次查找。</p>
<p>编译器搜寻类，依次查找java.lang包，导入的包，以及当前包，然后对类路径中所有类逐一查看。</p>
<h5 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h5><p>最好采用 -classpath (或 -cp) 选项指定类路径。也可以通过设置 CLASSPATH 环境变量完成这个操作。</p>
<p>将 CLASSPATH 环境变量设置为永久不变的值是一个很糟糕的主意，人们有可能会忘记全局设置， 因此， 当使用的类没有正确地加载进来时，会感到很奇怪。</p>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>javadoc 可以由源文件生成一个 HTML 文档。联机 API 文档就是通过对标准 Java 类库的源代码运行 javadoc 生成的。</p>
<p>在源代码中添加以定界符 /**开始的注释， 可以很容易地生成一个文档。这种方式可以将代码与注释保存在一个地方，在修改源代码的同时， 重新运行 javadoc 就可以轻而易举地保持代码和注释的一致性。</p>
<h5 id="注释的插入"><a href="#注释的插入" class="headerlink" title="注释的插入"></a>注释的插入</h5><p>javadoc 实用程序（utility) 从下面几个特性中抽取信息：</p>
<ol>
<li>包 </li>
<li>公有类与接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ol>
<p>应该为每个特性编写注释，注释应该放置在所描述特性的前面。注释以<code> /**</code>开始，并 以 <code>*/ </code>结束。每个<code>/**</code> …<code> */</code> 文档注释在标记之后紧跟着自由格式文本（ free-form text )，标记由@开始。自由格式文本的第一句应该是一个概要性的句子，javadoc 实用程序自动地将这些句子抽取出来形成概要页。</p>
<p>在自由格式文本中，可以使用 HTML 修饰符。不要使用 <code>&lt;hl&gt; </code>或<code> &lt;hr&gt;</code>, 因为它们会与文档的格式产生冲突。若要键入等宽代码，需使用 {@code … } 而不是<code>&lt;code&gt;</code>…<code>&lt;/code&gt;</code>，这样就不用操心 &lt; 字符转义。</p>
<p>如果文档中有到其他文件的链接，就应该将这些文件放到子目录 doc-files 中。javadoc 实用程序将从源目录拷贝这些目录及其中的文件到文档目录中。在链接中需要使用 doc-files 目录。</p>
<h5 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h5><p>类注释必须放在 import 语句之后，类定义之前。</p>
<h5 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h5><p>每一个方法注释必须放在所描述的方法之前。</p>
<p>除了通用标记之外，还可以使用下面的标记：<br>@param 变量描述<br>这个标记将对当前方法的“ param” （参数）部分添加一个条目。这个描述可以占据多行， 并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。<br>@return 描述<br>这个标记将对当前方法添加“ return” （返回）部分。这个描述可以跨越多行， 并可以使用 HTML 标记。<br>@throws 类描述<br>这个标记将添加一个注释， 用于表示这个方法有可能抛出异常。</p>
<h5 id="域注释"><a href="#域注释" class="headerlink" title="域注释"></a>域注释</h5><p>只需要对公有域（通常指的是静态常量）建立文档。</p>
<h5 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h5><p>下面的标记可以用在类文档的注释中：<br>@author  姓名<br>这个标记将产生一个“author” (作者）条目。可以使用多个 @author 标记，每个 @author 标记对应一个作者。<br>@version 文本<br>这个标记将产生一个“version”（版本）条目。这里的文本可以是对当前版本的任何描述。</p>
<p>下面的标记可以用于所有的文档注释中：<br>@since 文本<br>这个标记将产生一个“ since” （始于）条目。这里的 text 可以是对引人特性的版本描述。<br>@deprecated 文本<br>这个标记将对类、 方法或变量添加一个不再使用的注释。文本中给出了取代的建议。<br>@see 引用<br>这个标记将在 “see also” 部分增加一个超级链接。可以为一个特性添加多个 @see 标记，但必须将它们放在一起。<br>这里的引用可以选择下列情形之一：</p>
<ol>
<li>package.class#feature label<br>可以省略包名和类名。</li>
<li><code>&lt;a href=&quot;...&quot;&gt;label&lt;/a&gt; </code><br>可以指定一个可选的标签（ label ) 作为链接锚（link anchor) 。如果省略了 label , 用户看到的锚的名称就是目标代码名或 URL。</li>
<li>“text”<br>文本显示在 “see also” 部分。<br>{@link …} 超链接<br>这里的特性描述规则与 @see 标记规则一样。</li>
</ol>
<h5 id="包与概述注释"><a href="#包与概述注释" class="headerlink" title="包与概述注释"></a>包与概述注释</h5><p>要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择：</p>
<ol>
<li>提供一个以 package.html 命名的 HTML 文件。在标记<code> &lt;body&gt;</code>—<code>&lt;/body&gt; </code>之间的所有文本都会被抽取出来。 </li>
<li>提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 <code>/** </code>和 <code>*/</code> 界定的 Javadoc 注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li>
</ol>
<p>可以为所有的源文件提供一个概述性的注释。这个注释将被放置在一个名为 overview.html 的文件中，这个文件位于包含所有源文件的父目录中。标记 <code>&lt;body&gt;</code>…<code>&lt;/body&gt;</code> 之间的所有文本将被抽取出来。当用户从导航栏中选择“ Overview ” 时，就会显示出这些注释内容。</p>
<h5 id="注释的抽取"><a href="#注释的抽取" class="headerlink" title="注释的抽取"></a>注释的抽取</h5><p>执行以下步骤：</p>
<ol>
<li>切换到包含想要生成文档的源文件目录。 如果有嵌套的包要生成文档， 就必须切换到包含子目录的目录。</li>
<li>生成文档 ：<br>一个包：javadoc -d docDirectory nameOfPackage<br>多个包：javadoc -d docDirectory nameOfPackage1 nameOfPackage2 …<br>文件在默认包中：javadoc -d docDirectory *.java</li>
</ol>
<p>如果省略了 -d docDirectory 选项， 那 HTML 文件就会被提取到当前目录下。这样有可能会带来混乱，因此不提倡这种做法。</p>
<p>可以使用多种形式的命令行选项对 javadoc 程序进行调整。</p>
<p>如果需要进一步的定制，可用 doclet, 以便生成想要的任何输出形式。</p>
<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型。用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于修改。</li>
<li>不是所有的域都需要独立的域访问器和域更改器</li>
<li>将职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责。命名类名的良好习惯是采用一个名词、前面有形容词修饰的名词或动名词修饰名词。对于方法来说，习惯是访问器方法用小写 get 开头, 更改器方法用小写的set 开头。</li>
<li>优先使用不可变的类。更改对象的问题在于， 如果多个线程试图同时更新一个对象，就会发生并发更改。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。</li>
</ol>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>05继承</title>
    <url>/2021/04/26/05%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>继承（inheritance)。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域， 以满足新的需求。</p>
<p>反射（ reflection) 是指在程序运行期间发现更多的类及其属性的能力。</p>
<a id="more"></a>

<h3 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h3><h5 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h5><p>关键字 extends 表明正在构造的新类派生于一个已存在的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">subClassName</span> <span class="keyword">extends</span> <span class="title">superClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	添加方法和域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已存在的类称为超类( superclass)、 基类（ base class) 或父类（parent class); 新类称为子类（subclass) 、派生类( derived class) 或孩子类（child class)。 超类和子类是 Java 程序员最常用的两个术语。</p>
<p>前缀“ 超” 和“ 子” 来源于计算机科学和数学理论中的集合语言的术语。即超集与子集。</p>
<p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中。</p>
<h5 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h5><p>子类方法不能够直接地访问超类的私有域，必须借助于超类的公有的接口，可以使用关键字 super 调用超类的公有接口。</p>
<p>super 与 this 引用是不同概念。 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字。</p>
<p>在子类中可以增加域、 增加方法或覆盖超类的方法，然而无法删除继承的任何域和方法。</p>
<h5 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h5><p>由于子类的构造器不能访问超类的私有域， 所以必须利用超类的构造器对这部分私有域进行初始化，可以通过 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。</p>
<p>如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。</p>
<p>一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。</p>
<h5 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h5><p>由一个公共超类派生出来的所有类的集合被称为继承层次（ inheritance hierarchy )。在继承层次中， 从某个特定的类到其祖先的路径被称为该类的继承链 ( inheritance chain) 。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>“is-a” 规则， 它表明子类的每个对象也是超类的对象。</p>
<p>”is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。</p>
<p>在 Java 程序设计语言中，对象变量是多态的。 一个对象变量既可以引用一个类的对象， 也可以引用一个该类的任何一个子类的对象。</p>
<p>不能将一个超类的引用赋给子类变量。 如果赋值成功，后面调用子类添加的方法时就会发生运行时错误。</p>
<p>在 Java 中，子类数组的引用可以转换成超类数组的引用。然后可以向其中添加超类的对象，这是一种很忌讳发生的情形，当该对象调用子类添加的方法的时候，将会导致调用一个不存在的实例域， 进而搅乱相邻存储空间的内容。为了确保不发生这类错误， 所有数组都要牢记创建它们的元素类型， 并负责监督仅将类型兼容的引用存储到数组中。否则引发 ArrayStoreException 异常。</p>
<h5 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h5><p>下面假设要调用 x.f(args) ，隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述：</p>
<ol>
<li>编译器査看对象的声明类型和方法名。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中可以访问且名为 f 的方法。</li>
<li>编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重栽解析（ overloading resolution)。</li>
<li>如果是 private 方法、 static 方法、 final 方法或者构造器， 那么编译器将可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定（ static binding )。 与此对应的是，调用的方法依赖于隐式参数的实际类型， 并且在运行时实现动态绑定。</li>
<li>当程序运行，并且采用动态绑定调用方法时， 虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。</li>
</ol>
<p>返回类型不是签名的一部分， 因此，在覆盖方法时， 一定要保证返回类型的兼容性。 允许子类将覆盖方法的返回类型定义为原返回类型的子类型，称为可协变的返回类型。</p>
<p>每次调用方法都要进行搜索，时间开销相当大。虚拟机预先为每个类创建了一个方法表（method table), 其中列出了所有方法的签名和实际调用的方法。在真正调用方法的时候， 虚拟机仅查找这个表就行了。</p>
<p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p>
<h5 id="阻止继承：final-类和方法"><a href="#阻止继承：final-类和方法" class="headerlink" title="阻止继承：final 类和方法"></a>阻止继承：final 类和方法</h5><p>不允许继承的类被称为 final 类。如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。</p>
<p>类中的特定方法声明为 final，子类就不能覆盖这个方法。</p>
<p>如果一个方法没有被覆盖并且很短， 编译器就能够对它进行优化处理， 这个过程为称为内联( inlining )。</p>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>用一对圆括号将目标类型括起来，并放置在需要转换的变量之前就可以了。</p>
<p>只能在继承层次内进行类型转换。在将超类转换成子类之前，应该使用 instanceof 进行检查。</p>
<p>如果 x 为 null ,  x instanceof C，会返回 false。</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>使用abstract 关键字，声明抽象方法，抽象方法不需要实现。包含一个或多个抽象方法的类本身必须被声明为抽象的。除了抽象方法之外， 抽象类还可以包含具体数据和具体方法。</p>
<p>抽象方法充当着占位的角色， 它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在抽象类中实现部分抽象类方法或不实现抽象类方法，这样就必须将子类也标记为抽象类；另一种是实现全部的抽象方法，这样一来，子类就不是抽象的了。</p>
<p>类即使不含抽象方法，也可以将类声明为抽象类。</p>
<p>抽象类不能被实例化。也就是说， 如果将一个类声明为abstract , 就不能创建这个类的对象。可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象。</p>
<h5 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h5><p>若要超类中的某些方法允许被子类直接访问， 或者允许子类的方法直接访问超类的某个域。可将这些方法或域声明为protected。</p>
<p>在实际应用中，要谨慎使用protected 属性的域。假设需要将设计的类提供给其他程序员使用， 而在这个类中设置了一些受保护域， 由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下， 如果需要对这个类的实现进行修改， 就必须通知所有使用这个类的程序员。这违背了OOP 提倡的数据封装原则。</p>
<p>受保护的方法更具有实际意义。这表明子类（可能很熟悉祖先类）得到信任， 可以正确地使用这个方法， 而其他类则不行。</p>
<p>Java 用于控制可见性的4 个访问修饰符：</p>
<ol>
<li>仅对本类可见private。</li>
<li>对所有类可见public：</li>
<li>对本包和所有子类可见protected。</li>
<li>对本包可见——默认，不需要修饰符。</li>
</ol>
<h3 id="Object：-所有类的超类"><a href="#Object：-所有类的超类" class="headerlink" title="Object： 所有类的超类"></a>Object： 所有类的超类</h3><p>Object 类是 Java 中所有类的始祖， 在Java 中每个类都是由它扩展而来的。</p>
<p>一个类如果没有明确地指出超类，Object 就被认为是这个类的超类。</p>
<p>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object 类。</p>
<h5 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h5><p>Object 类中的equals 方法用于检测一个对象是否等于另外一个对象。这个方法将判断两个对象是否具有相同的引用。</p>
<p>经常需要覆盖equals方法，检测两个对象状态的相等性， 如果两个对象的状态相等， 就认为这两个对象是相等的。</p>
<p>为了防备两个参数可能为null 的情况，需要使用Objects.equals 方法。如果两个参数都为null，Objects.equals(a，b) 调用将返回true ; 如果其中一个参数为null ，则返回false ; 否则， 如果两个参数都不为null， 则调用a.equals(b)。</p>
<h5 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h5><p>Java 语言规范要求equals 方法具有下面的特性：</p>
<ol>
<li>自反性： 对于任何非空引用x, x.equals(x)， 应该返回true。</li>
<li>对称性: 对于任何引用x 和y, 当且仅当y.equals(x) 返回true, x.equals(y) 也应该返回true。</li>
<li>传递性： 对于任何引用x、y 和z, 如果x.equals(y) 返回 true， y.equals(z) 返回true，x.equals(z) 也应该返回true。</li>
<li>一致性： 如果x 和y 引用的对象没有发生变化， 反复调用x.equals(y) 应该返回同样的结果。</li>
<li>对于任意非空引用x, x.equals(null) 应该返回false.</li>
</ol>
<p>如果隐式和显式的参数不属于同一个类， equals 方法将如何处理：<br>如果子类能够拥有自己的相等概念， 则对称性需求将强制采用 getClass 进行检测。<br>如果由超类决定等的概念，那么就可以使用 instanceof 进行检测， 这样可以在不同子类的对象之间进行相等的比较，同时应该将超类equals方法声明为final。</p>
<p>下面给出编写一个完美的 equals 方法的建议：</p>
<ol>
<li>显式参数为Object otherObject。</li>
<li>检测 this 与 otherObject 是否引用同一个对象：<br>if (this == otherObject) return true;</li>
<li>检测 otherObject 是否为 null, 如果为null, 返回false：<br>if (otherObject = null ) return false;</li>
<li>比较 this 与 otherObject 是否属于同一个类：<br>如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：<br>if (getClass() != otherObject.getCIass()) return false;<br>如果所有的子类都拥有统一的语义，就使用 instanceof 检测：<br>if (!(otherObject instanceof ClassName)) return false;</li>
<li>otherObject 转换为相应的类类型变量：<br>ClassName other = (ClassName) otherObject;</li>
<li>对所有需要比较的域进行比较。使用 == 比较基本类型域，使用 equals 比较对象域，使用Arrays.equals 比较数组域。如果所有的域都匹配， 就返回true; 否则返回false：<br>return field1 == other.field1<br>&amp;&amp; Objects.equa1s(field2, other.field2)<br>&amp;&amp; …;</li>
</ol>
<p>为了避免发生错误，可以使用 @Override 对覆盖超类的方法进行标记，如果出现了错误， 并且正在定义一个新方法， 编译器就会给出错误报告。</p>
<h5 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h5><p>散列码（ hash code ) 是由对象导出的一个整型值。</p>
<p>由于hashCode 方法定义在Object 类中， 因此每个对象都有一个默认的散列码，其值为对象的存储地址。</p>
<p>字符串的散列码是由内容导出的。</p>
<p>hashCode 方法应该返回一个整型数值（也可以是负数)，并合理地组合实例域的散列码,以便能够让各个不同的对象产生的散列码更加均匀。</p>
<p>需要组合多个散列值时， 可以调用ObjeCtS.hash 并提供多个参数。这个方法会对各个参数调用Objects.hashCode， 并组合这些散列值。</p>
<p>Equals 与 hashCode 的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode( ) 就必须与y.hashCode( ) 具有相同的值。</p>
<p>如果存在数组类型的域， 那么可以使用静态的Arrays.hashCode 方法计算一个散列码， 这个散列码由数组元素的散列码组成。</p>
<h5 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h5><p>toString用于返回表示对象值的字符串。</p>
<p>绝大多数（但不是全部）的toString 方法返回结果都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。</p>
<p>最好通过调用getClass( ).getName( ) 获得类名的字符串，而不要将类名硬加到toString 方法中。</p>
<p>随处可见toString 方法的主要原因是： 只要对象与一个字符串通过操作符“ +” 连接起来，Java 编译就会自动地调用toString 方法，以便获得这个对象的字符串描述。</p>
<p>Object 类定义了toString 方法， 用来打印输出对象所属的类名和散列码。</p>
<p>数组继承了object 类的 toString 方法， 数组类型将按照旧的格式打印。生成字符串“ [I@hashCode” （前缀[I 表明是一个整型数组）。修正的方式是调用静态方法Arrays.toString。要想打印多维数组（即， 数组的数组）则需要调用Arrays.deepToString 方法。</p>
<p>强烈建议为自定义的每一个类增加toString 方法。这样做不仅自己受益， 而且所有使用这个类的程序员也会从这个日志记录支持中受益匪浅。</p>
<h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在Java 中，允许在运行时确定数组的大小。</p>
<p>ArrayList 类。使用起来有点像数组，但在添加或删除元素时， 具有自动调节数组容量的功能，而不需要为此编写任何代码。</p>
<p>ArrayList 是一个采用类型参数（ type parameter ) 的泛型类（ generic class )。为了指定数组列表保存的元素对象类型， 需要用一对尖括号将类名括起来加在后面。Java SE 7 中， 可以省去右边的类型参数：<br><code>ArrayList&lt;className&gt; a = new ArrayListo&lt;&gt;；</code><br>这被称为“ 菱形” 语法， 因为空尖括号&lt;&gt;就像是一个菱形。编译器会检查新值是什么，如果赋值给一个变量， 或传递到某个方法， 或者从某个方法返回， 编译器会检査这个变量、参数或方法的泛型类型， 然后将这个类型放在&lt;&gt;中。</p>
<p>Java SE 5.0 以前的版本没有提供泛型类， 而是有一个ArrayList 类， 其中保存类型为Object 的元素， 它是“ 自适应大小” 的集合。如果使用老版本的Java, 则需要将所有的后缀 &lt;…&gt; 删掉,， 在Java SE 5.0 以后的版本中， 没有后缀&lt;…&gt; 仍然可以使用ArrayList, 它将被认为是一个删去了类型参數的“ 原始” 类型。</p>
<p>使用add 方法可以将元素添加到数组列表中。</p>
<p>数组列表管理着对象引用的一个内部数组。如果调用 add 且内部数组已经满了， 数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p>
<p>如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用ensureCapacity 方法。<br>还可以把初始容量传递给ArrayList 构造器：<br><code>ArrayList&lt;className&gt; a = new ArrayListo(100) ;</code></p>
<p>分配数组列表，它与为新数组分配空间有所不同：如果为数组分配100 个元素的存储空间， 数组就有100 个空位置可以使用。而容量为100 个元素的数组列表只是拥有保存100 个元素的潜力, 但是在最初，甚至完成初始化构造之后， 数组列表根本就不含有任何元素。</p>
<p>size 方法将返回数组列表中包含的实际元素数目。</p>
<p>一旦能够确认数组列表的大小不再发生变化， 就可以调用trimToSize 方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块。</p>
<h5 id="访问数组列表元素"><a href="#访问数组列表元素" class="headerlink" title="访问数组列表元素"></a>访问数组列表元素</h5><p>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。其原因是ArrayList 类并不是Java 程序设计语言的一部分；它只是一个由某些人编写且被放在标准库中的一个实用类。</p>
<p>使用get 和set 方法实现访问或改变数组元素的操作，而不使用人们喜爱的[ ] 语法格式。set 方法只能替换数组中已经存在的元素内容。</p>
<p>下面这个技巧可以一举两得， 既可以灵活地扩展数组， 又可以方便地访问数组元素：</p>
<ol>
<li>创建一个数组列表， 并添加所有的元素。</li>
<li>执行完上述操作后，使用toArray 方法将数组元素拷贝到一个数组中。</li>
</ol>
<p>除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素， 使用带索引参数的add 方法。为了插人一个新元素，位于n 之后的所有元素都要向后移动一个位置。如果插人新元素后， 数组列表的大小超过了容量， 数组列表就会被重新分配存储空间。</p>
<p>可以使用“ foreach” 循环遍历数组列表。</p>
<h5 id="类型化与原始数组列表的兼容性"><a href="#类型化与原始数组列表的兼容性" class="headerlink" title="类型化与原始数组列表的兼容性"></a>类型化与原始数组列表的兼容性</h5><p>可以将一个类型化的数组列表传递给原始数组列表， 而并不需要进行任何类型换。尽管编译器没有给出任何错误信息或警告， 但是这样调用并不太安全，在原始数组列表中， 添加到数组列表中的元素可能不是类型化的数组列表类型。</p>
<p>将一个原始ArrayList 赋给一个类型化ArrayList 会得到一个警告。为了能够看到警告性错误的文字信息，要将编译选项置为-Xlint:unchecked。使用类型转换并不能避免出现警告。一旦能确保不会造成严重的后果， 可以用@SuppressWarnings(“unchecked”) 标注来标记这个变量能够接受类型转换。</p>
<h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>所有的基本类型都有一个与之对应的类。这些类称为包装器（ wrapper ) 。</p>
<p>对象包装器类是不可变的， 即一旦构造了包装器， 就不允许更改包装在其中的值。同时， 对象包装器类还是final , 因此不能定义它们的子类。</p>
<p>由于每个值分别包装在对象中， 所以<code>ArrayList&lt;lnteger&gt; </code>的效率远远低于int[ ] 数组。因此， 应该用它构造小型集合， 其原因是此时程序员操作的方便性要比执行效率更加重要。</p>
<p>将一个int 值赋给一个Integer 对象时， 将会自动地装箱（autoboxing)。将一个Integer 对象赋给一个int 值时， 将会自动地拆箱。在算术表达式中也能够自动地装箱和拆箱。</p>
<p>== 运算符也可以应用于对象包装器对象，只不过检测的是对象是否指向同一个存储区域， 因此，一个值的两个包装器对象比较通常不会成立。但自动装箱规范要求boolean、byte、char &lt;= 127， 介于-128 ~ 127 之间的short 和int 被包装到固定的对象中，所以会使一定范围的一个值的两个包装器对象相等。解决这个问题的办法是在两个包装器对象比较时调用equals 方法。</p>
<p>由于包装器类引用可以为null , 所以自动装箱有可能会抛出一个NullPointerException 异常。</p>
<p>如果在一个条件表达式中混合使用Integer 和Double 类型， Integer 值就会拆箱，提升为double, 再装箱为Double。</p>
<p>装箱和拆箱是编译器认可的， 而不是虚拟机。编译器在生成类的字节码时， 插人必要的方法调用。虚拟机只是执行这些字节码。</p>
<p>使用数值对象包装器还有另外一个好处。Java 设计者发现，可以将某些基本方法放置在包装器中。</p>
<p>如果想编写一个修改数值参数值的方法， 就需要使用在org.omg.CORBA 包中定义的持有者（ holder ) 类型。每个持有者类型都包含一个公有域值， 通过它可以访问存储在其中的值。</p>
<h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><p>省略号. . . 是Java 代码的一部分，它表明这个方法可以接收任意数量的对象。</p>
<p>className… 参数类型与className[ ] 完全一样。</p>
<p>允许将一个数组传递给可变参数方法的最后一个参数。因此， 可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>enum 声明定义的类型是一个类， 它刚好有n 个实例， 在此尽量不要构造新对象。</p>
<p>在比较两个枚举类型的值时, 直接使用“ ==” 就可以了。</p>
<p>如果需要的话， 可以在枚举类型中添加一些构造器、方法和域。</p>
<p>所有的枚举类型都是Enum 类的子类。toString方法能够返回枚举常量名。方法valueOf将变量设置成枚举常量。每个枚举类型都有一个静态的values 方法， 它将返回一个包含全部枚举值的数组。ordinal 方法返 回 enum 声明中枚举常量的位置， 位置从0 开始计数。</p>
<p>如同Class 类一样， 鉴于简化的考虑， Enum 类省略了一个类型参数。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射库（ reflection library ) 提供了一个非常丰富且精心设计的工具集， 以便编写能够动态操纵 Java 代码的程序。</p>
<p>能够分析类能力的程序称为反射（ reflective )。</p>
<h5 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h5><p>在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。</p>
<p>可以通过专门的Java 类访问这些信息。保存这些信息的类被称为Class。Object 类中的getClass( ) 方法将会返回一个Class 类型的实例。</p>
<p>最常用的Class 方法是getName。这个方法将返回类的名字。如果类在一个包里，包的名字也作为类名的一部分。还可以调用静态方法forName 获得类名对应的Class 对象。</p>
<p>在启动时， 包含 main 方法的类被加载。它会加载所有需要的类。这些被加栽的类又要加载它们需要的类， 以此类推。对于一个大型的应用程序来说， 这将会消耗很多时间， 用户会因此感到不耐烦。可以使用下面这个技巧给用户一种启动速度比较快的幻觉。不过，要确保包含 main 方法的类没有显式地引用其他的类。首先， 显示一个启动画面；然后， 通过调用 Class.forName 手工地加载其他的类。</p>
<p>如果 T 是任意的Java 类型（或void 关键字)，T.class 将代表匹配的类对象。</p>
<p>一个Class 对象实际上表示的是一个类型， 而这个类型未必一定是一种类。例如，int 不是类， 但 int.class 是一个Class 类型的对象。</p>
<p>Class 类实际上是一个泛型类。在大多数实际问题中， 可以忽略类型参数， 而使用原始的 Class 类。</p>
<p>鉴于历史原getName 方法在应用于数组类型的时候会返回一个很奇怪的名字：<br>Double[ ].class.getName( ) 返回“ [Ljava.lang.Double;”。<br>int[ ].class.getName( ) 返回“ [I ”。</p>
<p>虚拟机为每个类型管理一个Class 对象。因此， 可以利用 == 运算符实现两个类对象比较的操作。</p>
<p>方法 newlnstance( ) 可以用来动态地创建一个类的实例。newlnstance 方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。如果需要以这种方式向按名称创建的类的构造器提供参数， 就必须使用Constructor 类中的newlnstance 方法。</p>
<h5 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>当程序运行过程中发生错误时， 就会“抛出异常”。抛出异常比终止程序要灵活得多，这是因为可以提供一个“捕获” 异常的处理器（handler ) 对异常情况进行处理。</p>
<p>如果没有提供处理器， 程序就会终止，并在控制台上打印出一条信息， 其中给出了异常的类型。</p>
<p>异常有两种类型： 未检查异常和已检查异常。对于已检查异常， 编译器将会检查是否提供了处理器。编译器不会査看是否为未检查异常提供了处理器。</p>
<p>将可能抛出已检査异常的一个或多个方法调用代码放在try 块中，然后在catch 子句中提供处理器代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	statements that might throw exceptions</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	handler action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h5><p>在java.lang.reflect 包中有三个类Field、Method 和Constructor 分别用于描述类的域、方法和构造器。这三个类都有一个叫做getName 的方法， 用来返回项目的名称。Field 类有一个getType 方法， 用来返回描述域所属类型的Class 对象。Method 和Constructor 类有能够报告参数类型的方法， Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫做 getModifiers 的方法， 它将返回一个整型数值， 用不同的位开关描述public 和 static 这样的修饰符使用状况。另外， 还可以利用 java.lang.reflect 包中的 Modifier类的静态方法分析 getModifiers 返回的整型数值。</p>
<p>Class 类中的 getFields、getMethods 和getConstructors 方法将分别返回类提供的public 域、方法和构造器数组， 其中包括超类的公有成员。Class 类的getDeclareFields、getDeclareMethods 和getDeclaredConstructors 方法将分别返回类中声明的全部域、方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。</p>
<h5 id="在运行时使用反射分析对象"><a href="#在运行时使用反射分析对象" class="headerlink" title="在运行时使用反射分析对象"></a>在运行时使用反射分析对象</h5><p>利用反射机制可以查看在编译时还不清楚的对象域。</p>
<p>查看对象域的关键方法是Field 类中的get 方法。如果f 是一个Field 类型的对象，obj 是某个包含f 域的类的对象，f.get(obj) 将返回一个对象，其值为obj 的f 域的当前值。但反射机制的默认行为受限于Java 的访问控制。如果一个Java 程序没有受到安全管理器的控制， 就可以覆盖访问控制。为了达到这个目的， 需要调用Field、Method 或Constructor 对象的setAccessible 方法。如果要查看基本类型的域，就调用Field 类中的getDouble 等方法，也可以调用get方法， 此时，将会自动地将这个域值打包到相应的对象包装器中。调用f.set(obj，value) 可以将obj 对象的f 域设置成新值。</p>
<p>可以使用通用的toString 方法实现自己类中的toString 方法，这是一种公认的提供toString 方法的手段。</p>
<h5 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h5><p>java.lang.reflect 包中的Array 类允许动态地创建数组。</p>
<p>Array 类中的静态方法newlnstance,它能够构造新数组。在调用它时必须提供两个参数，一个是数组的元素类型，一个是数组的长度：<br>Object newArray = Array.newInstance(componentType, newLength) ;<br>可以通过调用Array.getLength(a) 获得数组的长度， 也可以通过Array 类的静态getLength方法的返回值得到任意数组的长度。使用Class 类（能定义为数组的类对象）的getComponentType 方法确定数组对应的类型。</p>
<h5 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h5><p>反射机制允许你调用任意方法。</p>
<p>在Method 类中有一个invoke 方法， 它允许调用包装在当前Method 对象中的方法。invoke 方法的签名是：<br>Object invoke(Object obj, Object… args)<br>第一个参数是隐式参数， 其余的对象提供了显式参数（在Java SE 5.0 以前的版本中， 必须传递一个对象数组， 如果没有显式参数就传递一个null )。对于静态方法，第一个参数可以被忽略， 即可以将它设置为null。如果返回类型是基本类型， invoke 方法会返回其包装器类型。</p>
<p>可以通过调用getDeclareMethods 方法， 然后对返回的Method 对象数组进行查找， 直到发现想要的方法为止。也可以通过调用Class 类中的getMethod 方法得到想要的方法。getMethod 的签名是：<br>Method getMethod(String name, Class… parameterTypes)</p>
<h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol>
<li>将公共操作和域放在超类</li>
<li>不要使用受保护的域</li>
<li>使用继承实现“ is-a” 关系</li>
<li>除非所有继承的方法都有意义， 否则不要使用继承</li>
<li>在覆盖方法时， 不要改变预期的行为</li>
<li>使用多态， 而非类型信息</li>
<li>不要过多地使用反射</li>
</ol>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>06接口、lambda表达式与内部类</title>
    <url>/2021/04/26/06%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>接口（ interface) 技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现（ implement) 一个或多个接口，并在需要接口的地方， 随时使用实现了相应接口的对象。</p>
<p>lambda表达式是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda 表达式， 可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。</p>
<p>内部类（ inner class) 定义在另外一个类的内部， 其中的方法可以访问包含它们的外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。</p>
<p>代理（proxy)是一种实现任意接口的对象。</p>
<a id="more"></a>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h5><p>在Java 程序设计语言中， 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<p>Arrays 类中的 sort 方法承诺可以对对象数组进行排序， 但要求满足下列前提： 对象所属的类必须实现了Comparable 接口。在JavaSE 5.0 中，Comparable 接口已经改进为泛型类型。</p>
<p>接口中的所有方法自动地属于public。因此， 在接口中声明方法时， 不必提供关键字public。不过，在实现接口时， 必须把方法声明为public; 否则， 编译器将认为这个方法的访问属性是包可见性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</p>
<p>compareTo 方法必须确实比较两个对象的内容， 并返回比较的结果。当x 小于y 时， 返回一个负数；当x 等于y 时， 返回0; 否则返回一个正数。</p>
<p>接口绝不能含有实例域， 在JavaSE 8 之前， 也不能在接口中实现方法。</p>
<p>为了让类实现一个接口， 通常需要下面两个步骤：</p>
<ol>
<li>将类声明为实现给定的接口。使用关键字implements</li>
<li>对接口中的所有方法进行定义。</li>
</ol>
<p>compareTo方法的继承：</p>
<ol>
<li>如果子类之间的比较含义不一样， 每个compareTo 方法都应该在开始时进行下列检测：<br>if (getClass() != other.getClass()) throw new ClassCastExceptionO；</li>
<li>如果存在这样一种通用算法， 它能够对两个不同的子类对象进行比较， 则应该在超类中提供一个compareTo 方法， 并将这个方法声明为final 。</li>
</ol>
<h5 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h5><p>接口不是类，尤其不能使用new 运算符实例化一个接口，尽管不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象。可以使用instance 检查一个对象是否实现了某个特定的接口。接口也可以被扩展，这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。在接口中可以包含常量。接口中的域将被自动设为public static final。尽管每个类只能够拥有一个超类， 但却可以实现多个接口。</p>
<h5 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h5><p>为什么Java 程序设计语言还要不辞辛苦地引入接口概念，为什么不将接口直接设计成抽象类？<br>使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。</p>
<p>Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂（如同C++)，效率也会降低（如同Eiffel)。接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>在Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。</p>
<p>通常的做法都是将静态方法放在伴随类中。在标准库中， 你会看到成对出现的接口和实用工具类， 如Collection/Collections 或Path/Paths。</p>
<p>不过整个Java 库都以这种方式重构也是不太可能的， 但是实现你自己的接口时，不再需要为实用工具方法另外提供一个伴随类。</p>
<h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><p>在Java SE 8 中，可以为接口方法提供一个默认实现。必须用default 修饰符标记这样一个方法。默认方法可以调用任何其他方法。</p>
<p>在JavaAPI 中， 你会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法， 如CoUection/AbstractCollectkm 或MouseListener/MouseAdapter。</p>
<p>默认方法的一个重要用法是“接口演化” （interface evolution)。为接口新增加一个非默认方法不能保证“ 源代码兼容”(Source compatible)，而默认方法可以解决这个问题。</p>
<h5 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h5><p>如果先在一个接口中将一个方法定义为默认方法， 然后又在超类或另一个接口中定义了同样的方法， 会发生什么情况？规则如下：</p>
<ol>
<li>超类优先。如果超类提供了一个具体方法， 同名而且有相同参数类型的默认方法会被忽略。这正是“ 类优先” 规则。“类优先” 规则可以确保与Java SE 7 的兼容性。如果为一个接口增加默认方法，这对于有这个默认方法之前能正常工作的代码不会有任何影响。</li>
<li>接口冲突。如果一个接口提供了一个默认方法， 另一个接口提供了一个同名而且参数类型相同的方法， 必须覆盖这个方法来解决冲突。</li>
</ol>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><h5 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h5><p>回调（ callback) 是一种常见的程序设计模式。在这种模式中， 可以指出某个特定事件发生时应该采取的动作。</p>
<h5 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h5><p>ArrayS.Sort 方法还有第二个版本， 用一个数组和一个比较器( comparator )作为参数， 比较器是实现了Comparator 接口的类的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Comparators&#123;</span><br><span class="line">	int compare(T first, T second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h5><p>Cloneable 接口指示一个类提供了一个安全的clone 方法。</p>
<p>如果希望copy 是一个新对象，它的初始状态与original 相同， 但是之后它们各自会有自己不同的状态， 这种情况下就可以使用clone 方法。</p>
<p>如果对象中的所有数据域都是数值或其他基本类型，拷贝这些域没有任何问题、但是如果对象包含子对象的引用，拷贝域就会得到相同子对象的另一个引用，这样一来， 原对象和克隆的对象仍然会共享一些信息。默认的克隆操作是“ 浅拷贝”，并没有克隆对象中引用的其他对象。如果原对象和浅克隆对象共享的子对象是不可变的， 那么这种共享就是安全的。不过， 通常子对象都是可变的， 必须重新定义clone 方法来建立一个深拷贝， 同时克隆所有子对象。</p>
<p>对于每一个类，需要确定：</p>
<ol>
<li>默认的clone 方法是否满足要求；</li>
<li>是否可以在可变的子对象上调用clone 来修补默认的clone 方法；</li>
<li>是否不该使用clone。<br>实际上第3 个选项是默认选项。如果选择第1 项或第2 项，类必须：</li>
<li>实现Cloneable 接口；</li>
<li>重新定义clone 方法，并指定public 访问修饰符。</li>
</ol>
<p>Object 类中clone 方法声明为protected , 所以你的代码不能直接调用anObject.clone()。子类只能调用受保护的clone方法来克隆它自己的对象。必须重新定义clone 为public 才能允许所有方法克隆对象。（理解：就是说，clone为protected的话，就有限制，非子类，非同一包的公有类之间就不能互相调用各自对象的clone方法，从而复制对象，所以说“你的代码不能直接调用anObject.clone()”；而作者的目的，是在代码中实现复制对象，而没有什么限制）</p>
<p>Cloneable这个接口只是作为一个标记，指示类设计者了解克隆过程。对象对于克隆很“ 偏执”， 如果一个对象请求克隆， 但没有实现这个接口， 就会生成一个受査异常。Cloneable 接口是Java 提供的一组标记接口( tagging interface ) 之一。（有些程序员称之为记号接口( marker interface)。标记接口不包含任何方法； 它唯一的作用就是允许在类型查询中使用instanceof。</p>
<p>实现Cloneable 接口， 将clone重新定义为public。在Java SE 1.4 之前， clone 方法的返回类型总是Object, 而现在可以为你的clone方法指定正确的返回类型，这是协变返回类型的一个例子。</p>
<p>如果在一个对象上调用clone, 但这个对象的类并没有实现Cloneable 接口， Object 类的clone 方法就会拋出一个CloneNotSupportedException。</p>
<p>一旦为超类类定义了clone 方法， 任何人都可以用它来克隆子类对象。不能保证子类的实现者一定会修正clone 方法让它正常工作。出于这个原因， 在Object类中clone 方法声明为protected。</p>
<p>所有数组类型都有一个public 的clone 方法， 而不是protected: 可以用这个方法建立一个新数组， 包含原数组所有元素的副本。</p>
<h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><h5 id="为什么引入lambda-表达式"><a href="#为什么引入lambda-表达式" class="headerlink" title="为什么引入lambda 表达式"></a>为什么引入lambda 表达式</h5><p>lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。</p>
<p>之前，在Java 中传递一个代码段并不容易， 不能直接传递代码段，Java 是一种面向对象语言， 所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。</p>
<h5 id="lambda-表达式的语法"><a href="#lambda-表达式的语法" class="headerlink" title="lambda 表达式的语法"></a>lambda 表达式的语法</h5><p>lambda 表达式就是一个代码块， 以及必须传人代码的变量规范。</p>
<p>为什么起这个名字呢？逻辑学家Alonzo Church 想要形式化地表示能有效计算的数学函数。他使用了希腊字母lambda (λ) 来标记参数。</p>
<p>Java 中的一种lambda 表达式形式：参数， 箭头（-&gt;) 以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return 语句。即使lambda 表达式没有参数， 仍然要提供空括号，就像无参数方法一样。如果可以推导出一个lambda 表达式的参数类型，则可以忽略其类型。如果方法只有一参数， 而且这个参数的类型可以推导得出，那么甚至还可以省略小括号。无需指定lambda 表达式的返回类型，lambda 表达式的返回类型总是会由上下文推导得出。</p>
<p>如果一个lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。例如，（int x)-&gt; { if (x &gt;= 0) return 1; } 就不合法。</p>
<h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><p>对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个lambda 表达式。这种接口称为函数式接口（ functional interface )。</p>
<p>在底层，方法会接收实现了函数式接口的某个类的对象。在这个对象上调用函数式接口的抽象方法会执行这个lambda 表达式的体。</p>
<p>实际上，在Java 中， 对lambda 表达式所能做的也只是能转换为函数式接口。（注释：也就是把lambda表达式赋值给函数式接口变量）</p>
<p>Java API 在java.util.function 包中定义了很多非常通用的函数式接口。</p>
<p>想要用lambda 表达式做某些处理，还是要谨记表达式的用途， 为它建立一个特定的函数式接口。</p>
<h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p>可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。</p>
<p>方法引用要用 :: 操作符分隔方法名与对象或类名。主要有3 种情况：<br>object::instanceMethod<br>Class::staticMethod<br>Class::instanceMethod<br>在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。System.out::println 等价于x -&gt; System.out.println(x)。 Math::pow 等价于（x，y) -&gt; Math.pow(x, y)。<br>对于第3 种情况， 第1 个参数会成为方法的目标。String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y)。</p>
<p>如果有多个同名的重载方法， 编译器就会尝试从上下文中找出你指的那一个方法。选择哪一个版本取决于转换为哪个函数式接口的方法参数。类似于lambda 表达式， 方法引用不能独立存在，总是会转换为函数式接口的实例。</p>
<p>可以在方法引用中使用this 参数。使用super 也是合法的：<br>this::instanceMetod<br>super::instanceMethod</p>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><p>Class::new是Class 构造器的一个引用。调用哪一个构造器取决于上下文。</p>
<p>可以用数组类型建立构造器引用。例如， int[]::new 是一个构造器引用， 它有一个参数，即数组的长度。这等价于lambda 表达式 x-&gt; new int[x]。Java 有一个限制，无法构造泛型类型 T 的数组。数组构造器引用对于克服这个限制很有用。</p>
<h5 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h5><p>你可能希望能够在lambda 表达式中访问外围方法或类中的变量。<br>lambda 表达式有3个部分：</p>
<ol>
<li>一个代码块；</li>
<li>参数;</li>
<li>自由变量的值， 这是指非参数而且不在代码中定义的变量。<br>lambda 表达式的数据结构必须存储自由变量的值。我们说它被lambda 表达式捕获(captured)。lambda 表达式中捕获的变量必须实际上是最终变量( effectively final)。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。之所以有这个限制是有原因的。如果在lambda 表达式中改变变量， 并发执行多个动作时就会不安全。</li>
</ol>
<p>lambda 表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规则。在lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</p>
<p>在一个lambda 表达式中使用this 关键字时， 是指创建这个lambda 表达式的方法的this参数，而非转换的函数式接口实例的this参数。在lambda 表达式中， this 的使用并没有任何特殊之处，就是自由变量。</p>
<h5 id="处理lambda-表达式"><a href="#处理lambda-表达式" class="headerlink" title="处理lambda 表达式"></a>处理lambda 表达式</h5><p>使用lambda 表达式的重点是延迟执行（deferred execution )。毕竟， 如果想要立即执行代码，完全可以直接执行， 而无需把它包装在一个 lambda 表达式中。</p>
<p>要接受 lambda 表达式， 需要选择（偶尔可能需要提供）一个函数式接口。调用接口的抽象方法时会执行这个 lambda 表达式的主体。</p>
<table>
<thead>
<tr>
<th>常用函数式接口</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable</td>
<td>void</td>
<td>run</td>
<td>无参数和无返回值的动作运行</td>
</tr>
<tr>
<td>Supplier&lt;T&gt;</td>
<td>T</td>
<td>get</td>
<td>提供一个T 类型的值</td>
</tr>
<tr>
<td>Consumer&lt;T&gt;</td>
<td>void</td>
<td>accept</td>
<td>处理一个T 类型的值</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>void</td>
<td>accept</td>
<td>处理T 和U 类型的值</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;</td>
<td>R</td>
<td>apply</td>
<td>有一个T 类型参数的函数</td>
</tr>
<tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>R</td>
<td>apply</td>
<td>有T 和U 类型参数的函数</td>
</tr>
<tr>
<td>UnaryOperator&lt;T&gt;</td>
<td>T</td>
<td>apply</td>
<td>类型T 上的一元操作符</td>
</tr>
<tr>
<td>BinaryOperator&lt;T&gt;</td>
<td>T</td>
<td>apply</td>
<td>类型T 上的二元操作符</td>
</tr>
<tr>
<td>Predicate&lt;T&gt;</td>
<td>boolean</td>
<td>test</td>
<td>布尔值函数</td>
</tr>
<tr>
<td>BiPredicate&lt;T, U&gt;</td>
<td>boolean</td>
<td>test</td>
<td>有两个参数的布尔值函数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>基本类型的函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanSupplier</td>
<td>none</td>
<td>boolean</td>
<td>getAsBoolean</td>
</tr>
<tr>
<td>PSupplier</td>
<td>none</td>
<td>p</td>
<td>getAsP</td>
</tr>
<tr>
<td>PConsumer</td>
<td>p</td>
<td>void</td>
<td>accept</td>
</tr>
<tr>
<td>ObjPConsumer&lt;T&gt;</td>
<td>T,p</td>
<td>void</td>
<td>accept</td>
</tr>
<tr>
<td>PFunction&lt;T&gt;</td>
<td>p</td>
<td>T</td>
<td>apply</td>
</tr>
<tr>
<td>PToQFunction</td>
<td>p</td>
<td>q</td>
<td>applyAsQ</td>
</tr>
<tr>
<td>ToPFunction&lt;T&gt;</td>
<td>T</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>ToPBiFunction&lt;T, U&gt;</td>
<td>T, U</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PUnaryOperator</td>
<td>p</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PBinaryOperator</td>
<td>p,p</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PPredicate</td>
<td>p</td>
<td>boolean</td>
<td>test</td>
</tr>
<tr>
<td>p，q为int, long, double;</td>
<td></td>
<td></td>
<td>P，Q 为Int, Long, Double</td>
</tr>
</tbody></table>
<p>最好使用上表中的接口。</p>
<p>如果设计你自己的接口，其中只有一个抽象方法， 可以用@FunctionalInterface 注解来标记这个接口。这样做有两个优点。如果你无意中增加了另一个非抽象方法， 编译器会产生一个错误消息。另外javadoc 页里会指出你的接口是一个函数式接口。</p>
<h5 id="再谈-Comparator"><a href="#再谈-Comparator" class="headerlink" title="再谈 Comparator"></a>再谈 Comparator</h5><p>Comparator 接口包含很多方便的静态方法来创建比较器。这些方法可以用于lambda 表达式或方法引用。</p>
<p>静态comparing 方法取一个“ 键提取器” 函数， 它将类型T 映射为一个可比较的类型。对要比较的对象应用这个函数， 然后对返回的键完成比较。可以把比较器与thenComparing 方法串起来。可以为comparing 和thenComparing 方法提取的键指定一个比较器。</p>
<p>如果键函数可以返回null, 可能就要用到nullsFirst 和nullsLast 适配器。这些静态方法会修改现有的比较器， 从而在遇到null 值时不会抛出异常， 而是将这个值标记为小于或大于正常值。nullsFirst 方法需要一个比较器。</p>
<p>naturalOrder 方法可以为任何实现了Comparable 的类建立一个比较器。</p>
<p>静态reverseOrder 方法会提供自然顺序的逆序。要让比较器逆序比较， 可以使用reversed实例方法。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类（ inner class ) 是定义在另一个类中的类。为什么需要使用内部类呢？ 其主要原因有以下三点：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous) 内部类比较便捷。</li>
</ol>
<h5 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h5><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p>
<p>内部类的对象总有一个隐式引用， 它指向了创建它的外部类对象。这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器， 添加一个外围类引用的参数。</p>
<h5 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h5><p>表达式 OuterClass.this 表示外围类引用。</p>
<p>可以采用下列语法格式更加明确地编写内部对象的构造器：<br>outerObject.new InnerClass(construction parameters)</p>
<p>在外围类的作用域之外，可以这样引用内部类：<br>OuterClass.InnerClass</p>
<p>内部类中声明的所有静态域都必须是 final。我们希望一个静态域只有一个实例， 不过对于每个外部对象， 会分别有一个单独的内部类实例。如果这个域不是final , 它可能就不是唯一的。</p>
<p>内部类不能有static 方法。Java 语言规范对这个限制没有做任何解释。也可以允许有静态方法， 但只能访问外围类的静态域和方法。显然，Java 设计者认为相对于这种复杂性来说， 它带来的好处有些得不偿失。</p>
<h5 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h5><p>内部类是一种编译器现象， 与虚拟机无关。编译器将会把内部类翻译成用$ ( 美元符号）分隔外部类名与内部类名的常规类文件， 而虚拟机则对此一无所知。</p>
<p>编译器为了引用外围类， 生成了一个附加的实例域this$0 ( 名字this$0 是由编译器合成的，在自己编写的代码中不能够引用它）:<br>final OuterClass this$0;</p>
<p>由于内部类拥有访问特权， 所以与常规类比较起来功能更加强大。</p>
<p>编译器在外围类添加静态方法access$0：<br>static boolean access$0(outerObject);<br>它将返回作为参数传递给它的对象域。（方法名可能稍有不同， 如access$000, 这取决于你的编译器。）内部类方法将调用那个方法。这样做存在安全风险，任何人都可以通过调用access$0方法很容易地读取到私有域。当然， access$0 不是Java 的合法方法名。但熟悉类文件结构的黑客可以使用十六进制编辑器轻松地创建一个用虚拟机指令调用那个方法的类文件。由于隐秘地访问方法需要拥有包可见性，所以攻击代码需要与被攻击类放在同一个包中。</p>
<p>在虚拟机中不存在私有类， 因此编译器将会利用私有构造器生成一个包可见的类：<br>private OuterClass$InnerClass(OuterClass);<br>当然， 没有人可以调用这个构造器， 因此， 存在第二个包可见构造器：<br>OuterClass$InnerClass(OuterClass, OuterClass$1);<br>它将调用第一个构造器。</p>
<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>类只在方法中创建这个类型的对象时使用了一次。当遇到这类情况时， 可以在一个方法中定义局部类。局部类不能用public 或private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势， 即对外部世界可以完全地隐藏起来。</p>
<h5 id="由外部方法访问变量"><a href="#由外部方法访问变量" class="headerlink" title="由外部方法访问变量"></a>由外部方法访问变量</h5><p>与其他内部类相比较， 局部类还有一个优点。它们不仅能够访问包含它们的外部类， 还可以访问局部变量。不过， 那些局部变量必须事实上为final。这说明， 它们一旦赋值就绝不会改变。</p>
<p>当创建一个对象的时候， 局部变量beep 就会被传递给内部类构造器，并存储在val$beep 域中。编译器必须检测对局部变量的访问， 为每一个变量建立相应的数据域， 并将局部变量拷贝到构造器中， 以便将这些数据域初始化为局部变量的副本。在JavaSE 8 之前， 必须把从局部类访问的局部变量声明为final，从而使内部类能够访问局部变量。</p>
<p>有时， final 限制显得并不太方便。补救的方法是使用数组。</p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>将局部内部类的使用再深人一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class)。</p>
<p>通常的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new SuperType(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">	inner class methods and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的含义是： 创建一个实现（扩展）SuperType 接口（类）的类的新对象，需要实现的方法定义在括号内。</p>
<p>由于构造器的名字必须与类名相同， 而匿名类没有类名， 所以， 匿名类不能有构造器。取而代之的是，将构造器参数传递给超类（ superclass) 构造器。</p>
<p>“双括号初始化” （double brace initialization )，为一个匿名列表添加元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new ArrayList&lt;T&gt;() &#123;&#123; add(T) ; add(T) ; ... &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>外层括号建立了ArrayList 的一个匿名子类。内层括号则是一个对象构造块。</p>
<p>外层括号建立了ArrayList 的一个匿名子类。内层括号则是一个对象构造块。</p>
<p>建立一个与超类大体类似（但不完全相同）的匿名子类通常会很方便。不过， 对于equals 方法要特别当心。以下测试：<br>if (getClass() != other.getClass()) return false;<br>对匿名子类做这个测试时会失败。</p>
<p>生成日志或调试消息时， 通常希望包含当前类的类名，不过， 这对于静态方法不奏效。毕竟， 调用getClass 时调用的是this.getClass(), 而静态方法没有this。所以应该使用以下表达式：<br>new Object(){}.getCIass().getEndosingClass()<br>在这里，newObject(){} 会建立Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类， 也就是包含这个静态方法的类。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static, 以便取消产生的引用。有些程序员用嵌套类（nested class ) 表示静态内部类。与常规内部类不同， 静态内部类可以有静态域和方法。声明在接口中的内部类自动成为static 和public 类。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p>
<h5 id="何时使用代理"><a href="#何时使用代理" class="headerlink" title="何时使用代理"></a>何时使用代理</h5><p>假设有一个表示接口的Class 对象，它的确切类型在编译时无法知道。要想构造一个实现这些接口的类， 就需要使用newlnstance 方法或反射找出这个类的构造器。但是， 不能实例化一个接口，需要在程序处于运行状态时定义一个新类。为了解决这个问题， 有些程序将会生成新类代码；将这些代码放置在一个文件中；调用编译器；然后再加载结果类文件。很自然， 这样做的速度会比较慢，并且需要将编译器与程序放在一起。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：</p>
<ol>
<li>指定接口所需要的全部方法。</li>
<li>Object 类中的全部方法， 例如， toString、equals 等。<br>然而，不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（ invocation handler)。调用处理器是实现了InvocationHandler 接口的类对象。在这个接口中只有一个方法：<br>Object invoke(Object proxy, Method method, Object[] args)<br>无论何时调用代理对象的方法， 调用处理器的invoke 方法都会被调用， 并向其传递Method 对象和原始的调用参数。调用处理器必须给出处理调用的方式。</li>
</ol>
<h5 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h5><p>要想创建一个代理对象， 需要使用Proxy 类的newProxylnstance 方法。这个方法有三个参数：</p>
<ol>
<li>一个类加载器（ class loader)。 作为Java 安全模型的一部分， 对于系统类和从因特网上下载下来的类，可以使用不同的类加载器。用null 表示使用默认的类加载器。</li>
<li>一个Class 对象数组， 每个元素都是需要实现的接口。</li>
<li>一个调用处理器。</li>
</ol>
<h5 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h5><p>需要记住， 代理类是在程序运行过程中创建的。然而， 一旦被创建， 就变成了常规类， 与虚拟机中的任何其他类没有什么区别。</p>
<p>所有的代理类都扩展于Proxy 类。一个代理类只有一个实例域——调用处理器，它定义在Proxy 的超类中。为了履行代理对象的职责， 所需要的任何附加数据都必须存储在调用处理器中。</p>
<p>所有的代理类都覆盖了Object 类中的方法toString、equals 和hashCode。如同所有的代理方法一样， 这些方法仅仅调用了调用处理器的invoke。Object 类中的其他方法（如clone和getClass ) 没有被重新定义。</p>
<p>没有定义代理类的名字，Sun 虚拟机中的Proxy 类将生成一个以字符串SProxy 开头的类名。</p>
<p>对于特定的类加载器和预设的一组接口来说， 只能有一个代理类。也可以利用getProxyClass 方法获得这个类。</p>
<p>代理类一定是public 和final。如果代理类实现的所有接口都是public， 代理类就不属于某个特定的包；否则， 所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包。</p>
<p>可以通过调用Proxy 类中的isProxyClass 方法检测一个特定的Class 对象是否代表一个代理类。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>07异常、断言和日志</title>
    <url>/2021/04/26/07%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>对于异常情况，Java 使用一种称为异常处理( exception handing) 的错误捕获机制处理。</p>
<a id="more"></a>

<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>用户期望在出现错误时， 程序能够采用一些理智的行为。如果由于出现错误而使得某些操作没有完成， 程序应该：</p>
<ol>
<li>返回到一种安全状态，并能够让用户执行一些其他的命令，或者</li>
<li>允许用户保存所有操作的结果，并以妥善的方式终止程序</li>
</ol>
<p>异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。</p>
<p>在Java 中， 如果某个方法不能够采用正常的途径完整它的任务，就可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值， 而是抛出( throw) 一个封装了错误信息的对象。此外， 调用这个方法的代码也将无法继续执行，取而代之的是， 异常处理机制开始搜索能够处理这种异常状况的异常处理器（exception handler )。</p>
<h5 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h5><p>在Java 程序设计语言中， 异常对象都是派生于Throwable 类的一个实例。如果Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。</p>
<p>Java 异常层次结构：<br>Error -&gt; Throwable<br>IOException -&gt; Exception -&gt; Throwable<br>RuntimeException -&gt; Exception</p>
<p>Error 类层次结构描述了Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。</p>
<p>Exception划分两个分支的规则是：由程序错误导致的异常属于RuntimeException ; 而程序本身没有问题， 但由于像I/O 错误这类问题导致的异常属于其他异常。</p>
<p>“如果出现RuntimeException 异常， 那么就一定是你的问题” 是一条相当有道理的规则。</p>
<p>Java 语言规范将派生于Error 类或RuntimeException 类的所有异常称为非受查( unchecked ) 异常， 所有其他的异常称为受查（ checked) 异常。编译器将核查是否为所有的受査异常提供了异常处理器。</p>
<h5 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h5><p>一个方法不仅需要告诉编译器将要返回什么值， 还要告诉编译器有可能发生什么错误。</p>
<p>方法应该在其首部用throws子句声明所有可能抛出的异常。在遇到下面4 种情况时应该抛出异常：</p>
<ol>
<li>调用一个抛出受査异常的方法，</li>
<li>程序运行过程中发现错误， 并且利用throw 语句抛出一个受查异常</li>
<li>程序出现错误</li>
<li>Java 虚拟机和运行时库出现的内部错误<br>如果一个方法有可能抛出多个受查异常类型， 那么就必须在方法的首部列出所有的异常类。每个异常类之间用逗号隔开。如果方法没有声明所有可能发生的受查异常， 编译器就会发出一个错误消息。</li>
</ol>
<p>如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用（也就是说， 子类方法中可以抛出更特定的异常， 或者根本不抛出任何异常）。特别需要说明的是， 如果超类方法没有抛出任何受查异常， 子类也不能抛出任何受查异常。</p>
<p>如果类中的一个方法声明将会抛出一个异常， 而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常， 或者这个类的任意一个子类的异常。</p>
<h5 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h5><p>对于一个已经存在的异常类， 将其抛出非常容易。 在这种情况下：</p>
<ol>
<li>找到一个合适的异常类。</li>
<li>创建这个类的一个对象。</li>
<li>用throw将对象抛出。</li>
</ol>
<h5 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h5><p>我们需要做的只是定义一个派生于Exception 的类， 或者派生于Exception 子类的类。习惯上， 定义的类应该包含两个构造器， 一个是默认的构造器；另一个是带有详细描述信息的构造器。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h5 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h5><p>如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息， 其中包括异常的类型和堆栈的内容(在调试GUI 程序时， 最好保证控制台窗口可见， 并且没有被最小化)。</p>
<p>要想捕获一个异常， 必须设置try/catch 语句块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	code</span><br><span class="line">	more code</span><br><span class="line">	more code</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">	handler <span class="keyword">for</span> <span class="keyword">this</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在try 语句块中的任何代码抛出了一个在catch 子句中说明的异常类， 那么：</p>
<ol>
<li>程序将跳过try 语句块的其余代码。</li>
<li>程序将执行catch 子句中的处理器代码。<br>如果在try 语句块中的代码没有拋出任何异常，那么程序将跳过catch 子句。<br>如果方法中的任何代码拋出了一个在catch 子句中没有声明的异常类型，那么这个方法就会立刻退出。</li>
</ol>
<p>通常， 最好的选择是什么也不做，而是将异常传递给调用者。如果采用这种处理方式，就必须声明这个方法可能会拋出一个异常。</p>
<p>编译器严格地执行throws 说明符。如果调用了一个抛出受查异常的方法，就必须对它进行处理， 或者继续传递。</p>
<p>应该捕获那些知道如何处理的异常， 而将那些不知道怎样处理的异常继续进行传递。</p>
<h5 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h5><p>在一个try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。可以为每个异常类型使用一个单独的catch 子句。</p>
<p>异常对象可能包含与异常本身有关的信息。要想获得对象的更多信息， 可以试着使用e.getMessage()<br>得到详细的错误信息（如果有的话)，或者使用e.getClass().getName()得到异常对象的实际类型。</p>
<p>在Java SE 7 中，同一个catch 子句中可以捕获多个异常类型。只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。捕获多个异常时， 异常变量隐含为final 变量。捕获多个异常不仅会让你的代码看起来更简单， 还会更高效。生成的字节码只包一个对应公共catch 子句的代码块。</p>
<h5 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h5><p>在catch 子句中可以抛出一个异常， 这样做的目的是改变异常的类型，</p>
<p>可以将原始异常设置为新异常的“ 原因”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	code</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionClass e)</span><br><span class="line">	Throwable ne = <span class="keyword">new</span> newException(aDescription)；</span><br><span class="line">	ne.initCause(e);</span><br><span class="line">	<span class="keyword">throw</span> ne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当捕获到异常时， 就可以使用下面这条语句重新得到原始异常：<br>Throwable e = ne.getCause();<br>强烈建议使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。</p>
<p>在Java SE 7 之前,thorws声明的异常类比throw抛出的异常类更特定，编译器就会指出这个问题。现在这个问题已经有所改进。编译器会跟踪到e 来自try 块。假设这个try 块中仅有的已检査异常是throws声明的异常类实例， 另外， 假设e 在 catch 块中未改变， 将外围方法声明为throws声明的异常类就是合法的。</p>
<h5 id="finally-子句"><a href="#finally-子句" class="headerlink" title="finally 子句"></a>finally 子句</h5><p>如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。Java 有一种好的解决方案， 这就是finally 子句。</p>
<p>不管是否有异常被捕获， finally 子句中的代码都被执行。try 语句可以只有finally 子句，而没有catch 子句。</p>
<p>强烈建议解耦合try/catch 和try/finally 语句块。这样可以提高代码的清晰<br>度，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStrean in = . . .;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内层的try 语句块只有一个职责， 就是确保关闭输入流。外层的try 语句块也只有一个职责， 就是确保报告出现的错误。这种设计方式不仅清楚， 而且还具有一个功能， 就是将会报告finally 子句中出现的错误。</p>
<p>假设利用return语句从try 语句块中退出。在方法返回前， finally 子句的内容将被执行。如果finally 子句中也有一个return 语句， 这个返回值将会覆盖原始的返回值。</p>
<h5 id="带资源的try-语句"><a href="#带资源的try-语句" class="headerlink" title="带资源的try 语句"></a>带资源的try 语句</h5><p>假设资源属于一个实现了AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。AutoCloseable 接口有一个方法：<br>void close() throws Exception</p>
<p>带资源的try 语句（try-with-resources ) 的最简形式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = . . .) &#123;</span><br><span class="line">	work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try 块退出时，会自动调用res.dose()。还可以指定多个资源。</p>
<p>如果try 块抛出一个异常， 而且close 方法也抛出一个异常，这就会带来一个难题，带资源的try 语句可以很好地处理这种情况。原来的异常会重新抛出，而close方法抛出的异常会“ 被抑制”。这些异常将自动捕获，并由addSuppressed 方法增加到原来的异常。如果对这些异常感兴趣， 可以调用getSuppressed 方法， 它会得到从close 方法抛出并被抑制的异常列表。</p>
<p>带资源的try 语句自身也可以有catch 子句和一个finally 子句。这些子句会在关闭资源之后执行。</p>
<h5 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h5><p>堆栈轨迹（ stack trace ) 是一个方法调用过程的列表， 它包含了程序执行过程中方法调用的特定位置。</p>
<p>可以调用Throwable 类的printStackTrace 方法访问堆栈轨迹的文本描述信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable t = <span class="keyword">new</span> Throwable()；</span><br><span class="line">StringWriter out = <span class="keyword">new</span> StringWriter() ;</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> PrintWriter(out)) ;</span><br><span class="line">String description = out.toString() ;</span><br></pre></td></tr></table></figure>
<p>一种更灵活的方法是使用getStackTrace 方法， 它会得到StackTraceElement 对象的一个数组， 可以在你的程序中分析这个对象数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace() ;</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement frame : frames)</span><br><span class="line">	analyze frame</span><br></pre></td></tr></table></figure>
<p>StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法， 同时， 还含有能够获得类名和方法名的方法。toString 方法将产生一个格式化的字符串， 其中包含所获得的信息。</p>
<p>静态的Thread.getAllStackTrace 方法， 它可以产生所有线程的堆栈轨迹：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAl1StackTraces() ;</span><br><span class="line"><span class="keyword">for</span> (Thread t : map.keySet () ) &#123;</span><br><span class="line">	StackTraceElement[] frames = map.get(t) ;</span><br><span class="line">	analyze frames</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><ol>
<li><p>异常处理不能代替简单的测试<br>与执行简单的测试相比， 捕获异常所花费的时间大大超过了前者</p>
</li>
<li><p>不要过分地细化异常</p>
</li>
<li><p>利用异常层次结构<br>不要只抛出RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。<br>不要只捕获Thowable 异常， 否则，会使程序代码更难读、更难维护。</p>
</li>
<li><p>不要压制异常<br>在Java 中， 往往强烈地倾向关闭异常。如果编写了一个调用另一个方法的方法，而这个方法有可能100 年才抛出一个异常， 那么， 编译器会因为没有将这个异常列在throws 表中产生抱怨。而没有将这个异常列在throws 表中主要出于编译器将会对所有调用这个方法的方法进行异常处理的考虑。因此，应该将这个异常关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// code that threatens to throw checked exceptions</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;&#125; <span class="comment">// so there</span></span><br></pre></td></tr></table></figure>
<p>如果认为异常非常重要， 就应该对它们进行处理。</p>
</li>
<li><p>在检测错误时，“ 苛刻” 要比放任更好</p>
</li>
<li><p>不要羞于传递异常<br>让高层次的方法通知用户发生了错误， 或者放弃不成功的命令更加适宜。<br>规则5、6 可以归纳为“ 早抛出， 晚捕获’。</p>
</li>
</ol>
<h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><h5 id="断言的概念"><a href="#断言的概念" class="headerlink" title="断言的概念"></a>断言的概念</h5><p>假设确信某个属性符合要求， 并且代码的执行依赖于这个属性。</p>
<p>断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插人的检测语句将会被自动地移走。</p>
<p>Java 语言引人了关键字assert。这个关键字有两种形式：<br>assert 条件；<br>assert 条件：表达式；<br>这两种形式都会对条件进行检测， 如果结果为false, 则抛出一个AssertionError 异常。在第二种形式中，表达式将被传人AssertionError 的构造器， 并转换成一个消息字符串。“表达式” 部分的唯一目的是产生一个消息字符串。AssertionError 对象并不存储表达式的值， 因此， 不可能在以后得到它。</p>
<h5 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h5><p>在默认情况下， 断言被禁用。可以在运行程序时用-enableassertions 或-ea 选项启用：<br>java -enableassertions MyApp<br>在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器( class loader ) 的功能。当断言被禁用时， 类加载器将跳过断言代码， 因此，不会降低程序运行的速度。<br>也可以在某个类或整个包中使用断言， 例如：<br>java -ea:MyClass -ea:com.mycompany.mylib… MyApp<br>这条命令将开启MyClass 类以及在com.mycompany.mylib 包和它的子包中的所有类的断言。选项-ea 将开启默认包中的所有类的断言。</p>
<p>也可以用选项-disableassertions 或-da 禁用某个特定类和包的断言：<br>java -ea:… -da:MyClass MyApp<br>有些类不是由类加载器加载， 而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。</p>
<p>启用和禁用所有断言的-ea 和-da 开关不能应用到那些没有类加载器的“ 系统类”上。对于这些系统类来说， 需要使用-enablesystemassertions/-esa 开关启用断言。</p>
<h5 id="使用断言完成参数检查"><a href="#使用断言完成参数检查" class="headerlink" title="使用断言完成参数检查"></a>使用断言完成参数检查</h5><p>什么时候应该选择使用断言呢？：</p>
<ol>
<li>断言失败是致命的、不可恢复的错误。</li>
<li>断言检查只用于开发和测阶段。<br>不应该使用断言向程序的其他部分通告发生了可恢复性的错误， 或者，不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段确定程序内部的错误位置。</li>
</ol>
<p>计算机科学家将文档的约定称为前置条件（ Precondition)。方法对参数没有前置条件， 即承诺在任何条件下都能够给予正确的执行。有一个前置条件，如果调用者在调用这个方法时没有提供满足这个前置条件的参数， 所有的断言都会失败，并且这个方法可以执行它想做的任何操作。事实上， 由于可以使用断言，当方法被非法调用时， 将会出现难以预料的结果。有时候会拋出一个断言错误， 有时候会产生一个null 指针异常， 这完全取决于类加载器的配置。</p>
<h5 id="为文档假设使用断言"><a href="#为文档假设使用断言" class="headerlink" title="为文档假设使用断言"></a>为文档假设使用断言</h5><p>很多程序员使用注释说明假设条件。</p>
<h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>每个Java 程序员都很熟悉在有问题的代码中插入一些System.out.println 方法调用来帮助观察程序运行的操作过程。当然， 一旦发现问题的根源， 就要将这些语句从代码中删去。如果接下来又出现了问题， 就需要再插入几个调用System.out.println 方法的语句。记录日志API 就是为了解决这个问题而设计的。</p>
<h5 id="基本日志"><a href="#基本日志" class="headerlink" title="基本日志"></a>基本日志</h5><p>要生成简单的日志记录，可以使用全局日志记录器（global logger) 并调用其info 方法：<br>Logger.getGlobal().info(“aInfo”);</p>
<p>但是， 如果在适当的地方（如main 开始）调用：<br>Logger.getGlobal().setLevel(Level.OFF) ;<br>将会取消所有的日志。</p>
<h5 id="高级日志"><a href="#高级日志" class="headerlink" title="高级日志"></a>高级日志</h5><p>在一个专业的应用程序中，不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。可以调用getLogger 方法创建或获取记录器：<br>private static final Logger myLogger = Logger.getLogger(“com.mycompany.myapp”) :<br>未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要像上面的例子中一样， 用一个静态变量存储日志记录器的一个引用。</p>
<p>与包名类似， 日志记录器名也具有层次结构。日志记录器的父与子之间将共享某些属性。如果对com.mycompany 日志记录器设置了日志级别，它的子记录器也会继承这个级别。</p>
<p>有以下7 个日志记录器级别：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>在默认情况下， 只记录前三个个级别。也可以设置其他的级別：<br>logger.setLevel (Level .FINE) ;<br>现在， FINE 和更高级别的记录都可以记录下来。另外， 还可以使用Level.ALL 开启所有级别的记录， 或者使用Level.OFF 关闭所有级别的记录。</p>
<p>对于所有的级别有下面几种记录方法：<br>logger.fine(message) ;<br>logger.log(Level .FINE, message);</p>
<p>默认的日志记录将显示包含日志调用的类名和方法名。但是,如果虚拟机对执行过程进行了优化，就得不到准确的调用信息。此时，可以调用logp 方法获得调用类和方法的确切位置， 这个方法的签名为：<br>void logp(Level level, String className, String methodName, String message)<br>下面有一些用来跟踪执行流的方法：<br>void entering(String dassName, String methodName)<br>void entering(String className, String methodName, Object param)<br>void entering(String className, String methodName, Object[] params)<br>void exiting(St ring className, String methodName)<br>void exiting(St ring className, String methodName, Object result)<br>这些调用将生成FINER 级别和以字符串ENTRY 和RETURN 开始的日志记录。</p>
<p>记录日志的常见用途是记录那些不可预料的异常。可以使用下面两个方法提供日志记录中包含的异常描述内容：<br>void throwing(String className, String methodName , Throwable t)<br>void log(Level level , String message, Throwable t)<br>调用throwing 可以记录一条FINER 级别的记录和一条以THROW 开始的信息。</p>
<h5 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h5><p>在默认情况下， 配置文件存在于：jre/lib/logging.properties<br>要想使用另一个配置文件， 就要将java.util.logging.config.file 特性设置为配置文件的存储位置， 并用下列命令启动应用程序：<br>java -Djava.util.logging.config.file=configFile MainClass</p>
<p>日志管理器在VM 启动过程中初始化， 这在main 执行之前完成。如果在main中调用System.setProperty(“java.util.logging.config.file”，file), 也会调用LogManager.readConfiguration() 来重新初始化日志管理器。</p>
<p>要想修改默认的日志记录级别， 修改以下命令行<br>.level=INFO<br>可以通过添加以下内容来指定自己的日志记录级别<br>com.mycompany.myapp.level=FINE</p>
<p>日志记录并不将消息发送到控制台上，这是处理器的任务。要想在控制台上看到FINE 级别的消息， 就需要进行下列设置：<br>java.util.logging.ConsoleHandler.level=FINE</p>
<h5 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h5><p>本地化的应用程序包含资源包（ resource bundle ) 中的本地特定信息。资源包由各个地区的映射集合组成。</p>
<p>一个程序可以包含多个资源包。每个资源包都有一个名字。要想将映射添加到一个资源包中，需要为每个地区创建一个logmessage_language.properties 文件。可以将这些文件与应用程序的类文件放在一起， 以便ResourceBimdle 类自动地对它们进行定位。这些文件都是纯文本文件：<br>readingFile=Achtung! Datei wird eingelesen</p>
<p>在请求日志记录器时，可以指定一资源包：<br>Logger logger = Logger.getLogger(loggerName, “com.mycompany.logmessages”) ;<br>然后， 为日志消息指定资源包的关键字，而不是实际的日志消息字符串。<br>logger.info(“readingFile”);<br>通常需要在本地化的消息中增加一些参数，因此，消息应该包括占位符{0}、{1} 等：<br>Achtung! Datei {0} wird eingelesen.<br>然后，通过调用下面的一个方法向占位符传递具体的值：<br>logger.log(Level .INFO, “readingFile”, fileName) ;<br>logger,log(Level .INFO, “readingFile”, new Object[] { oldName, newName }) ;</p>
<h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><p>在默认情况下，日志记录器将记录发送到ConsoleHandler 中， 并由它输出到System.err流中。特别是， 日志记录器还会将记录发送到父处理器中，而最终的处理器（命名为“ ”）有一个ConsoleHandler。</p>
<p>与日志记录器一样， 处理器也有日志记录级别。对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。日志管理器配置文件设置的默认控制台处理器的日志记录级别为<br>java.util.logging.ConsoleHandler.level =INF0<br>要想记录FINE 级别的日志，就必须修改配置文件中的默认日志记录级别和处理器级别。</p>
<p>可以绕过配置文件，安装自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger = Logger.getLogger(<span class="string">&quot;com.mycompany.myapp&quot;</span>);</span><br><span class="line">logger.setLevel(Level.FINE);</span><br><span class="line">logger.setUseParentHandlers(<span class="keyword">false</span>);</span><br><span class="line">Handler handler = <span class="keyword">new</span> ConsoleHandler();</span><br><span class="line">handler.setLevel(Level.FINE);</span><br><span class="line">1ogger.addHandler(hander)</span><br></pre></td></tr></table></figure>
<p>要想将日志记录发送到其他地方， 就要添加其他的处理器。日志API为此提供了两个很有用的处理器， 一个是FileHandler ; 另一个是SocketHandler。</p>
<p>FileHandler将记录发送到用户主目录的javan.log 文件中， n 是文件名的唯一编号。如果用户系<br>统没有主目录，文件就存储在默认位置上。在默认情况下， 记录被格式化为XML。</p>
<p>可以通过设置日志管理器配置文件中的不同参数，或者利用其他的构造器来修改文件处理器的默认行为。</p>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>java.util.logging.FileHandler.level</td>
<td>处理器级别</td>
<td>Level.ALL</td>
</tr>
<tr>
<td>java.util.logging.FileHandler.append</td>
<td>控制处理器应该追加到一个已经存在的文件尾部；还是应该为每个运行的程序打开一个新文件</td>
<td>false</td>
</tr>
<tr>
<td>java.util.logging.FileHandler.limit</td>
<td>在打开另一个文件之前允许写入一个文件的近似最大字节数（ 0 表示无限制）</td>
<td>在FileHandler 类中为0 ( 表示无限制）；在默认的日志管理器配置文件中为50000</td>
</tr>
<tr>
<td>ava.util.logging.FileHandler.pattern</td>
<td>日志文件名的模式</td>
<td>%h/java%u.log</td>
</tr>
<tr>
<td>java.util .logging.FilcHandler.count</td>
<td>在循环序列中的日志记录数量</td>
<td>1 ( 不循环）</td>
</tr>
<tr>
<td>java.util.logging.FileHandler.filter</td>
<td>使用的过滤器类</td>
<td>没有使用过滤器</td>
</tr>
<tr>
<td>java.util.logging.FilcHandler.encoding</td>
<td>使用的字符编码</td>
<td>平台的编码</td>
</tr>
<tr>
<td>java.util.logging.FileHandler.formatter</td>
<td>记录格式器</td>
<td>ava.util.logging.XMLFormatter</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%h</td>
<td>系统属性user.home 的值</td>
</tr>
<tr>
<td>%t</td>
<td>系统临时目录</td>
</tr>
<tr>
<td>%u</td>
<td>用于解决冲突的唯一编号</td>
</tr>
<tr>
<td>%g</td>
<td>为循环日志记录生成的数值。（当使用循环功能且模式不包括%g时， 使用后缀%g)</td>
</tr>
<tr>
<td>%%</td>
<td>%字符</td>
</tr>
</tbody></table>
<p>开启文件循环功能是一个不错的主意。日志文件以myapp.log.0, myapp.log.1 , myapp.log.2, 这种循环序列的形式出现。</p>
<p>可以通过扩展Handler 类或StreamHandler 类自定义处理器。</p>
<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>在默认情况下， 过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。另外， 可以通过实现Filter 接口并定义下列方法来自定义过滤器：<br>boolean isLoggable(LogRecord record)<br>返回true 表示这些记录应该包含在日志中。</p>
<p>要想将一个过滤器安装到一个日志记录器或处理器中， 只需要调用setFilter 方法就可以了。注意，同一时刻最多只能有一个过滤器。</p>
<h5 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h5><p>可以自定义日志记录的格式。这需要扩展Formatter 类并覆盖下面这个方法：<br>String format(LogRecord record)<br>调用setFormatter 方法将格式化器安装到处理器中。</p>
<h5 id="日志记录说明"><a href="#日志记录说明" class="headerlink" title="日志记录说明"></a>日志记录说明</h5><ol>
<li><p>为一个简单的应用程序， 选择一个日志记录器，并把日志记录器命名为与主应用程序包一样的名字：<br>Logger logger = Logger.getLogger(“com.mycompany.myprog”);</p>
</li>
<li><p>默认的日志配置将级别等于或高于INFO 级别的所有消息记录到控制台。用户可以覆盖默认的配置文件。下列代码确保将所有的消息记录到应用程序特定的文件中。可以将这段代码放置在应用程序的main 方法中：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (System,getProperty(<span class="string">&quot;java,util.logging.config.class&quot;</span>) == <span class="keyword">null</span></span><br><span class="line">&amp;&amp; System.getProperty(<span class="string">&quot;java.util.logging.config.file&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Logger.getLogger(<span class="string">&quot;&quot;</span>).setLevel(Level.ALL);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> LOC_ROTATION_COUNT = <span class="number">10</span>;</span><br><span class="line">		Handler handler = <span class="keyword">new</span> FileHandler(<span class="string">&quot;Wmyapp.log&quot;</span>, <span class="number">0</span>, LSOG_ROTATION_COUNT):</span><br><span class="line">		Logger.getLogger(<span class="string">&quot;&quot;</span>).addHandler(handler):</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		logger.log(Level .SEVERE, <span class="string">&quot;Can&#x27;t create log file handler&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>现在，可以记录自己想要的内容了。但需要牢记： 所有级别为INFO、WARNING 和SEVERE 的消息都将显示到控制台上。 因此， 最好只将对程序用户有意义的消息设置为这几个级别。将程序员想要的日志记录，设定为FINE 是一个很好的选择。</li>
</ol>
<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>调试器是Eclipse、NetBeans 这类专业集成开发环境的一部分。在启动调试器之前，先给出一些有价值的建议：</p>
<ol>
<li>可以用下面的方法打印或记录任意变量的值：<br>System.out.println(“x=” + x); 或 Logger.getGlobal().info(“x=” + x);<br>要想获得隐式参数对象的状态，就可以打印this 对象的状态。<br>Logger.getGlobal().info(“this=” + this)；</li>
<li>一个不太为人所知但却非常有效的技巧是在每一个类中放置一个单独的main 方法。<br>这样就可以对每一个类进行单元测试。Java 虚拟机只调用启动类的main 方法。</li>
<li>JUnit 是一个非常常见的单元测试框架， 利用它可以很容易地组织测试用例套件。</li>
<li>日志代理（ logging proxy) 是一个子类的对象， 它可以截获方法调用， 并进行日志记录， 然后调用超类中的方法。</li>
<li>利用Throwable 类提供的printStackTrace 方法，可以从任何一个异常对象中获得堆栈情况。只要在代码的任何位置插入下面这条语句也可以获得堆栈轨迹：<br>Thread.dumpStack():</li>
<li>—般来说， 堆栈轨迹显示在System.err 上。也可以利用printStackTrace(PrintWriter s)方法将它发送到一个文件中。另外， 如果想记录或显示堆栈轨迹， 就可以采用下面的方式，将它捕获到一个字符串中：<br>StringWriter out = new StringWriter() ;<br>new Throwable().printStackTrace(new PrintWriter(out)) ;<br>String description = out.toString()；</li>
<li>通常， 将一个程序中的错误信息保存在一个文件中是非常有用的：<br>java MyProgram 2&gt; errors.txt<br>要想在同一个文件中同时捕获System.err和System.out , 需要使用下面这条命令<br>java MyProgram 1&gt; errors.txt 2&gt;&amp;1</li>
<li>让非捕获异常的堆栈轨迹出现在System.err 中并不是一个很理想的方法。比较好的方式是将这些内容记录到一个文件中。可以调用静态的Thread.setDefaultUncaughtExceptionHandler 方法改变非捕获异常的处理器：<br>Thread.setDefaultUncaughtExceptionHandler(<br>  new Thread.UncaughtExceptionHandler() {<pre><code>public void uncaughtException(Thread t , Throwable e) &#123;
  save information in logfile
&#125;</code></pre>
  })；</li>
<li>要想观察类的加载过程， 可以用-verbose 标志启动Java 虚拟机。</li>
<li>-Xlint 选项告诉编译器对一些普遍容易出现的代码问题进行检査。术语“ lint” 最初用来描述一种定位C 程序中潜在问题的工具， 现在通常用于描述查找可疑但不违背语法规则的代码问题的工具。<br>-Xlint 或-Xlint:all         执行所有的检查<br>-Xlint:deprecation     与-deprecation —样， 检查废弃的方法<br>-Xlint:fall through      检查switch 语句中是否缺少break 语句<br>-Xlint : finally              警告finally 子句不能正常地执行<br>-Xlint:none                 不执行任何检查<br>-Xlint : path                检查类路径和源代码路径上的所有目录是否存在<br>-Xlint :serial                警告没有serialVersionUID 的串行化类<br>-Xlint:unchecked       对通用类型与原始类型之间的危险转换给予警告</li>
<li>java 虚拟机增加了对Java 应用程序进行监控（monitoring) 和管理（management ) 的支持。jconsole 图形工具， 可以用于显示虚拟机性能的统计结果：<br>jconsole processID</li>
<li>可以使用jmap 实用工具获得一个堆的转储， 其中显示了堆中的每个对象。使用命令如下：<br> jmap -dump:format=b, file=dumpFileName processID<br> jhat dumpFileName<br> 然后，通过浏览器进人localhost:7000, 将会运行一个网络应用程序， 借此探查转储对象时堆的内容。</li>
<li>如果使用-Xprof 标志运行Java 虚拟机， 就会运行一个基本的剖析器来跟踪那些代码中经常被调用的方法。剖析信息将发送给System.out。输出结果中还会显示哪些方法是由即时编译器编译的。</li>
</ol>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>10图形程序设计</title>
    <url>/2021/04/26/10%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="Swing-概述"><a href="#Swing-概述" class="headerlink" title="Swing 概述"></a>Swing 概述</h3><p>在 Java 1.0 刚刚出现的时候，包含了一个用于基本 GUI 程序设计的类库，Sun将它称为抽象窗口工具箱（ Abstract Window Toolkit, AWT)。基本 AWT 库采用将处理用户界面元素的任务委派给每个目标平台（ Windows、Solaris、 Macintosh 等）的本地 GUI 工具箱的方式，由本地 GUI 工具箱负责用户界面元素的创建和动作。从理论上说，结果程序可以运行在任何平台上， 但观感（ look and feel ) 的效果却依赖于目标平台，因此，Sun 公司的口号是“ 一次编写，随处使用”。</p>
<p>对于简单的应用程序来说，基于对等体方法的效果还是不错的。但是，要想编写依赖于本地用户界面元素的高质量、 可移植的图形库就会暴露出一些缺陷。因此， 要想给予用户一致的、 可预见性的界面操作方式是相当困难的。而且，有些图形环境（如 XII/Motif) 并没有像 Windows 或 Macintosh 这样丰富的用户界面组件集合。这也就将基于对等体的可移植库限制在了“ 最小公分母” 的范围内。其结果使 AWT 构建的 GUI 应用程序看起来没有 Windows 或 Macintosh 应用程序显示的那么漂亮， 也没有提供那些平台用户所认知的功能。更加糟糕的是， 在不同平台上的 AWT 用户界面库中存在着不同的 bug。研发人员必须在每一个平号上测试应用程序， 因此人们嘲弄地将 AWT 称为“ 一次编写， 随处调试”。</p>
<p>在 1996 年，Netscape 创建了一种称为 IFC ( Internet Foundation Class) 的 GUI 库， 它采用了与 AWT 完全不同的工作方式。它将按钮、菜单这样的用户界面元素绘制在空白窗口上，而对等体只需要创建和绘制窗口。因此，Netscape 的 IFC 组件在程序运行的所有平台上的外观和动作都一样。Sun 与 Netscape 合作完善了这种方式， 创建了一个名为 Swing 的用户界面库。Swing 可作为 Java 1.1 的扩展部分使用， 现已成为 Java SE 1.2 标准库的一部分。JFC 特性不仅仅包含了 Swing 组件，而且还包含了一个可访问性 API、一2D API 和一个可拖放 API。</p>
<p>Swing 没有完全替代 AWT, 而是基于 AWT 架构之上。Swing 仅仅提供了能力更加强大的用户界面组件。 尤其在采用 Swing 编写的程序中，还需要使用基本的 AWT 处理事件。从现在开始，Swing 是指 “ 被绘制的” 用户界面类；AWT 是指像事件处理这样的窗口工具箱的底层机制。</p>
<p>Swing 给予不同平台的用户一致的感觉。不过，存在着一个潜在的问题： 如果在所有平台上用户界面元素看起来都一样， 那么它们就有可能与本地控件不一样，而这些平台的用户对此可能并不熟悉。Swing 采用了一种很巧妙的方式来解决这个问题。在程序员编写 Swing 程序时，可以为程序指定专门的“ 观感”。 Sun 开发了一种称为 Metal 的独立于平台的观感。现在，市场上人们将它称为“ Java 观感”。Java 7 提供了一个新观感， 称为 Nimbus, 不过默认情况下不可用。Nimbus使用了矢量绘图而不是位图绘图， 所以它不依赖于屏幕分辨率。Java SE 5.0 引入了一种称为 Synth 的观感，在 Synth中， 可以提供图像文件和 XML 描述文件来定义新的观感， 而无须进行任何编程。Napkin 观感为所有用户界面元素提供了一种手绘外观。</p>
<p>Eclipse 集成开发环境使用了一种与 AWT 类似称为 SWT 的图形工具箱， 它可以映射到不同平台的本地组件上。Oracle 正在开发一种替代技术， 称为 JavaFX, 将来某个时间可能会取代 Swing。</p>
<p>GUI 构造器可以用来设计应用程序的外观， 然后生成大部分（通常是全部）GUI 代码。尽管也有一些 Java 程序设计的 GUI 构造器，但要想有效地使用这些工具，需要知道如何手工地创建用户界面。</p>
<h3 id="创建框架"><a href="#创建框架" class="headerlink" title="创建框架"></a>创建框架</h3><p>在 Java 中，顶层窗口（就是没有包含在其他窗口中的窗口）被称为框架（frame )。在AWT 库中有一个称为 Frame 的类， 用于描述顶层窗口。这个类的 Swing 版本名为 JFrame,它扩展于 Frame 类。它的修<br>饰部件（按钮、标题栏、图标等）由用户的窗口系统绘制， 而不是由 Swing 绘制。</p>
<p>绝大多数 Swing 组件类都以“ J” 开头，如果偶然地忘记书写“ J”，程序仍然可以进行编译和运行，但是将 Swing 和 AWT 组件混合在一起使用将会导致视觉和行为的不一致。</p>
<p>Swing 类位于 javax.swing 包中。在默认情况下， 框架的大小为 0 x 0 像素， 这种框架没有什么实际意义。</p>
<p>所有的 Swing 组件必须由事件分派线程（event dispatch thread ) 进行配置，线程将鼠标点击和按键控制转移到用户接口组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventQueue.invokeLatter(() -&gt; &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>许多 Swing 程序并没有在事件分派线程中初始化用户界面。在主线程中完成初始化是通常采用的方式。遗憾的是， 由于 Swing 组件十分复杂， JDK 的程序员无法保证这种方式的安全性。 虽然发生错误的概率非常小， 但任何人不愿意成为遭遇这个问题的不幸者之一。</p>
<p>定义一个用户关闭这个框架时的响应动作，让程序退出：<br>frame.setDefaultCloseOperation(JFrame.EXIT_0N_CL0SE)；</p>
<p>简单地构造框架是不会自动地显示出来的， 框架起初是不可见的。这就给程序员了一个机会， 可以在框架第一次显示之前往其中添加组件。为了显示框架，main方法需要调用框架的 setVisible 方法。</p>
<p>在 Java SE 5.0 以前的版本中， 可以使用 JFrame 类从超类 Window 继承 show 方法。</p>
<p>在初始化语句结束后，main方法退出。需要注意，退出 main 并没有终止程序，终止的只是主线程。事件分派线程保持程序处于激活状态， 直到关闭框架或调用 SyStem.exit 方法终止程序。</p>
<p>可以调用 frame.setUndecorated(true) 关闭所有框架装饰。</p>
<h3 id="框架定位"><a href="#框架定位" class="headerlink" title="框架定位"></a>框架定位</h3><p>JFrame从各个超类中继承了许多用于处理框架大小和位置的方法 其中最重要的有下面几个：</p>
<ul>
<li>setLocation 和 setBounds 方法用于设置框架的位置。</li>
<li>setIconlmage 用于告诉窗口系统在标题栏、任务切换窗口等位置显示哪个图标。</li>
<li>setTitle 用于改变标题栏的文字。</li>
<li>setResizable 利用一个 boolean 值确定框架的大小是否允许用户改变。</li>
</ul>
<p>JFrame类的继承层次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JFrame -&gt; Frame -&gt; Window -&gt; Container -&gt; Component -&gt; Object</span><br><span class="line">JPanel -&gt; JComponent -&gt; Container</span><br></pre></td></tr></table></figure>
<p>对于框架来说， setLocation 和 setBounds 中的坐标均相对于整个屏幕。 在容器中包含的组件所指的坐标均相对于容器。</p>
<h5 id="框架属性"><a href="#框架属性" class="headerlink" title="框架属性"></a>框架属性</h5><p>组件类的很多方法是以获取 / 设置方法对形式出现的，这样的一个获取 / 设置方法对被称为一种属性。属性包含属性名和类型。将 get 或 set 之后的第一个字母改为小写字母就可以得到相应的属性名。例如， Frame 类有一个名为 title且类型为 String 的属性。</p>
<p>针对 get/set 约定有一个例外： 对于类型为 boolean 的属性， 获取方法由 is 开头。</p>
<h5 id="确定合适的框架大小"><a href="#确定合适的框架大小" class="headerlink" title="确定合适的框架大小"></a>确定合适的框架大小</h5><p>要记住： 如果没有明确地指定框架的大小，所有框架的默认值为 0 x 0 像素。</p>
<p>对于专业应用程序来说，应该检查屏幕的分辨率， 并根据其分辨率编写代码重置框架的大小。为了得到屏幕的大小，需调用 Toolkit 类的静态方法 getDefaultToolkit 得到一个 Toolkit 对象（Toolkit 类包含很多与本地窗口系统打交道的方法。) 然后，调用getScreenSize 方法，这个方法以 Dimension 对象的形式返回屏幕的大小。Dimension 对象同时用公有实例变量 width 和 height 保存着屏幕的宽度和高度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Toolkit kit &#x3D; Toolkit.getDefaultToolkit();</span><br><span class="line">Dimension screenSize &#x3D; kit.getScreenSize();</span><br><span class="line">int screenWidth &#x3D; screenSize.width;</span><br><span class="line">int screenHeight &#x3D; screenSize.height;</span><br></pre></td></tr></table></figure>
<p>处理框架给予的一些提示:</p>
<ul>
<li>如果框架中只包含标准的组件， 如按钮和文本框，那么可以通过调用 pack 方法设置框架大小。框架将被设置为刚好能够放置所有组件的大小。在通常情况下， 将程序的主框架尺寸设置为最大。可以通过调用下列方法将框架设置为最大。<br>frame.setExtendedState(Frame.MAXIMIZED_BOTH);</li>
<li>牢记用户定位应用程序的框架位置、 重置框架大小，并且在应用程序再次启动时恢复这些内容是一个不错的想法。</li>
<li>GraphicsDevice 类还允许以全屏模式执行应用。</li>
</ul>
<h3 id="在组件中显示信息"><a href="#在组件中显示信息" class="headerlink" title="在组件中显示信息"></a>在组件中显示信息</h3><p>可以将消息字符串直接绘制在框架中， 但这并不是一种好的编程习惯。在 Java 中， 框架被设计为放置组件的容器。</p>
<p>JFrame内部结构：从内到外依次是框架、根窗格（面板）、层级窗格、菜单栏（可选）、内容窗格、玻璃窗格。Swing 程序员最关心的是内容窗格。在设计框架的时候， 要使用下列代码将所有的组件添加到内容窗格中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container contentPane &#x3D; frame.getContentPane();</span><br><span class="line">Component c &#x3D; . . .;</span><br><span class="line">contentPane.add (c);</span><br></pre></td></tr></table></figure>
<p>绘制一个组件，需要定义一个扩展Component 的类，并覆盖其中的 paintComponent 方法。paintComponent 方法有一个 Graphics 类型的参数。在 Java 中，所有的绘制都必须使用 Graphics 对象，其中包含了绘制图案、 图像和文本的方法。Graphics 参数与 Windows 中的设备环境或 XII 程序设计中的图形环境基本类似。</p>
<p>无论何种原因， 只要窗口需要重新绘图， 事件处理器就会通告组件，从而引发执行所有组件的 paintComponent 方法。一定不要自己调用 paintComponent 方法。在应用程序需要重新绘图的时候， 这个方法将被自动地调用，不要人为地干预这个自动的处理过程。如果需要强制刷新屏幕， 就需要调用 repaint 方法， 而不是 paintComponent 方法。</p>
<p>有些程序员更喜欢妒展 JPanel, 而不是 JComponent。JPanel 是一个可以包含其他组件的容器（ container), 但同样也可以在其上面进行绘制。有一点不同之处是， 面板不透明， 这意味着需要在面板的边界内绘制所有的像素。 最容易实现的方法是， 在每个面板子类的 paintComponent 方法中调用 super.paintComponent 来用背景色绘制面板。</p>
<h3 id="处理2D图形"><a href="#处理2D图形" class="headerlink" title="处理2D图形"></a>处理2D图形</h3><p>自从 Java 版本 1.0 以来， Graphics 类就包含绘制直线、矩形和楠圆等方法。但是，这些绘制图形的操作能力非常有限。Java SE 1.2引人了 Java 2D 库，这个库实现了一组功能强大的图形操作。</p>
<p>要想使用 Java 2D 库绘制图形， 需要获得一个 Graphics2D 类对象。这个类是 Graphics 类的子类。自从 Java SE 2 版本以来，paintComponent 方法就会自动地获得一个 Graphics2D 类对象，我们只需要进行一次类型转换就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void paintComponent(Craphics g)</span><br><span class="line">&#123;</span><br><span class="line">	Craphics2D g2 &#x3D; (Graphics2D) g;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 2D 库采用面向对象的方式将几何图形组织起来。包含描述直线、 矩形的椭圆的类：Line2D、Rectangle2D、Ellipse2D。这些类全部实现了 Shape 接口。</p>
<p>要想绘制图形，首先要创建一个实现了 Shape 接口的类的对象， 然后调用 GraphicS2D 类中的 draw 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rectangle2D rect &#x3D; . . .;</span><br><span class="line">g2.draw(rect);</span><br></pre></td></tr></table></figure>
<p>在 1.0 的绘制方法中， 采用的是整型像素坐标， 而 Java 2D 图形采用的是浮点坐标。在 Java 2D库中， 内部的很多浮点计算都采用单精度 float。毕竟， 几何计算的最终目的是要设置屏幕或打印机的像素， 所以单精度完全可以满足要求了。只要舍人误差限制在一个像素的范围内，视觉效果就不会受到任何影响。然而，有时候程序员处理 float 并不太方便， 这是因为 Java 程序设计语言在将 double 值转换成 float 值时必须进行类型转换。由于后缀和类型转换都有点麻烦， 所以 2D 库的设计者决定为每个图形类提供两个版本：一个是为那些节省空间的程序员提供的 float 类型的坐标；另一个是为那些懒惰的程序员提供的 double 类型的坐标。创 建 一 个 Rectangle2D.Float 对 象 时， 应 该 提 供 float 型 数 值 的 坐 标。 而 创 建Rectangle2D. Double 对象时，应该提供 double 型数值的坐标。 Rectangle2D.Float 和 Rectangle2D.Double 都 扩 展 于 Rectangle2D 类。</p>
<p>Rectangle2D方法的参数和返回值均为 double 类型。</p>
<p>Rectangle2D 和 Ellipse2D 类都是由公共超类 RectangularShape 继承来的。无可非议， 椭圆不是矩形， 但它们都有着矩形边界。</p>
<p>从 Java 1.0 遗留下来的两个类也被放置在图形类的继承层次中。它们是 Rectangle 和 Point 类， 分别扩展于Rectangle2D 和 Point2D 类，并用整型坐标存储矩形和点。</p>
<p>图形类之间的关系:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Point -&gt; Point2D</span><br><span class="line">Line2D -&gt; Shape</span><br><span class="line">Ellipse2D -&gt; RectangularShape -&gt; Shape</span><br><span class="line">Rectangle -&gt; Rectangle2D -&gt; RectangularShape</span><br></pre></td></tr></table></figure>
<p>Rectangle2D 和 Ellipse2D 对象很容易构造。需要给出</p>
<ul>
<li>左上角的 x 和 y 坐标；</li>
<li>宽和高。</li>
</ul>
<p>对于椭圆，这些内容代表外接矩形。</p>
<p>如果得到的是矩形的两个对角点， 而这两个对角不一定是左上角和右下角。在这种情况下，首先创建一个空矩形，然后调用 setFrameFromDiagonal 方法，如下所示：<br>Rectangle2D rect = new Rectangle2D.Double()；<br>rect.setFrameFromDiagonal (px, py, qx, qy);<br>或者，如果已知的顶点分别用 Point2D 类型的两个对象 p 和 q 表示，就应该这样调用：<br>ract.setFrameFroiiiDiagonal (p, q);</p>
<p>在构造楠圆时，通常可以知道椭圆的中心、宽和高，而不是外接矩形的顶点。setFrameFromCenter 方法使用中心点，但仍然要给出四个顶点中的一个。因此，通常采用下列方式构造橢圆：<br>Ellipse2D ellipse = new Ellipse2D.Double(centerX - width / 2, centerY - height / 2, width, height);</p>
<p>要想构造一条直线，需要提供起点和终点。这两个点既可以使用 Point2D 对象表示，也可以使用一对数值表示：<br>Line2D line = new Line2D.Double(start, end);<br>或者<br>Line2D line = new Line2D.Double(startX, startY, endX, endY);</p>
<h3 id="使用颜色"><a href="#使用颜色" class="headerlink" title="使用颜色"></a>使用颜色</h3><p>使用 Graphics2D 类的 setPaint 方法可以为图形环境上的所有后续的绘制操作选择颜色。</p>
<p>只需要将调用 draw 替换为调用 fill 就可以用一种颜色填充一个封闭图形的内部。</p>
<p>要想绘制多种颜色， 就需要按照选择颜色、 绘制图形、 再选择另外一种颜色、 再绘制图形的过程实施。</p>
<p>fill 方法会在右侧和下方少绘制一个像素。 例如， 如果绘制一个 new Rectangle2D.Double(0, 0, 10, 20), 绘制的矩形将包括 x = 10 和 y = 20 的像素。如果填充这个矩形， 则不会绘制 x = 10 和 y= 20 的像素。</p>
<p>Color 类用于定义颜色。在 java.awt.Color 类中提供了 13 个预定义的常量， 它们分別表示 13 种标准颜色：BLACK , BLUE, CYAN, DARK_GRAY, CRAY, GREEN, LIGHT_CRAY , MACENTA, ORANGE, PINK, RED, WHITE, YELLOW。</p>
<p>在 Java SE 1.4 之前的版本中， 颜色常量的名字为小写形式，为了向后兼容， 也可以用小写形式。</p>
<p>可以通过提供红、 绿和蓝三色成分来创建一个 Color 对象， 以达到定制颜色的目的。三种颜色都是用 0 ~ 255(也就是一个字节）之间的整型数值表示， 调用 Color 的构造器格式为：<br>Color(int redness, int greenness, int blueness)</p>
<p>如果使用 Graphics对象， 而不是 Graphics2D 对象， 就需要使用 setColor 方法设置颜色。</p>
<p>要想设置背景颜色， 就需要使用 Component 类中的 setBackground 方法。setForeground方法用来设定在组件上进行绘制时使用的默认颜色。</p>
<p>Color 类中的 brighter( ) 方法和 darker( ) 方法的功能， 它们分别加亮或变暗当前的颜色。</p>
<p>Java 在 SystemColor 类中预定义了很多颜色的名字。在这个类中的常量， 封装了用户系统的各个元素的颜色。）当希望让绘制的用户界面元素与用户桌面上已经存在的其他元素的颜色匹配时， 使用 SystemColor 类中的颜色非常有用。</p>
<p>系统颜色：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>desktop</td>
<td>桌面的背景颜色</td>
</tr>
<tr>
<td>activeCaption</td>
<td>标题的背景颜色</td>
</tr>
<tr>
<td>activeCaptionText</td>
<td>标题的文本颜色</td>
</tr>
<tr>
<td>activeCaptionBorder</td>
<td>标题文本的边框颜色</td>
</tr>
<tr>
<td>inactiveCaption</td>
<td>非活动标题的背景颜色</td>
</tr>
<tr>
<td>inactiveCaptionText</td>
<td>非活动标题的文本颜色</td>
</tr>
<tr>
<td>inactiveCaptionBorder</td>
<td>非活动标题的边框颜色</td>
</tr>
<tr>
<td>textInactiveTest</td>
<td>非活动控件的文本颜色</td>
</tr>
<tr>
<td>textHighlight</td>
<td>髙亮度文本的背景颜色</td>
</tr>
<tr>
<td>textHighlightText</td>
<td>髙亮度文本的文本颜色</td>
</tr>
<tr>
<td>control</td>
<td>控件的背景颜色</td>
</tr>
<tr>
<td>controlText</td>
<td>控件的文本颜色</td>
</tr>
<tr>
<td>controlLtHighlight</td>
<td>控件的浅高亮度颜色</td>
</tr>
<tr>
<td>window</td>
<td>窗口的背景</td>
</tr>
<tr>
<td>windowBorder</td>
<td>窗口边框的颜色</td>
</tr>
<tr>
<td>windowText</td>
<td>窗口内的文本颜色</td>
</tr>
<tr>
<td>menu</td>
<td>菜单的背景颜色</td>
</tr>
<tr>
<td>menuText</td>
<td>菜单的文本颜色</td>
</tr>
<tr>
<td>text</td>
<td>文本的背景颜色</td>
</tr>
<tr>
<td>textText</td>
<td>文本的前景颜色</td>
</tr>
<tr>
<td>controlHighlight</td>
<td>控件的高亮度颜色</td>
</tr>
<tr>
<td>controlShadow</td>
<td>控件的阴影颜色</td>
</tr>
<tr>
<td>controlDkShadow</td>
<td>控件的暗阴影颜色</td>
</tr>
<tr>
<td>scrollbar</td>
<td>滚动条的背景颜色</td>
</tr>
<tr>
<td>info</td>
<td>帮助区文本的颜色</td>
</tr>
<tr>
<td>infoText</td>
<td>帮助区的文本颜色</td>
</tr>
</tbody></table>
<h3 id="文本使用特殊字体"><a href="#文本使用特殊字体" class="headerlink" title="文本使用特殊字体"></a>文本使用特殊字体</h3><p>人们可以通过字体名（ font face name) 指定一种字体。字体名由“ Helvetica” 这样的字体家族名（font family name) 和一个可选的“ Bold” 后缀组成。</p>
<p>要想知道某台特定计算机上允许使用的字体， 就需要调用 GraphicsEnvironment 类中的getAvailableFontFamilyNames 方法。这个方法将返回一个字符型数组， 其中包含了所有可用的字体名。GraphicsEnvironment 类描述了用户系统的图形环境， 为了得到这个类的对象，需要调用静态的 getLocalGraphicsEnvironment 方法。即：<br>GraphicsEnviroment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();</p>
<p>字体名可以商标化， 字体设计在一些权限内可以版权化。因此，字体的分发需要向字体的创始者付版税。</p>
<p>为了创建一个公共基准， AWT 定义了五个逻辑（logical) 字体名：SansSerif、Serif、Monospaced、Dialog、Dialoglnput。这些字体将被映射到客户机上的实际字体。</p>
<p>Oracle JDK 包含 3 种字体，它们是“Lucida Sans”，“ Lucida Bright” 和“ Lucida Sans Typewriter”。</p>
<p>要想使用某种字体绘制字符， 必须首先利用指定的字体名、字体风格和字体大小来创建—个 Font 类对象：<br>Font font = new Font(“FontName”, Font.BOLD, 14);<br>在 Font 构造器中，提供字体名的位置也可以给出逻辑字体名称。<br>第二个参数可以指定字体的风格，下面是几个字体风格的值：Font.PLAIN、Font.BOLD、Font.ITALIC、Font.BOLD + Font.ITALIC。<br>第三个参数是以点数目计算的字体大小。点数目是排版中普遍使用的表示字体大小的单位，每英寸包含 72 个点。</p>
<p>字体映射定义在 Java 安装的 jre/lib 子目录中的 fontconfig.properties 文件中。</p>
<p>可以读取 TrueType 或 PostScriot Type 1 格式的字体文件。这需要一个字体输人流。通常从磁盘文件或者 URL 读取。然后调用静态方法Font.createFont:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;www.fonts.com&#x2F;Wingbats.ttf&quot;);</span><br><span class="line">InputStream in &#x3D; url.openStream();</span><br><span class="line">Font fl &#x3D; Font.createFont(Font.TRUETYPE_FONT, in);</span><br></pre></td></tr></table></figure>
<p>上面定义的字体为常规字体，大小为 1。可以使用 deriveFont 方法得到希望大小的字体：<br>Font f = fl.deriveFont(14.0F);<br>deriveFont 方法有两个重栽版本。一个（有一个 float 参数）设置字体的大小；另一个（有一个 int 参数）设置字体风格。</p>
<p>要想得到屏幕设备字体属性的描述对象， 需要调用 GraphicS2D 类中的 getFontRenderContext 方法。它将返回一个 FontRenderContext 类对象。可以直接将这个对象传递给 Font 类的 getStringBounds 方法：<br>FontRenderContext context = g2.getFontRenderContext()；<br>Rectangle2D bounds = font.getStringBounds(message, context);<br>getStringBounds 方法将返回包围字符串的矩形</p>
<p>基线(baseline) 是一条虚构的线， 例如，字母“ e” 所在的底线。上坡度（ascent) 是从基线到坡顶( ascenter) 的距离。例如，“b” 和“k” 以及大写字母的上面部分。下坡度（descent) 是从基线到坡底（descenter) 的距离， 坡底是“p” 和“ g” 这种字母的底线。行间距（ leading) 是某一行的坡底与其下一行的坡顶之间的空隙。字体的高度是连续两个基线之间的距离， 它等于下坡度 + 行间距 + 上坡度。</p>
<p>getStringBounds 方法返回的矩形宽度是字符串水平方向的宽度。矩形的高度是上坡度、下坡度、 行间距的总和。这个矩形始于字符串的基线，矩形顶部的 y 坐标为负值。因此，可以采用下面的方法获得字符串的宽度、 髙度和上坡度：<br>double stringWidth = bounds.getWidth();<br>double stringHeight = bounds.getHeight();<br>double ascent = -bounds.getY();</p>
<p>如果需要知道下坡度或行间距，可以使用 Font 类的 getLineMetrics 方法。这个方法将返回一个 LineMetrics 类对象，获得下坡度和行间距的方法是：<br>LineMetrics metrics = f.getLineMetrics(message, context);<br>float descent = raetrics.getDescent()；<br>float leading = metrics.getLeading()；</p>
<h3 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h3><p>Imagelcon 类：<br>Image image = new Imagelcon(filename).getlmage();<br>这里的变量 image 包含了一个封装图像数据的对象引用。可以使用 Graphics类的 drawlmage方法将图像显示出来。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>13部署Java应用程序</title>
    <url>/2021/04/26/13%E9%83%A8%E7%BD%B2Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="JAR-文件"><a href="#JAR-文件" class="headerlink" title="JAR 文件"></a>JAR 文件</h3><p>Java 归档（JAR) 文件既可以包含类文件，也可以包含诸如图像和声音这些其他类型的文件。 JAR 文件使用了大家熟悉的 ZIP 压缩格式。</p>
<a id="more"></a>

<h5 id="创建-JAR-文件"><a href="#创建-JAR-文件" class="headerlink" title="创建 JAR 文件"></a>创建 JAR 文件</h5><p>使用 jar 工具制作 JAR 文件（位于 jdk/bin 目录下)。创建一个新的 JAR 文件应该使用的常见命令格式为：<br>jar cvf JARFileName File1 File2 . . .</p>
<p>jar 命令的格式如下：<br>jar options File1 File2 . . .</p>
<p>jar 程序选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>创建一个新的或者空的存档文件并加人文件。 如果指定的文件名是目录，jar程序将会对它们进行递归处理</td>
</tr>
<tr>
<td>C</td>
<td>暂时改变目录</td>
</tr>
<tr>
<td>e</td>
<td>在清单文件中创建一个条目</td>
</tr>
<tr>
<td>f</td>
<td>将 JAR 文件名指定为第二个命令行参数。如果没有这个参数，jar 命令会将结果写到标准输出上（在创建 JAR 文件时）或者从标准输入中读取它 （在解压或者列出 JAR 文件内容时）</td>
</tr>
<tr>
<td>i</td>
<td>建立索引文件（用于加快对大型归档的查找）</td>
</tr>
<tr>
<td>m</td>
<td>将一个清单文件（ manifest ) 添加到 JAR 文件中。清单是对存档内容和来源的说明每个归档有一个默认的清单文件。但是， 如果想验证归档文件的内容， 可以提供自己的清单文件</td>
</tr>
<tr>
<td>M</td>
<td>不为条目创建清单文件</td>
</tr>
<tr>
<td>t</td>
<td>显示内容表</td>
</tr>
<tr>
<td>u</td>
<td>更新一个已有的 JAR 文件</td>
</tr>
<tr>
<td>v</td>
<td>生成详细的输出结果</td>
</tr>
<tr>
<td>x</td>
<td>解压文件。 如果提供一个或多个文件名， 只解压这些文件；否则， 解压所有文件</td>
</tr>
<tr>
<td>0</td>
<td>存储，不进行 ZIP m缩</td>
</tr>
</tbody></table>
<h5 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h5><p>清单文件 （manifest)用于描述归档特征。清单文件被命名为 MANIFEST.MF , 它位于 JAR 文件的一个特殊 META-INF 子目录中。最小的符合标准的清单文件：<br>Manifest-Version: 1.0<br>复杂的清单文件可能包含更多条目。这些清单条目被分成多个节。第一节被称为主节( main section ) 。它作用于整个 JAR 文件。随后的条目用来指定已命名条目的属性，这些已命名的条目可以是某个文件、 包或者 URL。它们都必须起始于名为 Name 的条目。节与节之间用空行分开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">描述这个归档文件的行</span><br><span class="line"></span><br><span class="line">Name: Woozle.class</span><br><span class="line">描述这个文件的行</span><br><span class="line">Name: cora&#x2F;mycompany&#x2F;mypkg&#x2F;</span><br><span class="line">描述这个包的行</span><br></pre></td></tr></table></figure>
<p>要想编辑清单文件， 需要将希望添加到清单文件中的行放到文本文件中，然后运行：<br>jar cfm JARFileName ManifestFileName …<br>要想更新一个已有的 JAR 文件的清单，则需要将增加的部分放置到一个文本文件中，然后执行下列命令：<br>jar ufin JARFileName ManifestFileName</p>
<p>清单文件的最后一行必须以换行符结束。 否则， 清单文件将无法被正确地读取。</p>
<h5 id="可执行-JAR-文件"><a href="#可执行-JAR-文件" class="headerlink" title="可执行 JAR 文件"></a>可执行 JAR 文件</h5><p>可以使用jar 命令中的 e 选项指定程序的人口点， 即通常需要在调用java 程序加载器时指定的类：<br>jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files to add<br>或者， 可以在清单中指定应用程序的主类，包括以下形式的语句：<br>Main-Class: com.mycompany.mypkg.MainAppClass<br>不要将扩展名 .class 添加到主类名中。<br>用户可以通过下面命令来启动应用程序：<br>java -jar MyProgram.jar<br>根据操作系统的配置， 用户可以通过双击 JAR 文件图标来启动应用程序。在 Windows 平台中， 可以使用第三方的包装器工具（Launch4J、IzPack）将 JAR 文件转换成 Windows 可执行文件（.exe）。</p>
<h5 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h5><p>在 applet 和应用程序中使用的类通常需要使用一些相关的数据文件，这些关联的文件被称为资源（resource)。Java 资源作为单独的文件存储， 并不是作为类文件的一部分存储。对资源的访问和解释由每个程序自己完成。</p>
<p>类加载器知道如何搜索类文件，直到在类路径、 存档文件或 web 服务器上找到为止。利用资源机制， 对于非类文件也可以同样方便地进行操作。步骤：<br>1 ) 获得具有资源的 Class 对象。<br>2 ) 如果资源是一个图像或声音文件， 就需要调用 getResource (filename) 获得作为URL 的资源位置，然后利用 getlmage 或 getAudioClip 方法进行读取。<br>3 ) 其他资源使用 getResourceAsStream 方法读取文件中的数据。<br>重点在于类加载器可以记住如何定位类，然后在同一位置査找关联的资源。<br>除了可以将资源文件与类文件放在同一个目录中外，还可以将它放在子目录中。可以使用相对资源名（相对路径），它会被解释为相对于加载这个资源的类所在的包。 必须使用“ /” 作为分隔符。一个以“ /”开头的资源名被称为绝对资源名，它的定位方式与类在包中的定位方式一样。</p>
<p>文件的自动装载是利用资源加载特性完成的。没有标准的方法来解释资源文件的内容。每个程序必须拥有解释资源文件的方法。</p>
<p>与语言相关的字符串，都存放在资源文件中，每种语言对应一个文件。 国际化 API 提供了组织和访问本地化文件的标准方法。</p>
<h5 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h5><p>如果在代码中使用了包可见的类、方法和域，就可能希望密封包。如果不密封， 其他类就有可能放在这个包中，进而访问包可见的特性。</p>
<p>在默认情况下，JAR 文件中的包是没有密封的。可以在清单文件的主节中加人下面一行：<br>Sealed: true<br>来改变全局的默认设定。对于每个单独的包，可以通过在 JAR 文件的清单中增加一节， 来指定是否想要密封这个包：<br>Name: com/mycoinpany/util/<br>Sealed: true</p>
<h3 id="应用首选项的存储"><a href="#应用首选项的存储" class="headerlink" title="应用首选项的存储"></a>应用首选项的存储</h3><p>应用用户通常希望能保存他们的首选项和定制信息， 以后再次启动应用时再恢复这些配置。</p>
<h5 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h5><p>属性映射（ property map) 是一种存储键 / 值对的数据结构。属性映射通常用来存储配置信息，它有 3 个特性：</p>
<ul>
<li>键和值是字符串。</li>
<li>映射可以很容易地存人文件以及从文件加载。</li>
<li>有一个二级表保存默认值。</li>
</ul>
<p>实现属性映射的 Java 类名为 Properties。可以使用 store方法将属性映射列表保存到一个文件中：<br>OutputStream out = new FileOutputStream(“program.properties”);<br>settings.store(out, “Program Properties”);<br>要从文件加载属性，可以使用以下调用：<br>InputStrean in = new FileInputStream(“program.properties”);<br>settings.load(in);</p>
<p>习惯上， 会把程序属性存储在用户主目录的一个子目录中。目录名通常以一个点号开头(在 UNIX 系统中) ，这个约定说明这是一个对用户隐藏的系统目录。要找出用户的主目录，可以调用System.getProperties 方法，它恰好也使用一个 Properties 对象描述系统信息。主目录包含键”user.home”。还有一个便利方法可以读取单个键：<br>String userDir = System.getProperty(“user.home”)；</p>
<p>可以为程序属性提供默认值。Properties 类有两种提供默认值的机制。第一种方法是， 查找一个字符串的值时可以指定一个默认值，这样当键不存在时就会自动使用这个默认值：<br>String title = settings.getProperty(“title”, “Default title”);<br>第二种方法是把所有默认值都放在一个二级属性映射中，并在主属性映射的构造器中提供这个二级映射：<br>Properties settings = new Properties(defaultSettings);<br>如果为 defaultSettings 构造器提供另一个属性映射参数，甚至可以为默认值指定默认值。</p>
<p>出于历史上的原因，Properties 类实现了 Map&lt;Object,Object&gt;。 因此， 可以使用 Map 接口的 get 和 put 方法。不过，get 方法会返回类型 Object, 而 put 方法允许插入任何对象。 最好坚持使用 getProperty 和 setProperty 方法，这些方法会处理字符串，而不是对象。</p>
<p>属性映射是没有层次结构的简单表。 通常会用类似 window.main.color、window.main.title 等键名引入一个伪层次结构 。不过 Properties 类没有提供方法来组织这样一个层次结构。如果存储复杂的配置信息， 就应当使用 Preferences 类。</p>
<p>使用属性文件有以下缺点：</p>
<ul>
<li>有些操作系统没有主目录的概念， 所以很难找到一个统一的配置文件位置。</li>
<li>关于配置文件的命名没有标准约定， 用户安装多个 Java 应用时，就更容易发生命名冲突。</li>
</ul>
<h5 id="首选项-API"><a href="#首选项-API" class="headerlink" title="首选项 API"></a>首选项 API</h5><p>Preferences 类以一种平台无关的方式提供了一个中心存储库。Preferences 存储库有一个树状结构， 节点路径名类似于 /com/mycompany/myapp。建议配置节点路径要与程序中的包名一致。存储库的各个节点分别有一个单独的键 / 值对表，可以用来存储数值、字符串或字节数组，但不能存储可串行化的对象。为了增加灵活性，可以有多个并行的树。每个程序用户分别有一棵树；另外还有一棵系统树， 可以用于存放所有用户的公共信息。 Preferences 类使用操作系统的“ 当前用户” 概念来访问适当的用户树。</p>
<p>若要访问树中的一个节点，需要从用户或系统根开始：<br>Preferences root = Preferences.userRoot();<br>Preferences root = Preferences.systemRoot();</p>
<p>访问节点。可以直接提供一个节点路径名:<br>Preferences node = root.node(“/com/mycompany/myapp”);<br>如果节点的路径名等于类的包名。只需要得到这个类的一个对象，然后调用：<br>Preferences node = Preferences.userNodeForPackage (obj.getClass());<br>Preferences node = Preferences.systemNodeForPackage(obj.getClass());</p>
<p>一旦得到了节点，可以用以下方法访问键 / 值表：<br>String get(String key, String defval)<br>int getInt(String key, int defval)<br>long getLong(String key, long defval)<br>float get FIoat(String key, float defval)<br>double getDouble(String key, double defval)<br>boolean getBoolean(String key, boolean defval)<br>byte[] getByteArray(String key, byte[] defval)<br>读取信息时必须指定一个默认值， 以防止没有可用的存储库数据。</p>
<p>可以用如下的 put 方法向存储库写数据：<br>put(String key, String value)<br>putInt(String key, int value)<br>…</p>
<p>可以用以下方法枚举一个节点中存储的所有键：<br>String[] keys()<br>目前没有办法找出一个特定键对应的值的类型。</p>
<p>可以通过调用以下方法导出一个子树(或者比较少见的，也可以是一个节点）的首选项：<br>void exportSubtree(OutputStream out)<br>void exportNode(OutputStream out)<br>数据用 XML 格式保存。可以通过调用以下方法将数据导人到另一个存储库：<br>void importPreferences(InputStreain in)</p>
<h3 id="服务加载器"><a href="#服务加载器" class="headerlink" title="服务加载器"></a>服务加载器</h3><p>利用 ServiceLoader 类可以很容易地加载符合一个公共接口的插件。</p>
<p>定义一个接口（或者， 如果愿意也可以定义一个超类)， 其中包含服务的各个实例应当提供的方法：<br>package serviceLoader;<br>public interface Cipher {}</p>
<p>服务提供者可以提供一个或多个实现这个服务的类：<br>package serviceLoader.impl ;<br>public class CaesarCipher implements Cipher {}<br>每个实现类必须有一个无参数构造器。现在把这些类的类名增加到 META-INF/services 目录下的一个 UTF-8 编码文本文件中，文件名必须与完全限定类名一致：<br>文件 META-INF/services/serviceLoader.Cipher 必须包含这样一行：<br>serviceLoader.impl.CaesarCipher</p>
<p>程序可以如下初始化一个服务加载器：<br>public static ServiceLoader&lt;Cipher&gt; cipherLoader = ServiceLoader.load(Cipher.class);<br>这个初始化工作只在程序中完成一次。服务加载器的 iterator 方法会对服务提供的所有实现返冋一个迭代器。</p>
<h3 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h3><p>applet 是包含在 HTML 页面中的 Java 程序。需要使用 applet 的标记( tag) 告诉浏览器从哪里得到类文件， 以及这个 applet 在 Web 页面上如何定位（大小、位置等)。然后浏览器再从 Internet (或者从用户机器上的某个目录）获取类文件， 并自动运行 applet。</p>
<p>最初开发 applet 时， 必须使用 Sun 的 HotJava 浏览器才能査看包含 applet 的 Web 页面。<br>Netscape 在它的 Navigator 浏览器中包含了一个 Java 虚拟机，那时 Java applet 才开始流行。<br>Sun Microsystems 开发了“ Java Plug-in”。通过使用浏览器扩展机制，可以把插件插人不同的浏览器， 允许这些浏览器使用外部 Java 运行时环境执行 Java applet。<br>尽管不时会发现 Java 虚拟机的安全漏洞并被恶意利用， 但 Sun Microsystems 和后来的 Oracle 在修补这些漏洞方面却动作迟缓， 举措不力。如今，开发人员要部署 Java applet 会很困难， 用户运行 applet 也不容易。</p>
<h5 id="一个简单的-applet"><a href="#一个简单的-applet" class="headerlink" title="一个简单的 applet"></a>一个简单的 applet</h5><p>applet 就是一个扩展了 java.applet.Applet 类的 Java 类。如果你的 applet 包含 Swing 组件， 必须扩展 JApplet 类。普通 Applet 中的 Swing组件不能正确绘制。</p>
<p>Applet 继承图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object &lt;- Component &lt;- Container &lt;- Panel &lt;- Applet &lt;- JApplet</span><br></pre></td></tr></table></figure>
<p>HTML文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;applet class&#x3D;&quot;applet&#x2F;NotHel1olilorld.class&quot; archive&#x3D;&quot;NotHelloWorld.jar&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot;&gt;</span><br><span class="line">&lt;&#x2F;applet&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器中査看 applet 之前， 最好先在 JDK 自带的 applet viewer ( applet 查看器）程序中进行测试：<br>appletviewer NotHelloWorldApplet.html<br>applet 査看器程序只会显示 applet , 而 不 会 显 示周 围 的 HTML 文本。 如果你的 HTML 文件包含多个 applet 标记， applet 查 看 器 就 会 弹 出 多 个窗口。</p>
<p>要正确地査看 applet, 只 需 要 把 HTML 文件加载到浏览器。如果 applet 没有出现， 则需要安装 JavaPlug-in，并允许它加载无签名的本地 applet。如果修改了 applet 并重新编译， 就需要重新启动浏览器， 这样才会加载新的类文件。可以利用 Java控制台避免烦人的浏览器重启。</p>
<p>把一个图形化 Java 应用转换为可以嵌入在 Web 页面中的 applet 的具体的步骤：</p>
<ol>
<li>建立一个HTML 页面， 其中包含加载 applet 代码的适当标记。</li>
<li>提供 JApplet 类的一个子类。将这个类标记为 public。否则 applet 将无法加载。</li>
<li>删去应用中的 main 方法。不要为应用构造框架窗口。应用将在浏览器中显示。</li>
<li>把所有初始化代码从框架窗口移至 applet 的 init 方法。不需要明确构造 applet 对象，浏览器会实例化 applet 对象并调用 init 方法。</li>
<li>删除 setSize 调用；对 applet 来说， 用 HTML 文件中的 width 和 height 参数就可以指定大小。</li>
<li>删除 setDefaultCloseOperation 调用。applet 不能关闭；浏览器退出时 applet 就会终止运行。</li>
<li>删除 setTitle调用。applet 没有标题栏。（当然，可以用 HTML title 标记为 Web 页面本身指定标题。）</li>
<li>删除 setVisible(true)调用。applet 会自动显示。</li>
</ol>
<h5 id="applet-HTML-标记和属性"><a href="#applet-HTML-标记和属性" class="headerlink" title="applet HTML 标记和属性"></a>applet HTML 标记和属性</h5><p>可以在 applet 标记中使用以下属性：</p>
<ul>
<li>width, height：指定了 applet 的宽度和高度（单位为像素）。</li>
<li>align：这个属性指定了 applet 的对齐方式。</li>
<li>vspace, hspace：指定了 applet 上下的像素数（ vspace) 以及左右两边的像素数（hspace ) 。</li>
<li>code：这个属性指定了 applet 的类文件名。路径名必须与 applet 类的包一致。这个属性可以是 code=”com/mycompany/MyApplet.class”， 也可以是 code=”com.mycompany.MyApplet.class”。浏览器会自动加载applet 包含的其他类文件。</li>
<li>archive：这个属性会列出包含 applet 的类以及其他资源的 JAR 文件。这些文件会在加载 applet 之前从 Web 服务器获。可能有多个 JAR 文件，JAR 文件用逗号分隔。</li>
<li>codebase：这个属性是加载 JAR 文件（早期还可以加载类文件）的 URL。</li>
<li>object：这个属性已经过时， 可以指定包含串行化 applet 对象的文件的文件名，这个文件用于持久存储 applet 状态。由于没有办法对一个串行化文件签名，所以这个特性已经没有用了。</li>
<li>alt：Java 禁用时，可以使用 alt 属性来显示一个消息。如果一个浏览器根本无法处理 applet, 它会忽略未知的 applet 和 param 标记。浏览器会显示标记之间的所有文本。与之相反，支持 Java 的浏览器不会显示标记之间的任何文本。</li>
<li>name：编写脚本的人可以为applet 指定一 个 name 属性， 用来指示所编写的 applet。希望同一个页面上的两个 applet 相互直接通信时 name 属性也很重要。</li>
</ul>
<h5 id="使用参数向-applet-传递信息"><a href="#使用参数向-applet-传递信息" class="headerlink" title="使用参数向 applet 传递信息"></a>使用参数向 applet 传递信息</h5><p>applet 可以使用内嵌在 HTML 文件中的参数。这是利用 HTML param 标记以及所定义的属性来完成的。</p>
<p>使用以下 HTML 标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;applet code&#x3D;&quot;FontParamApplet.class&quot; ...&gt;</span><br><span class="line">	&lt;param name&#x3D;&quot;font&quot; value&#x3D;&quot;Helvetica&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;applet&gt;</span><br></pre></td></tr></table></figure>
<p>然后使用 Applet 类的 getParameter 方法得到参数的值。只能在 applet 的 init 方法中调用getParameter 方法， 而不能在构造器中调用。执行applet 构造器时， 参数还没有准备好。参数总是作为字符串返回。如果需要数值类型， 则需要将字符串转换为数值。param 标记中的 name 属性值与 getParameter 方法的参数匹配时， 会使用不区分大小写的比较。除了要确保代码中的参数匹配之外， 还要检查是否缺少参数。可以简单地测试是否为 null来达到目的。</p>
<h5 id="访问图像和音频文件"><a href="#访问图像和音频文件" class="headerlink" title="访问图像和音频文件"></a>访问图像和音频文件</h5><p>applet 可以处理图像和音频。图像必须是 GIF、 PNG 或 JPEG 格式，音频文件必须是 AU、AIFF、 WAV 或 MIDI。另外也支持动画 GIF。</p>
<p>要用相对 URL 指定图像和音频文件的位置。通常可以通过调用 getDocumentBase 或 getCodeBase 方法得到基 URL , 前一个方法会得到包含这个 applet 的 HTML 页面的 URL, 后者会得到 applet 的 codebase 属性指定的 URL。可以为 getlmage 或 getAudioClip 方法提供基 URL 和文件位置。</p>
<p>要播放一段音频， 只需要调用它的 play 方法。还可以调用 Applet 类的 play 方法而无须先加载这段音频。</p>
<h5 id="applet-上下文"><a href="#applet-上下文" class="headerlink" title="applet 上下文"></a>applet 上下文</h5><p>applet 可以要求浏览器为它做些事情，浏览器可能会执行这些请求，也可能将其忽略。</p>
<p>要与浏览器通信，applet 可以调用 getAppletContext 方法。这个方法会返回一个实现 AppletContext 接口的对象。</p>
<h5 id="applet-间通信"><a href="#applet-间通信" class="headerlink" title="applet 间通信"></a>applet 间通信</h5><p>如果一个 Web 页面包含来自同一个 codebase 的多个 applet，它们可以相互通信。</p>
<p>如果为 HTML 文件中的各个 applet 指定 name 属性，可以使用 AppletContext 接口的 getApplet 方法来得到这个 applet 的一个引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;applet code&#x3D;&quot;Chart.class&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; name&#x3D;&quot;Chart1&quot;&gt;</span><br><span class="line">Applet chartl &#x3D; getAppletContext().getApplet(&quot;Chartl&quot;);</span><br></pre></td></tr></table></figure>
<p>通过适当的类型转换来使用这个引用。</p>
<p>getApplets 方法会返回一个枚举对象。可以列出一个 Web 页面上的所有 applet, 不论它们是否有 name 属性。</p>
<p>applet 不能与不同 Web 页面上的其他 applet 通信。</p>
<h5 id="在浏览器中显示信息项"><a href="#在浏览器中显示信息项" class="headerlink" title="在浏览器中显示信息项"></a>在浏览器中显示信息项</h5><p>可以访问外围浏览器的两个区域：状态栏和 Web 页面显示区， 这都要使用 AppletContext 接口的方法。可以用 showStatus 方法在浏览器底部的状态栏中显示一个字符串。showStatus 的作用有限。浏览器也会经常使用状态栏， 它会覆盖原先的消息。可以使用状态栏显示不太重要的消息， 而不能显示用户不能遗漏的消息。可以用 showDocument 方法告诉浏览器显示一个不同的 Web 页面。提供一个要显示的 URL，它会在当前页面所在的同一个窗口中打开新 Web 页面。可以提供第二个参数（<code>&quot;_blank&quot;</code>）告诉浏览器在另一个窗口中显示文档。</p>
<p>showDocument 方法：</p>
<table>
<thead>
<tr>
<th>目标参数</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>“_self”或无</td>
<td>在当前框架中显示文档</td>
</tr>
<tr>
<td>“_parent”</td>
<td>在父框架中显示文档</td>
</tr>
<tr>
<td>“_top”</td>
<td>在最顶层框架中显示文档</td>
</tr>
<tr>
<td>“_blank”</td>
<td>在新的未命名顶层窗口中显示文档</td>
</tr>
<tr>
<td>其他字符串</td>
<td>在指定框架中显示。如果不存在指定名字的框架，则打开一个新窗口， 并指定为这个窗口的名字</td>
</tr>
</tbody></table>
<h5 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h5><p>受限的执行环境通常称为“ 沙箱”。沙箱中的程序有以下限制：</p>
<ul>
<li>它们绝对不能运行任何本地可执行程序。</li>
<li>它们不能读写本地计算机的文件系统。</li>
<li>它们不能査找有关本地计算机的信息， 不过所用的 Java 版本和一些无害的操作系统细节除外。</li>
<li>远程加载的程序需要用户同意与下载这个程序的服务器以外的主机通信；这个服务器称为源主机（originating host) 。这个规则通常称为“ 远程代码只能与家人通话”。这个规则可以保护用户防止代码刺探内部网资源。</li>
<li>所有弹出窗口都带有一个警告消息。这个消息是一个安全特性， 确保用户不会把这个窗口误认为一个本地应用。</li>
</ul>
<p>如今，不论是否在沙箱中运行，通过 Java Plug-in执行的所有代码都必须有数字签名。</p>
<h5 id="签名代码"><a href="#签名代码" class="headerlink" title="签名代码"></a>签名代码</h5><p>applet 或 Java Web Start 应用的 JAR 文件必须有数字签名。签名的 JAR 文件带有一个证书，指示签名者的身份。加密技术可以确保这个证书不可伪造，而且能检测出对签名文件的任何篡改。</p>
<p>现在已经不再支持不安全的证书。必须从 Java Plug-in 支持的一个证书发行商得到一个证书， 用它对你的 JAR 文件签名。</p>
<h3 id="Java-Web-Start"><a href="#Java-Web-Start" class="headerlink" title="Java Web Start"></a>Java Web Start</h3><p>Java Web Start 是一项在 Internet 上发布应用程序的技术。包含下列主要特性：</p>
<ul>
<li>Java Web Start 应用程序一般通过浏览器发布。只要 Java Web Start 应用程序下载到本地就可以启动它，而不需要浏览器。</li>
<li>Java Web Start 应用程序并不在浏览器窗口内。它将显示在浏览器外的一个属于自己的框架中。</li>
<li>Java Web Start 应用程序不使用浏览器的 Java 实现。浏览器只是在加载 Java Web Start应用程序描述符时启动一个外部应用程序。</li>
<li>数字签名应用程序可以被赋予访问本地机器的任意权限。未签名的应用程序只能运行在“ 沙箱” 中。</li>
</ul>
<h5 id="发布-Java-Web-Start-应用"><a href="#发布-Java-Web-Start-应用" class="headerlink" title="发布 Java Web Start 应用"></a>发布 Java Web Start 应用</h5><p>要想准备一个通过 Java Web Start 发布的应用程序， 应该将其打包到一个或多个 JAR 文件中。然后创建一个 Java Network Launch Protocol ( JNLP ) 格式的描述符文件。将这些文件放置在 Web 服务器上，要确保 Web 服务器对扩展名为 .jnlp 的文件报告一个 application/x-java-jnlp-file 的MIME 类型（浏览器利用 MIME 类型确定启动哪一种辅助应用程序)，可以安装tomcat。</p>
<h5 id="JNLP-API"><a href="#JNLP-API" class="headerlink" title="JNLP API"></a>JNLP API</h5><p>JNLP API 允许未签名的应用程序在沙箱中运行，同时通过一种安全的途径访问本地资源。</p>
<p>API 提供了下面的服务：</p>
<ul>
<li>加载和保存文件</li>
<li>访问剪贴板</li>
<li>打印</li>
<li>下载文件</li>
<li>在默认的浏览器中显示一个文档</li>
<li>保存和获取持久性配置信息</li>
<li>确信只运行一个应用程序的实例</li>
</ul>
<p>要访问服务， 需要使用 ServiceManager：<br>FileSaveService service = (FileSaveService) ServiceManager.lookup(“javax. jnlp.FileSaveService”);<br>如果服务不可用， 调用将拋出 UnavailableServiceException。</p>
<p>如果想要编译使用了 JNLP API 的程序， 那就必须在类路径中包含 javaws.jar 文件。这个文件在 JDK 的 jre/lib 子目录下。</p>
<p>要保存文件，需要为文件对话框提供文件的初始路径名和文件扩展类型、要保存的数据和建议的文件名：<br>service.saveFileDialog(“.”, new String[] { “txt” }, data, “calc.txt”);<br>数据必须由 InputStream 传递。</p>
<p>要想从文件中读取数据， 需要使用 FileOpenService。 它的 openFileDialog 对话框接收应用程序提供的初始路径名和文件扩展名， 并返回一个 FileContents 对象。 然后调用 getlnputStream 和 getOuputStream 方法来读写文件数据。 如果用户没有选择文件，openFileDialog 方法将返回 null：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileOpenService service &#x3D; (FileOpenService) ServiceManager.lookup(&quot;javax.jnlp.FileOpenService&quot;);</span><br><span class="line">FileContents contents &#x3D; service.openFileDialog(&quot;.&quot;, new String[]&#123; &quot;txt&quot; &#125;);</span><br><span class="line">if (contents !&#x3D; null) &#123;</span><br><span class="line">	InputStream in &#x3D; contents.getInputStream();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要打开一个特定的文件， 需要使用 ExtendedService：<br>ExtendedService service = (ExtendedService) ServiceManager.lookup(“ javax.jnlp.ExtendedService”);<br>FileContents contents = service.openFile(new File(“c:\autoexec.bat”));<br>程序的用户必须同意文件访问。</p>
<p>要想在默认浏览器中显示一个文档， 就需要使用 BasicService 接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BasicService service &#x3D; (BasicService) ServiceManager.lookup(&quot; javax.jnlp.Basi cService&quot;);</span><br><span class="line">if (service.isWebBrowserSupported())</span><br><span class="line">	service.showDocument(url);</span><br><span class="line">else . . .</span><br></pre></td></tr></table></figure>
<p>PersistenceService 允许应用程序保存少量的配置信息， 并且应用程序下次运行时恢复。使用 URL 键 进行持久性存储。URL 并不需要指向一个真正的web 资源， 服务仅仅使用它们来构造一个方便的具有层次结构的命名机制。对于任何给定的 URL 键，应用程序可以存储任意的二进制数据（存储可能会限制数据块的大小)。因为应用程序是彼此分离的， 一个特定的应用程序只能使用从 codebase 开始的 URL 键值。应用程序可以调用 BasicService 类的 getCodeBase 方法查看它的 codebase。可以调用 PersistenceService 中的 create 方法建立一个新的键：<br>URL url = new URL(CodeBase, “key”);<br>service.create(url, value);<br>要想访问与某个特定键关联的信息， 需要调用 get 方法。 这个方法将返回一个 FileContents 对象， 通过这个对象可以对键数据进行读写：<br>FileContents contents = service.get(url);<br>InputStream in = contents.getlnputStream();<br>OutputStream out = contents.getOutputStream(true); // true = overwrite<br>无法轻而易举地知道这个键是已经存在还是需要创建。可以假定这个键已经存在， 并调用 get 方法。如果抛出 FileNotFoundException， 就说明需要创建。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub</title>
    <url>/2021/03/03/GitHub/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24=">Github Docs<i class="fa fa-external-link-alt"></i></span></p>
<img data-src="/2021/03/03/GitHub/github0.png" class="" title="GitHub">

<p>Workspace：工作区，Index / Stage：暂存区，Repository：仓库区（或本地仓库），Remote：远程仓库</p>
<a id="more"></a>

<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h5 id="安装，windows需要处理换行符"><a href="#安装，windows需要处理换行符" class="headerlink" title="安装，windows需要处理换行符"></a>安装，windows需要处理换行符</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure>
<h5 id="设置姓名和邮箱地址"><a href="#设置姓名和邮箱地址" class="headerlink" title="设置姓名和邮箱地址"></a>设置姓名和邮箱地址</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Firstname Lastname&quot;</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<h5 id="提高输出可读性"><a href="#提高输出可读性" class="headerlink" title="提高输出可读性"></a>提高输出可读性</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global color.ui auto</span><br></pre></td></tr></table></figure>
<h5 id="设置文件"><a href="#设置文件" class="headerlink" title="设置文件"></a>设置文件</h5><ul>
<li><p>显示当前的 Git 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list</span><br><span class="line">cat ~/.giconfig</span><br></pre></td></tr></table></figure></li>
<li><p>编辑Git配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config -e [--global]</span><br></pre></td></tr></table></figure>
<h5 id="设置SSH，添加认证密码"><a href="#设置SSH，添加认证密码" class="headerlink" title="设置SSH，添加认证密码"></a>设置SSH，添加认证密码</h5></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<h5 id="添加公开密钥"><a href="#添加公开密钥" class="headerlink" title="添加公开密钥"></a>添加公开密钥</h5><p>将下面的密钥添加到 GitHub 设置中的 SSH key 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<h5 id="查看是否认证和通信成功"><a href="#查看是否认证和通信成功" class="headerlink" title="查看是否认证和通信成功"></a>查看是否认证和通信成功</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<h5 id="获取远程仓库"><a href="#获取远程仓库" class="headerlink" title="获取远程仓库"></a>获取远程仓库</h5><p>clone 后默认在 master 分支下自动将 origin 设置为远程仓库标识符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone SSH</span><br></pre></td></tr></table></figure>
<h5 id="获取远程非master分支"><a href="#获取远程非master分支" class="headerlink" title="获取远程非master分支"></a>获取远程非master分支</h5><p><code>-b</code> 后是新建分支名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b branchName origin/branchName</span><br></pre></td></tr></table></figure>
<h5 id="获取最新的远程仓库分支"><a href="#获取最新的远程仓库分支" class="headerlink" title="获取最新的远程仓库分支"></a>获取最新的远程仓库分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin branchName		# 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">git fetch [remote]		# 下载远程仓库的所有变动</span><br></pre></td></tr></table></figure>

<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><h5 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h5><p>生成  <code>.git</code>  目录, 也就是当前目录的仓库，当前目录称为“附属于该仓库的工作树”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init [project-name]</span><br></pre></td></tr></table></figure>
<h5 id="查看仓库的状态"><a href="#查看仓库的状态" class="headerlink" title="查看仓库的状态"></a>查看仓库的状态</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status		# 显示有变更的文件</span><br></pre></td></tr></table></figure>
<h5 id="向暂存区添加文件"><a href="#向暂存区添加文件" class="headerlink" title="向暂存区添加文件"></a>向暂存区添加文件</h5><ul>
<li><p>添加指定文件到暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure></li>
<li><p>添加指定目录到暂存区，包括子目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure></li>
<li><p>添加当前目录的所有文件到暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li>
<li><p>删除工作区文件，并且将这次删除放入暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm [file1] [file2] ...</span><br></pre></td></tr></table></figure></li>
<li><p>改名文件，并且将这个改名放入暂存区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<p>原理（<code>git add</code> 为如下两步简写）：</p>
</li>
<li><p>为 example.txt 创建一个副本。<code>git hash-object</code> 命令把 example.txt 的当前内容压缩成二进制文件，称为一个 Git 对象，保存在 <code>.git/objects</code> 目录。并计算当前内容的哈希值，前 2 个字符作为目录名，后 38 个字符作为该对象的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git hash-object -w example.txt</span><br></pre></td></tr></table></figure>
<p>二进制对象里面会保存一些元数据，如果想看该文件原始的文本内容，需用<code>git cat-file</code>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br></pre></td></tr></table></figure></li>
<li><p>所有变动的文件，Git 都记录在”暂存区”，<code>git update-index</code> 命令用于在暂存区记录一个发生变动的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git update-index --add --cacheinfo 100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 example.txt</span><br></pre></td></tr></table></figure>
<p><code>git ls-files</code> 命令显示暂存区当前内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files --stage</span><br></pre></td></tr></table></figure>
<h5 id="查看更改前后的差别"><a href="#查看更改前后的差别" class="headerlink" title="查看更改前后的差别"></a>查看更改前后的差别</h5></li>
</ul>
<p>习惯：<code>git commit</code> 前先 <code>git diff HEAD</code></p>
<p><code>git diff</code> 默认查看工作树和暂存区的差别</p>
<p>HEAD查看工作树与最新提交的差别，HEAD 为指向当前分支中最新一次提交的指针，<code>HEAD^</code> 指向 <code>HEAD</code> 的前一个提交，<code>HEAD~6</code> 则是 <code>HEAD</code> 之前的第6个提交。每一个分支都是一个文本文件，保存在 <code>.git/refs/heads/</code> 目录中，文件的内容是最新提交的哈希值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff [HEAD]</span><br></pre></td></tr></table></figure>
<h5 id="将暂存区中文件保存到仓库历史记录中"><a href="#将暂存区中文件保存到仓库历史记录中" class="headerlink" title="将暂存区中文件保存到仓库历史记录中"></a>将暂存区中文件保存到仓库历史记录中</h5><p><code>-m</code> 用于记录一行信息，不加 <code>-m</code> 记录详细信息</p>
<ul>
<li><p>```shell<br>git commit -am “Message”    # 相当与 git add 与 git commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 提交暂存区的指定文件到仓库区</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;shell</span><br><span class="line">   git commit [file1] [file2] ... -m &quot;Message&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>提交工作区自上次commit之后的变化，直接到仓库区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure></li>
<li><p>提交时显示所有diff信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>原理（<code>git commit -m &quot;first commit&quot;</code> 为如下两步简写）：</p>
<ul>
<li><p><code>git write-tree</code> 命令保存当前的目录结构，生成一个 Git 对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git write-tree</span><br></pre></td></tr></table></figure></li>
<li><p><code>git commit-tree</code>  命令用目录结构 Git 对象生成一个 Git 对象，需添加提交说明，<code>-p</code> 参数用来指定父提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;first commit&quot; | git e5a60f66d9966270c835343d4facc1c4bf44ed7a -p c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</span><br></pre></td></tr></table></figure>
<h5 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h5></li>
</ul>
<p>产生一个新的提交对象，替换掉上一次提交产生的提交对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend -m &quot;Message&quot;</span><br></pre></td></tr></table></figure>
<p>重做上一次 commit，并包括指定文件的新变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<h5 id="压缩历史"><a href="#压缩历史" class="headerlink" title="压缩历史"></a>压缩历史</h5><p>用于拼错单词等简单的错误，选定当前分支中包含 HEAD（最新提交）在内的 number 个最新历史记录为对象并在编辑器中打开，pick 为合并对象，fixup 为被合并对象，最后 pick 提交信息会保留</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~[number] </span><br></pre></td></tr></table></figure>
<h5 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h5><ul>
<li><p><code>--pretty=short</code> 用于只显示第一行简述信息</p>
</li>
<li><p><code>FileName</code> 为文件名或目录名，只显示指定文件的日志</p>
</li>
<li><p><code>-p</code> 用于显示文件的改动</p>
</li>
<li><p><code>--stat</code> 显示 commit 历史，以及每次 commit 发生变更的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log [--pretty=short][FileName][-p][--stat]		# 显示当前分支的版本历史</span><br></pre></td></tr></table></figure></li>
<li><p>查看文件每次提交的diff</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log -p FileName</span><br></pre></td></tr></table></figure></li>
<li><p>搜索提交历史，根据关键词</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log -S [keyword]</span><br></pre></td></tr></table></figure></li>
<li><p>显示某个 commit 之后的所有变动，每个commit占据一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure></li>
<li><p>显示某个 commit 之后的所有变动，其”提交说明”必须符合搜索条件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure></li>
<li><p>显示某个文件的版本历史，包括文件改名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --follow [file]</span><br><span class="line">git whatchanged [file]</span><br></pre></td></tr></table></figure>
<p><code>git log</code> 的运行过程</p>
</li>
<li><p>查找 HEAD 指针对应的分支</p>
</li>
<li><p>找到分支的最新提交</p>
</li>
<li><p>找到父节点（前一个提交）</p>
</li>
<li><p>依此类推，显示当前分支的所有提交</p>
</li>
</ul>
<h5 id="查看当前仓库操作日志"><a href="#查看当前仓库操作日志" class="headerlink" title="查看当前仓库操作日志"></a>查看当前仓库操作日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h5 id="从暂存区撤销文件"><a href="#从暂存区撤销文件" class="headerlink" title="从暂存区撤销文件"></a>从暂存区撤销文件</h5><p>停止追踪指定文件，但该文件会保留在工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached [filename]</span><br></pre></td></tr></table></figure>
<h5 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h5><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure>
<p>想抵消多个提交，必须在命令行依次指定这些提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert [倒数第一个提交] [倒数第二个提交]</span><br></pre></td></tr></table></figure>
<h5 id="回溯历史版本"><a href="#回溯历史版本" class="headerlink" title="回溯历史版本"></a>回溯历史版本</h5><ul>
<li><p>重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset [file]</span><br></pre></td></tr></table></figure></li>
<li><p>重置暂存区与工作区，与上一次 commit 保持一致</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></li>
<li><p>让最新提交的指针回到以前某个时点，该时点之后的提交都从历史中消失</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset 目标时间点哈希值		# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span><br></pre></td></tr></table></figure></li>
<li><p>默认情况下，<code>git reset</code>不改变工作区的文件（但会改变暂存区），<code>--hard</code>参数可以让工作区里面的文件也回到以前的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 目标时间点哈希值		#  重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br></pre></td></tr></table></figure></li>
<li><p>重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --keep [commit]</span><br></pre></td></tr></table></figure>
<h5 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h5></li>
</ul>
<p><code>origin</code> 为远程仓库的标识符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin SSH		# 增加一个新的远程仓库，并命名</span><br><span class="line">git remote -v		# 显示所有远程仓库</span><br><span class="line">git remote show [remote]		# 显示某个远程仓库的信息</span><br></pre></td></tr></table></figure>
<h5 id="推送至远程仓库"><a href="#推送至远程仓库" class="headerlink" title="推送至远程仓库"></a>推送至远程仓库</h5><ul>
<li>推送的是当前分支 </li>
<li><code>-u</code> 在推送的同时将远程仓库的（origin仓库）的 branch 分支设为本地仓库当前分支的 upstream（上游）<br>运行 git pull 从远程仓库获取内容时，就可以省略参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push [-u origin branchName]		# 上传本地指定分支到远程仓库</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h5 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout branchName			# 切换分支，并更新工作区</span><br><span class="line">git checkout -					#切换至上一分支</span><br><span class="line">git checkout -b branchName		# 新建一个分支，并切换到该分支</span><br><span class="line">git branch [branch] [commit]		# 新建一个分支，指向指定commit</span><br><span class="line">git branch --track [branch] [remote-branch]		# 新建一个分支，与指定的远程分支建立追踪关系</span><br></pre></td></tr></table></figure>
<h5 id="以图表形式查看分支"><a href="#以图表形式查看分支" class="headerlink" title="以图表形式查看分支"></a>以图表形式查看分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure>
<h5 id="显示分支一览表"><a href="#显示分支一览表" class="headerlink" title="显示分支一览表"></a>显示分支一览表</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch		# 列出所有本地分支</span><br><span class="line">git branch -r		#  列出所有远程分支</span><br><span class="line">git branch -a				# 同时显示本地仓库和远程仓库的分支信息</span><br><span class="line">git branch branchName		# 用于创建分支</span><br></pre></td></tr></table></figure>
<h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><ul>
<li><code>--no-ff</code> 用于记录本次分支合并</li>
<li>消除冲突：打开冲突的文件，在编辑器中改为想要的样子</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge [--no-ff]  branchName		# 合并指定分支到当前分支</span><br><span class="line">git cherry-pick [commit]		# 选择一个 commit，合并进当前分支</span><br></pre></td></tr></table></figure>
<h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><ul>
<li><p>删除分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d [branch-name]</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h5 id="撤销工作区的文件修改"><a href="#撤销工作区的文件修改" class="headerlink" title="撤销工作区的文件修改"></a>撤销工作区的文件修改</h5></li>
<li><p>先找暂存区，如果该文件有暂存的版本，则恢复该版本，否则恢复上一次提交的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- [filename]</span><br></pre></td></tr></table></figure></li>
<li><p>恢复某个 commit 的指定文件到暂存区和工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout [commit] [file]</span><br></pre></td></tr></table></figure></li>
<li><p>恢复暂存区的所有文件到工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3></li>
<li><p>列出所有 tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个 tag 在当前commit</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag [tag]</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个tag在指定commit</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag [tag] [commit]</span><br></pre></td></tr></table></figure></li>
<li><p>删除本地 tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程 tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure></li>
<li><p>查看 tag 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show [tag]</span><br></pre></td></tr></table></figure></li>
<li><p>提交指定 tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push [remote] [tag]</span><br></pre></td></tr></table></figure></li>
<li><p>提交所有tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个分支，指向某个tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
<h3 id="Git-Ignore"><a href="#Git-Ignore" class="headerlink" title="Git Ignore"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9naXRpZ25vcmU=">Git Ignore<i class="fa fa-external-link-alt"></i></span></h3></li>
</ul>
<p>git 为我们提供了一个 <code>.gitignore</code> 文件，只要在这个文件中申明哪些文件你不希望添加到git中去，这样当你使用 <code>git add .</code> 的时候这些文件就会被自动忽略掉。</p>
<p>经实验，可以为每一个平行非包含的目录设定一个 .gitignore。</p>
<h3 id="GitHub-Hosts"><a href="#GitHub-Hosts" class="headerlink" title="GitHub Hosts"></a>GitHub Hosts</h3><p>查看打不开网页的域名，可在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaXBhZGRyZXNzLmNvbS8=">IPAddress<i class="fa fa-external-link-alt"></i></span> 中查找域名的 IP，添加至 hosts 文件中。</p>
<p>原则：</p>
<ul>
<li>网页打不开才加，DNS 比人工加要方便</li>
<li>加了打得开才留，保持 hosts 文件精简</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub520 Host Start</span><br><span class="line">185.199.108.154               github.githubassets.com</span><br><span class="line">140.82.112.22                 central.github.com</span><br><span class="line">185.199.108.133               desktop.githubusercontent.com</span><br><span class="line">185.199.108.153               assets-cdn.github.com</span><br><span class="line">185.199.108.133               camo.githubusercontent.com</span><br><span class="line">185.199.108.133               github.map.fastly.net</span><br><span class="line">199.232.69.194                github.global.ssl.fastly.net</span><br><span class="line">140.82.113.4                  gist.github.com</span><br><span class="line">185.199.108.153               github.io</span><br><span class="line">140.82.112.4                  github.com</span><br><span class="line">140.82.113.5                  api.github.com</span><br><span class="line">185.199.108.133               raw.githubusercontent.com</span><br><span class="line">185.199.108.133               user-images.githubusercontent.com</span><br><span class="line">185.199.108.133               favicons.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars5.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars4.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars3.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars2.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars1.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars0.githubusercontent.com</span><br><span class="line">185.199.108.133               avatars.githubusercontent.com</span><br><span class="line">140.82.112.10                 codeload.github.com</span><br><span class="line">52.216.236.131                github-cloud.s3.amazonaws.com</span><br><span class="line">52.217.37.76                  github-com.s3.amazonaws.com</span><br><span class="line">52.217.73.172                 github-production-release-asset-2e65be.s3.amazonaws.com</span><br><span class="line">52.217.42.180                 github-production-user-asset-6210df.s3.amazonaws.com</span><br><span class="line">52.216.25.84                  github-production-repository-file-5c1aeb.s3.amazonaws.com</span><br><span class="line">185.199.108.153               githubstatus.com</span><br><span class="line">64.71.168.201                 github.community</span><br><span class="line">185.199.108.133               media.githubusercontent.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Update time: 2021-04-17T12:06:21+08:00</span><br><span class="line"># Star me GitHub url: https:&#x2F;&#x2F;github.com&#x2F;521xueweihan&#x2F;GitHub520</span><br><span class="line"># GitHub520 Host End</span><br></pre></td></tr></table></figure>
<h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><h5 id="使用-GitHub"><a href="#使用-GitHub" class="headerlink" title="使用 GitHub"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvZ2l0aHViL3dvcmtpbmctd2l0aC1naXRodWItcGFnZXMvZ2V0dGluZy1zdGFydGVkLXdpdGgtZ2l0aHViLXBhZ2Vz">使用 GitHub<i class="fa fa-external-link-alt"></i></span></h5><p>GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。</p>
<p>有三种类型的 GitHub Pages 站点：项目、用户和组织。 项目站点连接到 GitHub 上托管的特定项目。 用户和组织站点连接到特定的 GitHub 帐户。</p>
<p>To publish a user site, you must create a repository owned by your user account that’s named <code>&lt;username.github.io&gt;</code>. Repositories using the legacy <code>&lt;username.github.com&gt;</code> naming scheme will still be published, but visitors will be redirected from <code>http(s)://&lt;username.github.com&gt;</code> to <code>http(s)://&lt;username.github.io</code>. If both a <code>&lt;username.github.com&gt;</code> and <code>&lt;username.github.io&gt;</code> repository exist, only the <code>&lt;username.github.io&gt;</code> repository will be published.</p>
<p>GitHub Pages sites are publicly available on the internet, even if the repository for the site is private or internal. 如果站点的仓库中有敏感数据，您可能想要在发布前删除它。</p>
<p>GitHub Pages 站点的发布来源是存储站点源文件的分支和文件夹。用户和组织站点的默认发布源是仓库默认分支的根目录。 项目站点的默认发布来源是 <code>gh-pages</code> 分支的根目录。</p>
<p>您可以创建自己的静态文件或使用静态站点生成器为您构建站点。默认情况下，GitHub Pages 将使用 Jekyll 来构建您的站点。</p>
<p>GitHub Pages 站点受到以下使用限制的约束：</p>
<ul>
<li>GitHub Pages source repositories have a recommended limit of 1GB. </li>
<li>发布的 GitHub Pages 站点不得超过 1 GB。</li>
<li>GitHub Pages sites have a soft bandwidth limit of 100GB per month.</li>
<li>GitHub Pages sites have a soft limit of 10 builds per hour.</li>
</ul>
<p>可在 Repository 的 Settings 中配置 GitHub Pages 站点的发布源或取消发布 GitHub Pages 站点。</p>
<h5 id="使用-jekyll"><a href="#使用-jekyll" class="headerlink" title="使用 jekyll"></a><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvZ2l0aHViL3dvcmtpbmctd2l0aC1naXRodWItcGFnZXMvc2V0dGluZy11cC1hLWdpdGh1Yi1wYWdlcy1zaXRlLXdpdGgtamVreWxs">使用 jekyll<i class="fa fa-external-link-alt"></i></span></h5><p>Github Docs 与 Jekyll 文档不一致，Windows 并未正式支持 Jekyll。</p>
<h5 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">使用 Hexo<i class="fa fa-external-link-alt"></i></span></h5><p>我选择 Hexo，一个是安装简单；一个是文档好。</p>
<h3 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h3><h5 id="GitHub-Actions-是什么"><a href="#GitHub-Actions-是什么" class="headerlink" title="GitHub Actions 是什么"></a>GitHub Actions 是什么</h5><p>持续集成由很多操作组成，比如自动抓取代码、运行测试、登录远程服务器、发布到第三方服务等。GitHub 把这些操作就称为 actions。</p>
<p>很多操作在不同项目里面是类似的，可以共享。GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p>
<p>可在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlP3R5cGU9YWN0aW9ucw==">官方市场<i class="fa fa-external-link-alt"></i></span>与 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NkcmFzL2F3ZXNvbWUtYWN0aW9ucw==">awesome actions<i class="fa fa-external-link-alt"></i></span> 找 action。</p>
<h5 id="workflow-文件"><a href="#workflow-文件" class="headerlink" title="workflow 文件"></a>workflow 文件</h5><p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的 <code>.github/workflows</code> 目录。</p>
<p>workflow 文件采用 YAML 格式，一个库可以有多个 workflow 文件。GitHub 发现 <code>.github/workflows</code> 目录里有 <code>.yml</code> 文件，就会自动运行该文件。</p>
<p>配置字段：</p>
<ul>
<li><p>name：工作流程的名称。如果省略 name，GitHub 将其设置为相对于仓库根目录的工作流程文件路径</p>
</li>
<li><p>on：必要，触发工作流程的 GitHub 事件的名称</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>on.&lt;push|pull_request&gt;.&lt;branches|tags&gt;：您可以将工作流配置为在特定分支或标记上运行</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span>    </span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;mona/octocat&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;releases/**&#x27;</span></span><br><span class="line">    <span class="attr">tags:</span>        </span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v1.*</span> </span><br></pre></td></tr></table></figure></li>
<li><p>jobs：工作流程运行包括一项或多项作业。每项作业必须关联一个 ID</p>
<ul>
<li><p>jobs.<job_id>.name：job_id 里面的 name 字段是任务的说明</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">my_first_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">first</span> <span class="string">job</span></span><br><span class="line">  <span class="attr">my_second_job:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">second</span> <span class="string">job</span></span><br></pre></td></tr></table></figure></li>
<li><p>jobs.<job_id>.needs：作业默认是并行运行。needs字段指定当前任务的运行顺序</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">job1:</span></span><br><span class="line">  <span class="attr">job2:</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">job1</span></span><br><span class="line">  <span class="attr">job3:</span></span><br><span class="line">    <span class="attr">needs:</span> [<span class="string">job1</span>, <span class="string">job2</span>]</span><br></pre></td></tr></table></figure>
<p>此例中作业执行顺序：job1、job2、job3</p>
</li>
<li><p>jobs.<job_id>.runs-on：必需，运行作业的机器类型</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>jobs.<job_id>.steps：作业包含一系列任务，称为 steps</p>
<ul>
<li><p>jobs.<job_id>.steps.name：步骤名称</p>
</li>
<li><p>jobs.<job_id>.steps.uses：引用的 Actions</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span>    </span><br><span class="line">  <span class="comment"># Reference a specific commit</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@74bc508</span></span><br><span class="line">  <span class="comment"># Reference a minor version of a release</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1.2</span></span><br><span class="line">  <span class="comment"># Reference a branch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@main</span></span><br></pre></td></tr></table></figure></li>
<li><p>jobs.<job_id>.steps.run：使用操作系统 shell 运行命令行程序</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">install</span> <span class="string">dependencies</span> <span class="string">and</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5></li>
</ul>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMDkvZ2V0dGluZy1zdGFydGVkLXdpdGgtZ2l0aHViLWFjdGlvbnMuaHRtbA==">GitHub Actions 入门教程<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvYWN0aW9ucw==">GitHub Actions<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="持续集成（Continuous-integration，简称CI）"><a href="#持续集成（Continuous-integration，简称CI）" class="headerlink" title="持续集成（Continuous integration，简称CI）"></a>持续集成（Continuous integration，简称CI）</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>持续集成指的是，频繁地（一天多次）将代码合并（集成）到主干源码仓库。在 CI 中可以通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><img data-src="/2021/03/03/GitHub/CI.png" class="" title="CI">

<ul>
<li>提交：开发者向代码仓库提交代码</li>
<li>测试（第一轮）：代码仓库对提交的代码跑自动化测试<ul>
<li>单元测试：针对函数或模块的测试</li>
<li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li>
<li>端对端测试：从用户界面直达数据库的全链路测试</li>
</ul>
</li>
<li>构建：将源码转换为可以运行的实际代码，会安装依赖，配置各种资源等。常用的构建工具如下<ul>
<li><span class="exturl" data-url="aHR0cDovL2plbmtpbnMtY2kub3JnLw==">Jenkins<i class="fa fa-external-link-alt"></i></span>：开源</li>
<li><span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==">Travis<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZXNoaXAuaW8v">Codeship<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3N0cmlkZXJjZC5jb20v">Strider<i class="fa fa-external-link-alt"></i></span>：开源</li>
</ul>
</li>
<li>测试（第二轮）：第二轮是全面测试</li>
<li>部署：直接部署</li>
<li>回滚：当前版本发生问题，回滚到上一个版本的构建结果</li>
</ul>
<h3 id="Commit-message"><a href="#Commit-message" class="headerlink" title="Commit message"></a>Commit message</h3><p>社区有多种 Commit Message Conventions。本文介绍 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xUXJERmNJaVBqU0xEbjNFTDE1SUp5Z05QaUhPUmdVMV9PT0FxV2ppRFU1WS9lZGl0I2hlYWRpbmc9aC5ncmVsamttbzE0eTA=">Angular 规范<i class="fa fa-external-link-alt"></i></span>。</p>
<h5 id="格式化的-Commit-message-好处"><a href="#格式化的-Commit-message-好处" class="headerlink" title="格式化的 Commit message 好处"></a>格式化的 Commit message 好处</h5><ul>
<li><p>提供更多的历史信息，方便浏览</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure></li>
<li><p>可以过滤某些 commit，便于查找信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log HEAD --grep feature</span><br></pre></td></tr></table></figure></li>
<li><p>可以直接从 commit 生成 Change Log</p>
</li>
</ul>
<h5 id="Commit-message-的格式"><a href="#Commit-message-的格式" class="headerlink" title="Commit message 的格式"></a>Commit message 的格式</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line">// 空一行</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">// 空一行</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Header 只有一行</p>
<ul>
<li>type 用于说明 commit 的类别<ul>
<li>feat：新功能</li>
<li>fix：修补bug</li>
<li>docs：文档</li>
<li>style： 格式</li>
<li>refactor：重构</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
<li>Revert：当前 commit 用于撤销以前的 commit</li>
</ul>
</li>
<li>scope 用于说明 commit 影响的范围</li>
<li>subject 是 commit 目的的简短描述<ul>
<li>以动词开头，使用第一人称现在时</li>
<li>第一个字母小写</li>
<li>结尾不加句号</li>
</ul>
</li>
</ul>
</li>
<li><p>Body 部分是对本次 commit 的详细描述</p>
</li>
<li><p>Footer</p>
<ul>
<li><p>不兼容变动：如果当前代码与上一个版本不兼容，则以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述、以及变动理由和迁移方法</p>
</li>
<li><p>关闭 Issue：如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure>
<h5 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h5></li>
</ul>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbW1pdGl6ZW4vY3otY2xp">Commitizen<i class="fa fa-external-link-alt"></i></span> 是一个撰写 Commit message 的工具</p>
<ul>
<li><p>Install the Commitizen cli tools</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install commitizen -g</span><br></pre></td></tr></table></figure></li>
<li><p>Initialize your project to use the cz-conventional-changelog adapter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commitizen init cz-conventional-changelog --save-dev --save-exact</span><br></pre></td></tr></table></figure></li>
<li><p>以后，凡是用到 <code>git commit</code> 命令，一律改为使用 <code>git cz</code>。</p>
</li>
</ul>
<h5 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h5><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDEvY29tbWl0X21lc3NhZ2VfY2hhbmdlX2xvZy5odG1s">Commit message 和 Change log 编写指南<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="YAML（YAML-Ain’t-a-Markup-Language）"><a href="#YAML（YAML-Ain’t-a-Markup-Language）" class="headerlink" title="YAML（YAML Ain’t a Markup Language）"></a>YAML（YAML Ain’t a Markup Language）</h3><p>YAML 是专门用来写配置文件的语言</p>
<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>规则：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
<li><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略</li>
<li>对象和数组可以结合使用，形成复合结构</li>
</ul>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>一组键值对</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure>
<p>行内表示法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hash:</span> &#123; <span class="attr">name:</span> <span class="string">Steve</span>, <span class="attr">foo:</span> <span class="string">bar</span> &#125; </span><br></pre></td></tr></table></figure>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>一组连词线开头的行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>行内表示法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animal:</span> [<span class="string">Cat</span>, <span class="string">Dog</span>]</span><br></pre></td></tr></table></figure>
<h5 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h5><ul>
<li><p>字符串：字符串默认不使用引号表示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">这是一行字符串</span></span><br></pre></td></tr></table></figure>
<p>包含空格或特殊字符，需要放在引号之中，单引号和双引号都可以使用，双引号不会对特殊字符转义</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">&#x27;内容： 字符串&#x27;</span></span><br></pre></td></tr></table></figure>
<p>单引号之中如果还有单引号，必须连续使用两个单引号转义</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">&#x27;labor&#x27;</span><span class="string">&#x27;s day&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">这是一段</span></span><br><span class="line">  <span class="string">多行</span></span><br><span class="line">  <span class="string">字符串</span></span><br></pre></td></tr></table></figure>
<p>多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">this:</span> <span class="string">|</span></span><br><span class="line">  <span class="string">Foo</span></span><br><span class="line">  <span class="string">Bar</span></span><br><span class="line"><span class="attr">that:</span> <span class="string">&gt;</span></span><br><span class="line">  <span class="string">Foo</span></span><br><span class="line">  <span class="string">Bar</span></span><br></pre></td></tr></table></figure>
<p><code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="string">|</span></span><br><span class="line">  <span class="string">Foo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">s2:</span> <span class="string">|+</span></span><br><span class="line">  <span class="string">Foo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">s3:</span> <span class="string">|-</span></span><br><span class="line">  <span class="string">Foo</span></span><br></pre></td></tr></table></figure>
<p>字符串之中可以插入 HTML 标记</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">message:</span> <span class="string">|</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&lt;p</span> <span class="string">style=&quot;color:</span> <span class="string">red&quot;&gt;</span></span><br><span class="line">    <span class="string">段落</span></span><br><span class="line">  <span class="string">&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h5></li>
</ul>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDcveWFtbC5odG1s">YAML 语言教程<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly95YW1sLm9yZy8=">The Official YAML Web Site<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="开源许可证"><a href="#开源许可证" class="headerlink" title="开源许可证"></a>开源许可证</h3><p>版权法默认禁止共享。</p>
<h5 id="宽松式许可证"><a href="#宽松式许可证" class="headerlink" title="宽松式许可证"></a>宽松式许可证</h5><p>特点：</p>
<ul>
<li>没有使用限制：用户可以使用代码，做任何想做的事情。</li>
<li>没有担保：不保证代码质量，用户自担风险。</li>
<li>披露要求</li>
</ul>
<p>常见许可证：以下在分发软件时，都必须保留原始的许可证声明。</p>
<ul>
<li>BSD（二条款版）</li>
<li>BSD（三条款版）：不得使用原始作者的名字为软件促销。</li>
<li>MIT</li>
<li>Apache 2：凡是修改过的文件，必须向用户说明该文件修改过。</li>
</ul>
<h5 id="Copyleft-许可证"><a href="#Copyleft-许可证" class="headerlink" title="Copyleft 许可证"></a>Copyleft 许可证</h5><p>Copyleft 的含义是不经许可，用户可以随意复制。核心是修改后的 Copyleft 代码不得闭源：</p>
<ul>
<li>如果分发二进制格式，必须提供源码</li>
<li>修改后的源码，必须与修改前保持许可证一致</li>
<li>不得在原始许可证以外，附加其他限制</li>
</ul>
<p>常见许可证：</p>
<ul>
<li>Affero GPL (AGPL)：云服务的代码也必须开源。</li>
<li>GPL：如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。</li>
<li>LGPL：如果项目采用动态链接调用该许可证的库，项目可以不用开源。</li>
<li>Mozilla（MPL）：只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</li>
</ul>
<h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><ul>
<li>分发（distribution）：除了 Affero GPL (AGPL) ，其他许可证都规定只有在”分发”时，才需要遵守许可证。换言之，如果不”分发”，就不需要遵守。</li>
<li>披露要求（notice requirement）：要求软件的分发者必须向用户披露，软件里面有开源代码。一般来说，你只要在软件里面提供完整的原始许可证文本，并且披露原始作者，就满足了”披露要求”。</li>
</ul>
<h3 id="SSH-原理与运用"><a href="#SSH-原理与运用" class="headerlink" title="SSH 原理与运用"></a>SSH 原理与运用</h3><h5 id="数字签名与数字证书"><a href="#数字签名与数字证书" class="headerlink" title="数字签名与数字证书"></a>数字签名与数字证书</h5><img data-src="/2021/03/03/GitHub/signature0.png" class="" title="signature">

<p>鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p>
<img data-src="/2021/03/03/GitHub/signature1.png" class="" title="signature">

<p>鲍勃把公钥送给他的朋友们——帕蒂、道格、苏珊——每人一把。</p>
<img data-src="/2021/03/03/GitHub/signature2.png" class="" title="signature">

<p>苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p>
<img data-src="/2021/03/03/GitHub/signature3.png" class="" title="signature">

<p>鲍勃收信后，用私钥解密，就看到了信件内容。只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p>
<img data-src="/2021/03/03/GitHub/signature4.png" class="" title="signature">

<p>鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p>
<img data-src="/2021/03/03/GitHub/signature5.png" class="" title="signature">

<p>然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。</p>
<img data-src="/2021/03/03/GitHub/signature6.png" class="" title="signature">

<p>鲍勃将这个签名，附在信件下面，一起发给苏珊。</p>
<img data-src="/2021/03/03/GitHub/signature7.png" class="" title="signature">

<p>苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p>
<img data-src="/2021/03/03/GitHub/signature8.png" class="" title="signature">

<p>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
<img data-src="/2021/03/03/GitHub/signature9.png" class="" title="signature">

<p>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p>
<img data-src="/2021/03/03/GitHub/signature10.png" class="" title="signature">

<p>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p>
<p>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p>
<img data-src="/2021/03/03/GitHub/signature12.png" class="" title="signature">

<p>苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</p>
<h5 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h5><ul>
<li><p>1995年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，用于计算机之间的加密登录。本文针对的实现是 <span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuc3NoLmNvbS8=">OpenSSH<i class="fa fa-external-link-alt"></i></span>。</p>
</li>
<li><p>基本用法：</p>
<ul>
<li><p>假定你要以用户名 user，登录远程主机 host</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@host</span><br></pre></td></tr></table></figure></li>
<li><p>如果本地用户名与远程用户名一致，登录时可以省略用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh host</span><br></pre></td></tr></table></figure></li>
<li><p>SSH 的默认端口是 22，使用 p 参数修这个端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -p 2222 user@host</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>中间人攻击（Man-in-the-middle attack）</p>
<ul>
<li><p>SSH 加密登录过程</p>
<ul>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送给远程主机。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ul>
</li>
</ul>
</li>
<li><p>中间人攻击：攻击者插在用户与远程主机之间，用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机。</p>
</li>
<li><p>口令登录：第一次登录远程主机时，会询问是否接受远程主机公钥（是否继续连接），并显示公钥指纹——公钥长度较长（这里采用RSA算法，长达 1024 位），很难比对，所以对其进行MD5计算，将它变成一个 128 位的指纹。用户通过比对远程网站上贴出的公钥指纹，决定是否接受这个远程主机的公钥。当远程主机的公钥被接受以后，它就会被保存在文件 <code>$HOME/.ssh/known_hosts</code> 之中。</p>
</li>
<li><p>公钥登录：省去口令登录每次都必须输入密码的步骤。用户将自己的公钥储存在远程主机上，登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来，远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<ul>
<li><pre><code class="shell">ssh-keygen
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    在 &#96;$HOME&#x2F;.ssh&#x2F;&#96; 目录下生成两个文件：公钥 &#96;id_rsa.pub&#96; 和私钥 &#96;id_rsa&#96;。</span><br><span class="line"></span><br><span class="line">##### 远程操作与端口转发</span><br><span class="line"></span><br><span class="line">- SSH 可以在用户和远程主机之间，建立命令和数据的传输通道</span><br><span class="line"></span><br><span class="line">- 绑定本地端口：让那些不加密的网络连接，全部改走 SSH 连接</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;shell</span><br><span class="line">  ssh -D 8080 user@host</span><br></pre></td></tr></table></figure>
建立一个 socket，去监听本地的 8080 端口。一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，发往远程主机。</code></pre>
</li>
</ul>
</li>
<li><p>本地端口转发：假定 host1 是本地主机，host2 是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台 host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过 host3，将 host1 连上 host2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -L 2121:host2:21 host3</span><br></pre></td></tr></table></figure>
<p>L 参数接受三个值——“本地端口:目标主机:目标主机端口”。SSH 绑定本地端口 2121，指定 host3 将所有的数据转发到目标主机 host2 的 21 端口。本地端口转发使得 host1 和 host3 之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH 隧道”。</p>
</li>
<li><p>远程端口转发：host1 与 host2 之间无法连通，必须借助 host3 转发，而 host3 是一台内网机器，它可以连接外网的 host1，但是反过来就不行。解决办法是从 host3 上建立与 host1 的 SSH 连接，然后在 host1 上使用这条连接。在 host3 执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -R 2121:host2:21 host1</span><br></pre></td></tr></table></figure>
<p>R 参数也是接受三个值——“远程主机端口:目标主机:目标主机端口”。它让 host1 监听它自己的 2121 端口，然后将所有数据经由 host3，转发到 host2 的 21 端口。</p>
</li>
</ul>
<h5 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h5><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTEvMDgvd2hhdF9pc19hX2RpZ2l0YWxfc2lnbmF0dXJlLmh0bWw=">数字签名是什么？<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTEvMTIvc3NoX3JlbW90ZV9sb2dpbi5odG1s">SSH原理与运用（一）：远程登录<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTEvMTIvc3NoX3BvcnRfZm9yd2FyZGluZy5odG1s">SSH原理与运用（二）：远程操作与端口转发<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><p>《GitHub入门与实践》</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMTIvZ2l0LXVuZG8uaHRtbA==">如何撤销 Git 操作？<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMTAvZ2l0LWludGVybmFscy5odG1s">Git 原理入门<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE1LzEyL2dpdC1jaGVhdC1zaGVldC5odG1s">常用 Git 命令清单<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2021/03/03/Linux/</url>
    <content><![CDATA[<p>Linux 使用笔记</p>
<a id="more"></a>

<h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p><strong>连接热点</strong></p>
<ul>
<li><p>打开WIFI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig interface up </span><br></pre></td></tr></table></figure></li>
<li><p>查看所有可用的无线网络信号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iw wlp2s0 scan | grep SSID</span><br></pre></td></tr></table></figure></li>
<li><p>连接无线网</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpa_supplicant -B -i wlp2s0 -c &lt;(wpa_passphrase &quot;SSID&quot; &quot;passwd&quot;) </span><br></pre></td></tr></table></figure></li>
<li><p>分配IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dhclient interface</span><br></pre></td></tr></table></figure></li>
<li><p>查看无线网卡地址信息，有ip地址表示网络连接成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig interface</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>PPPOE （ADSL）拨号上网</strong></p>
<ul>
<li><p>安装拨号软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install  rp-pppoe* ppp*</span><br></pre></td></tr></table></figure></li>
<li><p>设定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppoe-setup</span><br></pre></td></tr></table></figure></li>
<li><p>拨号上网</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppoe-stop</span><br><span class="line">pppoe-start</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>安装中文输入法</strong></p>
<ul>
<li><p>安装 fcitx </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install fcitx-im fcitx-configtool fcitx-googlepinyin</span><br></pre></td></tr></table></figure></li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nano ~&#x2F;.xprofile</span><br><span class="line">export GTK_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>fictx 没图标：重装fcitx，在fcitx配置里关掉Kimpanel</p>
</li>
</ul>
<p><strong>关闭触摸板</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install xorg-x11-apps</span><br><span class="line">synclient TouchpadOff&#x3D;1		# 关闭</span><br><span class="line">synclient TouchpadOff&#x3D;0		# 开启</span><br></pre></td></tr></table></figure>
<p><strong>关闭 SELinux</strong></p>
<ul>
<li><p>查看是否运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;sestatus -v</span><br></pre></td></tr></table></figure></li>
<li><p>关闭 SELinux </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line">SELINUX&#x3D;disabled</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>安装 Oracle JDK</strong></p>
<ul>
<li><p>解压缩到目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-7u60-linux-x64.gz -C dir</span><br></pre></td></tr></table></figure></li>
<li><p>修改环境变量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vim ~&#x2F;.bashrc</span><br><span class="line">set oracle jdk environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk1.7.0_60 		# 这里换成自己解压的jdk 目录</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre  </span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib  </span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>使环境变量生效</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>用 MTP 挂载手机</strong></p>
<ul>
<li><p>安装jmtpfs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install jmtpfs</span><br></pre></td></tr></table></figure></li>
<li><p>查看手机 “busnum”和“devnum”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmptfs -l</span><br></pre></td></tr></table></figure></li>
<li><p>建立挂载点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;media&#x2F;dir</span><br></pre></td></tr></table></figure></li>
<li><p>挂载手机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmtpfs -device&#x3D;busnum,devnum &#x2F;media&#x2F;dir&#x2F;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>dd 制作U盘启动盘</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd bs&#x3D;4M if&#x3D;fileName.iso of&#x3D;&#x2F;dev&#x2F;sdx status&#x3D;progress &amp;&amp; sync</span><br></pre></td></tr></table></figure>
<p>Windows 下用Rufus 且 dd 写入模式</p>
<p><strong>查找依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum whatprovide package</span><br><span class="line">dnf provides package</span><br></pre></td></tr></table></figure>
<p><strong>修改文件默认关联的应用程序</strong></p>
<ul>
<li>mime类型文件存在于以下的两个路径：<ul>
<li>/usr/share/mime</li>
<li>~/.local/share/mime</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;mime&#x2F;text&#x2F;makrdown.xml</span><br></pre></td></tr></table></figure>
<ul>
<li>应用程序的desktop文件，存在于以下的两个路径：<ul>
<li>/usr/share/applications</li>
<li>~/.local/share/applications</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">Name&#x3D;name		# 应用名称，即开始菜单中的名称</span><br><span class="line">Exec&#x3D;appPath		# 应用执行文件位置</span><br><span class="line">Icon&#x3D;default48.png		# 应用图标位置</span><br><span class="line">Terminal&#x3D;false		# 是否显示终端</span><br><span class="line">StartupNotify&#x3D;true</span><br><span class="line">Categories&#x3D;Office		# 所属分类</span><br><span class="line">MimeType&#x3D;text&#x2F;x-markdown		# MIME 类型</span><br></pre></td></tr></table></figure>
<ul>
<li>应用程序默认关联文件，存在于以下的两个路径：<ul>
<li>/usr/share/applications/mimeapps.list</li>
<li>~/.local/share/applications/mimeapps.list</li>
</ul>
</li>
</ul>
<p><strong>Firefox 安装 Adobe Flash</strong></p>
<p>Firefox 不要在网页下载，直接通过源下载。</p>
<p><strong>wine exe程序的卸载</strong></p>
<ol>
<li>wine 会在 /home 下的用户名目录生成三个隐藏的文件夹 .wine、.local、.config 等文件夹，快捷键 ctrl+H 可以显示出来;</li>
<li>进入 .wine 文件夹可以看到 drive_c 文件夹，这是wine自动生成的虚拟windows  C盘，里面有类似windows系统盘的目录结构，在里面找到需要卸载的软件文件夹删除即可；</li>
<li>找到 /home/用户名/.local/share/applications/wine/Programs，将软件对应的文件删除；</li>
<li>找到 /home/用户名/.config/menus/applications-merged，将软件对应的文件删除；</li>
<li>这时候已经删除完毕，但是可能还会看到桌面图标或软件列表，重启系统即可。</li>
</ol>
<p><strong>默认字体</strong></p>
<p>CentOS 默认字体目录 /lib/kbd/consolefonts </p>
<p>纯命令行是不能使用系统之外的字体的。</p>
<p><strong>CentOS Minimal + Xfce</strong></p>
<p>base 源与 epel 源，使用用阿里镜像: <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9taXJyb3Iv">https://developer.aliyun.com/mirror/<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>安装Xfce4，先安装 Xfce 可以保证不安装多余的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf group list</span><br><span class="line">dnf groupinstall Xfce</span><br></pre></td></tr></table></figure></li>
<li><p>安装 X Window system</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf groupinstall &quot;X Window system&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl isolate graphical.target</span><br></pre></td></tr></table></figure></li>
<li><p>设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl set-default multi-user.target		# 设置成命令模式</span><br><span class="line">systemctl set-default graphical.target		# 设置成图形模式</span><br></pre></td></tr></table></figure></li>
<li><p>安装中文字体和中文输入法楷体字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install cjkuni-ukai-fonts</span><br></pre></td></tr></table></figure></li>
<li><p>输入法需要安装如下包：</p>
<ul>
<li>ibus， 这个包里有ibus-daemon这个平台服务器程序和ibus这个配置助手。</li>
<li>ibus-libpinyin， 这个是ibus平台下具体的拼音输入法。</li>
<li>im-chooser,这个是输入法平台选择助手程序。</li>
<li>执行im-chooser，选择输入法平台和输入法。重新登录系统。</li>
</ul>
</li>
<li><p>xfce 主题</p>
<ul>
<li>网站：xfce-look.org</li>
<li>主题目录： /usr/share/themes 或 ~/.themes</li>
<li>图标鼠标目录： /usr/share/icons 或 ~/.icons</li>
<li>壁纸： /usr/share/background , /usr/share/wallpapers</li>
<li><span class="exturl" data-url="aHR0cDovL2xpLm51eC5yby8=">Plank<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<p><strong>DNF 与 YUM 区别</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>DNF（Dandified YUM）</th>
<th>YUM（Yellowdog Updater, Modified）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>DNF 使用 libsolv 来解析依赖关系，由 SUSE 开发和维护</td>
<td>YUM 使用公开的 API 来解析依赖关系</td>
</tr>
<tr>
<td>2</td>
<td>API 有完整的文档</td>
<td>API 没有完整的文档</td>
</tr>
<tr>
<td>3</td>
<td>由 C、C++、Python 编写的</td>
<td>只用 Python 编写</td>
</tr>
<tr>
<td>4</td>
<td>DNF 目前在 Fedora、RHEL 8、CentOS 8、OEL 8 和 Mageia 6/7 中使用</td>
<td>YUM 目前在 RHEL 6/7、CentOS 6/7、OEL 6/7 中使用</td>
</tr>
<tr>
<td>5</td>
<td>DNF 支持各种扩展</td>
<td>Yum 只支持基于 Python 的扩展</td>
</tr>
<tr>
<td>6</td>
<td>API 有良好的文档，因此很容易创建新的功能</td>
<td>因为 API 没有正确的文档化，所以创建新功能非常困难</td>
</tr>
<tr>
<td>7</td>
<td>DNF 在同步存储库的元数据时，使用的内存较少</td>
<td>在同步存储库的元数据时，YUM 使用了过多的内存</td>
</tr>
<tr>
<td>8</td>
<td>DNF 使用满足性算法来解决依赖关系解析（它是用字典的方法来存储和检索包和依赖信息）</td>
<td>由于使用公开 API 的原因，Yum 依赖性解析变得迟钝</td>
</tr>
<tr>
<td>9</td>
<td>从内存使用量和版本库元数据的依赖性解析来看，性能都不错</td>
<td>总的来说，在很多因素的影响下，表现不佳</td>
</tr>
<tr>
<td>10</td>
<td>DNF 更新：在 DNF 更新过程中，如果包中包含不相关的依赖，则不会更新</td>
<td>YUM 将在没有验证的情况下更新软件包</td>
</tr>
<tr>
<td>11</td>
<td>如果启用的存储库没有响应，DNF 将跳过它，并继续使用可用的存储库处理事务</td>
<td>如果有存储库不可用，YUM 会立即停止</td>
</tr>
<tr>
<td>12</td>
<td><code>dnf update</code> 和 <code>dnf upgrade</code> 是等价的</td>
<td>在 Yum 中则不同</td>
</tr>
<tr>
<td>13</td>
<td>安装包的依赖关系不更新</td>
<td>Yum 为这种行为提供了一个选项</td>
</tr>
<tr>
<td>14</td>
<td>清理删除的包：当删除一个包时，DNF 会自动删除任何没有被用户明确安装的依赖包</td>
<td>Yum 不会这样做</td>
</tr>
<tr>
<td>15</td>
<td>存储库缓存更新计划：默认情况下，系统启动后 10 分钟后，DNF 每小时会对配置的存储库检查一次更新。这个动作由系统定时器单元 <code>dnf-makecache.timer</code> 控制</td>
<td>Yum 也会这样做</td>
</tr>
<tr>
<td>16</td>
<td>内核包不受 DNF 保护。不像 Yum，你可以删除所有的内核包，包括运行中的内核包</td>
<td>Yum 不允许你删除运行中的内核</td>
</tr>
<tr>
<td>17</td>
<td>libsolv：用于解包和读取资源库。hawkey: 为 libsolv 提供简化的 C 和 Python API 库。librepo: 提供 C 和 Python（类似 libcURL）API 的库，用于下载 Linux 存储库元数据和软件包。libcomps: 是 yum.comps 库的替代品。它是用纯 C 语言编写的库，有 Python 2 和 Python 3 的绑定。</td>
<td>Yum 不使用单独的库来执行这些功能</td>
</tr>
<tr>
<td>18</td>
<td>DNF 包含 29000 行代码</td>
<td>Yum 包含 56000 行代码</td>
</tr>
<tr>
<td>19</td>
<td>DNF 由 Ales Kozumplik 开发</td>
<td>YUM 由 Zdenek Pavlas、Jan Silhan 和团队成员开发</td>
</tr>
</tbody></table>
<p><strong>DNF 命令</strong></p>
<ul>
<li><p>查看 DNF 包管理器版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf –version</span><br></pre></td></tr></table></figure></li>
<li><p>查看系统中可用的 DNF 软件库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf repolist</span><br></pre></td></tr></table></figure></li>
<li><p>查看系统中可用和不可用的所有的 DNF 软件库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf repolist all</span><br></pre></td></tr></table></figure></li>
<li><p>列出所有 RPM 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf list</span><br></pre></td></tr></table></figure></li>
<li><p>列出所有安装了的 RPM 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf list installed</span><br></pre></td></tr></table></figure></li>
<li><p>列出所有可供安装的 RPM 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf list available</span><br></pre></td></tr></table></figure></li>
<li><p>搜索软件库中的 RPM 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf search nano</span><br></pre></td></tr></table></figure></li>
<li><p>查找某一文件的提供者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf provides &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>
<li><p>查看软件包详情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf info nano</span><br></pre></td></tr></table></figure></li>
<li><p>安装软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install nano</span><br></pre></td></tr></table></figure></li>
<li><p>升级软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf update systemd</span><br></pre></td></tr></table></figure></li>
<li><p>检查系统软件包的更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf check-update</span><br></pre></td></tr></table></figure></li>
<li><p>升级所有系统软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf update 或  dnf upgrade</span><br></pre></td></tr></table></figure></li>
<li><p>删除软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf remove nano 或  dnf erase nano</span><br></pre></td></tr></table></figure></li>
<li><p>删除无用孤立的软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf autoremove</span><br></pre></td></tr></table></figure></li>
<li><p>删除缓存的无用软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf clean all</span><br></pre></td></tr></table></figure></li>
<li><p>获取有关某条命令的使用帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf help clean</span><br></pre></td></tr></table></figure></li>
<li><p>查看所有的 DNF 命令及其用途</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf help</span><br></pre></td></tr></table></figure></li>
<li><p>查看 DNF 命令的执行历史</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf history</span><br></pre></td></tr></table></figure></li>
<li><p>查看所有的软件包组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf grouplist</span><br></pre></td></tr></table></figure></li>
<li><p>安装一个软件包组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf groupinstall ‘Educational Software’</span><br></pre></td></tr></table></figure></li>
<li><p>升级一个软件包组中的软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf groupupdate ‘Educational Software’</span><br></pre></td></tr></table></figure></li>
<li><p>删除一个软件包组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf groupremove ‘Educational Software’</span><br></pre></td></tr></table></figure></li>
<li><p>从特定的软件包库安装特定的软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf –enablerepo&#x3D;epel install phpmyadmin</span><br></pre></td></tr></table></figure></li>
<li><p>更新软件包到最新的稳定发行版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf distro-sync</span><br></pre></td></tr></table></figure></li>
<li><p>重新安装特定软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf reinstall nano</span><br></pre></td></tr></table></figure></li>
<li><p>回滚某个特定软件的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf downgrade acpid</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3></li>
</ul>
<p>(友邦拓)</p>
<p><strong>GNOME 使用</strong></p>
<ul>
<li><p>Ubuntu 自动下载并安装对你的系统至关重要的安全更新。而这个自动更新经常导致你“无法锁定管理目录”错误(<span class="exturl" data-url="aHR0cHM6Ly9pdHNmb3NzLmNvbS9jb3VsZC1ub3QtZ2V0LWxvY2stZXJyb3IvKSVFMyU4MCU4MiVFNSU5QiVBMCVFNiVBRCVBNCVFOSU4MCU4OSVFNiU4QiVBOQ==">https://itsfoss.com/could-not-get-lock-error/)。因此选择<i class="fa fa-external-link-alt"></i></span> Display immediately。同时把其他 Updates 都改为 Every two weeks，免得烦。</p>
</li>
<li><p>Gnome 3 自带自动切换壁纸的功能，选择有时间小图标的壁纸。</p>
</li>
<li><p>GNOME 桌面拥有强大的搜索功能，按 <code>Super</code> 键并搜索一些东西，可以进入“设置”中来控制可以搜索的内容和顺序。</p>
</li>
<li><p>GNOME 桌面有称为“扩展”的小插件或附加组件，学会使用 GNOME 扩展来扩展系统的可用性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install gnome-tweaks		# GNOME 设置工具</span><br></pre></td></tr></table></figure>
<p>同时会安装新的 GNOME Shell extensions，可以禁用桌面图标、Ubuntu Dock。可从浏览器安装 <span class="exturl" data-url="aHR0cHM6Ly9leHRlbnNpb25zLmdub21lLm9yZy8=">GNOME Shell extensions<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li>OpenWeather<ul>
<li>Location</li>
<li>Units：中国使用公制单位</li>
<li>Layout: Right</li>
</ul>
</li>
</ul>
</li>
<li><p>Do Not Disturb 使通知只在消息栏中，不会在桌面上弹出。</p>
</li>
<li><p>清理系统</p>
<ul>
<li><p>apt autoremove，删除不再需要的包</p>
</li>
<li><p>APT cache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh &#x2F;var&#x2F;cache&#x2F;apt		# see the size of this cache</span><br><span class="line">apt-get autoclean		# remove only the outdated packages</span><br><span class="line">apt-get clean		# delete apt cache in its entirety </span><br></pre></td></tr></table></figure>
<p>  apt-get 和软件中心下载的软件包一般放在 <code>/var/cache/apt/archives/</code> 目录，一般都安装在 <code>/usr/</code></p>
</li>
<li><p>journal logs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">journalctl --disk-usage		# check the log size</span><br><span class="line">journalctl --vacuum-time&#x3D;3d		# clear the logs that are older than a certain days</span><br></pre></td></tr></table></figure></li>
<li><p>thumbnail cache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh ~&#x2F;.cache&#x2F;thumbnails		# check the size of thumbnail cache </span><br><span class="line">rm -rf ~&#x2F;.cache&#x2F;thumbnails&#x2F;*</span><br></pre></td></tr></table></figure></li>
<li><p>Find and remove duplicate files：You can use a GUI tool like <span class="exturl" data-url="aHR0cHM6Ly93d3cucGl4ZWxiZWF0Lm9yZy9mc2xpbnQv">FSlint<i class="fa fa-external-link-alt"></i></span> or a command line tool like <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkcmlhbmxvcGV6cm9jaGUvZmR1cGVz">FDUPES<i class="fa fa-external-link-alt"></i></span> for this task</p>
</li>
<li><p>Remove old Linux kernels</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg --list &#39;linux-image*&#39;		# List all installed Linux kernels </span><br><span class="line">apt-get remove linux-image-VERSION</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>快捷键</p>
<ul>
<li><code>Super</code> + <code>m</code>： 显示消息托盘</li>
<li><code>Super</code> + <code>a</code>：显示应用程序菜单</li>
<li><code>Alt</code> + <code>F2</code>：输入命令以快速启动应用</li>
<li><code>Alt</code> + <code>F2</code>，然后输入 <code>r</code> 或 <code>restart</code>，再 <code>Enter</code>：重启 GNOME shell。</li>
</ul>
</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzgxNTczNDg=">安装完 Ubuntu 20.04 后要做的 16 件事<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Ubuntu Software &amp; Update 卡在 cache refresh</strong></p>
<p>通过 <code>apt update</code> 可以看见是 Connecting to security.ubuntu.com Failed，解决办法是更改 /etc/hosts 文件添加其 IP，可通过 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWFzeWNvdW50ZXIuY29tLw==">EASYCOUNTER<i class="fa fa-external-link-alt"></i></span> 查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># security.ubuntu.com DNS Records</span><br><span class="line">91.189.88.142 security.ubuntu.com</span><br><span class="line">91.189.88.152 security.ubuntu.com</span><br><span class="line">91.189.91.38 security.ubuntu.com</span><br><span class="line">91.189.91.39 security.ubuntu.com</span><br></pre></td></tr></table></figure>
<p><strong>ubuntu下如何获取源码包和源码</strong></p>
<ul>
<li><p>在 Software &amp; Updates 中选中 Source code，不要 Reload，因为很慢，在命令行中 update。或者在软件源配置文件 /etc/apt/sources.list 中添加 deb-src 项。</p>
</li>
<li><p>获取 xxx 源码包的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-cache showsrc xxx</span><br></pre></td></tr></table></figure></li>
<li><p>获取源码包，并将源码包解压到同名目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get source  xxx </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Ubuntu 自动切换壁纸</strong></p>
<ul>
<li>安装 Shotwell</li>
<li>在侧边栏 Photos 中 Ctrl + A，在菜单栏 File 中选择 Set as Desktop SlideShow…</li>
<li>这会把图片复制到 .local/share/shotwell/wallpaper，并在该目录生成 wallpaper.xml，wallpaper.xml 定义自动切换壁纸动画。</li>
<li>替代软件 Variety 等</li>
</ul>
<p><strong>Ubuntu 桌面卡死</strong></p>
<ul>
<li><p>选择其他 tty：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkill Xorg </span><br></pre></td></tr></table></figure>
<p>pkill 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。kill 命令杀死指定进程 PID，需要配合 ps 使用。</p>
</li>
<li><p>安全重启：同时按住 Ctrl 和 Alt 键，按住不要放，按一下 SysRq 键（有的键盘是PrtSc），按一下 R 键，按一下 E 键，依次按下 I , S , U , B 键。</p>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvbmdHdTE5OTYvYXJ0aWNsZS9kZXRhaWxzLzg3NzEyNTQ2">参考<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>snap “canonical-livepatch” has “install-snap” change in progress</strong></p>
<p>Snap 包是 Ubuntu 16.04 LTS 发布时引入的新应用格式包。目前已流行在很多 Linux 发行版上。</p>
<p>当你在安装完 Snap 后，你会发现在在根目录下会出现如 /dev/loop0 的挂载点，这些挂载点正是 Snap 软件包的目录。</p>
<ul>
<li><p>原因是软件之前安装了一次，只是安装失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snap changes</span><br><span class="line">snap abort 5		# 5 为安装失败软件的 ID</span><br></pre></td></tr></table></figure></li>
<li><p>现在重新安装</p>
</li>
</ul>
<p>一些软件最好在官网下载或在 Snap 中下载，官方 Repository 可能并不新，比如 VLC。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NzAyODAvYXJ0aWNsZS9kZXRhaWxzLzgwMjEzODY2">参考<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Ubuntu 系统中使用 Firefox 播放 HTML5 视频</strong></p>
<p>安装媒体解码器来播放 MP3、MPEG4 和其他格式媒体文件。由于各个国家的版权问题， Ubuntu 在默认情况下不会安装它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install ubuntu-restricted-extras</span><br></pre></td></tr></table></figure>
<p><strong>apt 与 apt-get</strong></p>
<p>Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理包系统。在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。apt-get 便是其中一款广受欢迎的命令行工具，但是最常用的命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中，apt 命令的引入就是为了解决命令过于分散的问题。（简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合）</p>
<table>
<thead>
<tr>
<th align="center">apt 命令</th>
<th align="center">取代的命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt install</td>
<td align="center">apt-get install</td>
<td align="center">安装软件包</td>
</tr>
<tr>
<td align="center">apt remove</td>
<td align="center">apt-get remove</td>
<td align="center">移除软件包</td>
</tr>
<tr>
<td align="center">apt purge</td>
<td align="center">apt-get purge</td>
<td align="center">移除软件包及配置文件</td>
</tr>
<tr>
<td align="center">apt update</td>
<td align="center">apt-get update</td>
<td align="center">刷新存储库索引</td>
</tr>
<tr>
<td align="center">apt upgrade</td>
<td align="center">apt-get upgrade</td>
<td align="center">升级所有可升级的软件包</td>
</tr>
<tr>
<td align="center">apt autoremove</td>
<td align="center">apt-get autoremove</td>
<td align="center">自动删除不需要的包</td>
</tr>
<tr>
<td align="center">apt full-upgrade</td>
<td align="center">apt-get dist-upgrade</td>
<td align="center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td align="center">apt search</td>
<td align="center">apt-cache search</td>
<td align="center">搜索应用程序</td>
</tr>
<tr>
<td align="center">apt show</td>
<td align="center">apt-cache show</td>
<td align="center">显示装细节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">新的apt命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt list</td>
<td align="center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td align="center">apt edit-sources</td>
<td align="center">编辑源列表</td>
</tr>
</tbody></table>
<p><strong>Ubuntu Repositories(should enable)</strong></p>
<ul>
<li><p>Main - Canonical-supported free and open-source software.</p>
</li>
<li><p>Universe - Community-maintained free and open-source software.</p>
</li>
<li><p>Restricted - Proprietary drivers for devices.</p>
</li>
<li><p>Multiverse - Software restricted by copyright or legal issues. </p>
</li>
<li><p>Canonical Partner - The partner repositories offer access to proprietary and closed-source software</p>
<p>Repositories/Ubuntu( Repositories/Ubuntu)</p>
</li>
</ul>
<p><strong>Backup And Restore Linux</strong></p>
<ul>
<li>```<br>apt-get install timeshift<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Making a backup of your Linux system</span><br><span class="line"></span><br><span class="line">- Restoring your Linux system</span><br><span class="line"></span><br><span class="line">  - log onto to your OS, launch Timeshift and select a Restore Image and hit restore</span><br><span class="line">  - when you can’t log into your Linux system, boot into a live session(need a Live USB) and download and install Timeshift(yes, you can install applications in live sessions).After installation, launch the application and browse to your backup location and select restore (yes, you can access your hard drive using a live session).</span><br><span class="line"></span><br><span class="line">**Linux 添加 exFAT 支持**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
apt install exfat-fuse exfat-utils<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**制作 windows U盘启动盘**</span><br><span class="line"></span><br><span class="line">Ubuntu 下安装 WoeUSB</span><br><span class="line"></span><br><span class="line">**libguestfs**</span><br><span class="line"></span><br><span class="line">libguestfs 支持几乎所有类型的磁盘镜像。</span><br><span class="line"></span><br><span class="line">在基于 Debian 的系统上：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ apt-get install libguestfs-tools<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我们可以像下面这样挂载一个 qcow2 格式的磁盘镜像：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ guestmount -a /path/to/qcow2/image -m <device> /path/to/mount/point<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">要卸载它，则执行：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ guestunmount qcow2_mount_point<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### openSUSE</span><br><span class="line"></span><br><span class="line">（&#x2F;ˌoʊpənˈsuːzə&#x2F;）</span><br><span class="line"></span><br><span class="line">使用了 openSUSE 的 KDE 之后，真是惊喜连连，感觉比 gnome 要方便的多。系统主题，在 gnome 上，要切换主题，还是比较麻烦的；但是在 KDE 上，在系统设置里面可以直接下载主题，一键切换。桌面壁纸，在 gnome 上，我用的都是离线壁纸，通过 shotwell 轮播，而在 KDE 上，可以在 Desktop setting 里面使用每日一图，比如 bing，还有 Unsplash Wallpapers。gnome nautilus 没有创建文件的 menu item，每次都得打开 terminal touch 一下，而 kde dolphin 则不需要。还有很喜欢的 KDE connect。总之还有很多有待探索。</span><br><span class="line"></span><br><span class="line">**YaST 系统配置**</span><br><span class="line"></span><br><span class="line">YaST 是 *Yet another Setup Tool*（又一个配置工具）的缩写。YaST 是 openSUSE 和 SUSE Linux 企业版的安装和配置工具。YaST 控制中心是 YaST 配置模块的统一入口。 </span><br><span class="line"></span><br><span class="line">区别于 kde 桌面系统配置。</span><br><span class="line"></span><br><span class="line">在 YaST 加入新语言支持时，会自动下载对应的字体与输入法。</span><br><span class="line"></span><br><span class="line">**Zypper 包管理器**</span><br><span class="line"></span><br><span class="line">Zypper 是个命令行形式的软件包管理器，以 libzypp 为处理引擎，提供诸如供应源管理、依赖关系解决和软件包安装等功能。 </span><br><span class="line"></span><br><span class="line">可以直接使用 &#96;rpm&#96; 命令。</span><br><span class="line"></span><br><span class="line"> **装入 NTFS 分区**</span><br><span class="line"></span><br><span class="line">1. 安装 &#96;ntfs-3g&#96;。</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;bash</span><br><span class="line">   sudo zypper in ntfs-3g</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>创建一个要充当安装点的目录，如 <code>~/mounts/windows</code>。    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/mounts/windows</span><br></pre></td></tr></table></figure></li>
<li><p>确定所需的 Windows 分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure></li>
<li><p>以读写模式装入分区。使用相应的 Windows 分区替换占位符 <em>DEVICE</em>：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntfs-3g &#x2F;dev&#x2F;DEVICE MOUNT POINT</span><br></pre></td></tr></table></figure>
<p>要在只读模式下使用 Windows 分区，请追加 <code>-o ro</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntfs-3g /dev/DEVICE MOUNT POINT -o ro</span><br></pre></td></tr></table></figure>
<p><code>ntfs-3g</code> 命令使用当前用户 (UID) 和组 (GID) 装入给定设备。如果要为其他用户设置写权限，请使用命令 <code>id</code>     <code> USER</code> 获取 UID 和 GID 值的输出。设置方式：    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id username</span><br><span class="line">ntfs-3g /dev/DEVICE MOUNT POINT -o uid=1000,gid=100</span><br></pre></td></tr></table></figure></li>
<li><p>要卸载资源，请运行 <code>fusermount -u 安装点</code>。  </p>
</li>
</ol>
<p><strong>KDE</strong></p>
<p>KDE 是一个为桌面和便携式计算机创造自由和开源软件的国际技术团队。由 KDE 开发的 Plasma 是 openSUSE 的默认图形桌面环境。</p>
<p>KDE 上游有一份维护良好的 <span class="exturl" data-url="aHR0cHM6Ly91c2VyYmFzZS5rZGUub3JnLw==">UserBase Wiki<i class="fa fa-external-link-alt"></i></span>。大多数 KDE 应用程序的详细信息都可以在那里找到。</p>
<p>尽量使用自带软件，因为与系统完美整合。比如播放媒体用自带的 VLC，可以通过 kde connect 控制。</p>
<p><strong>KDE Connect</strong></p>
<p>KDE Connect 是一款能够方便手机与电脑进行连接的应用。</p>
<ul>
<li>文件互传</li>
<li>共享剪贴板</li>
<li>远程输入</li>
<li>响铃，即既可以用电脑来找手机，也可以用手机找电脑。</li>
<li>幻灯片遥控器</li>
<li>多媒体控制</li>
<li>执行命令</li>
<li>共享通知</li>
</ul>
<p>默认 kdeconnect 在防火墙那边是没放开的，要操作一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --permanent --add-service=kdeconnect-kde</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p><strong>openSUSE 镜像</strong></p>
<p>我们官方的态度是不鼓励直接使用镜像的。</p>
<p>因为比起「其它」发行版，我们 openSUSE 的技术力量比较强，开发了两个东西。</p>
<p>一个叫做 Metalink，意思是这个格式（BT、Megalink 磁力链一样的格式）可以自动从 BT/FTP/HTTP 同时下载。</p>
<p>另一个叫做 MirrorBrain，意思是我把所有的镜像地址隐藏起来，只暴露出一个中央服务器，所有人只需使用这个中央服务器（download.opensuse.org ），它会根据你的 IP 地理位置为你分配一个离你最近的镜像，但是在你那边显示的依旧是来自 download.opensuse.org。而如何分配是根据镜像管理员和中央服务器管理员当初的协定来确定的，比如镜像每月能够承受的流量、所愿意扮演的角色（是区域中心、地标式的镜像比如北交大、中科大，还是小镜像）等。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5zdXNlLm9yZy5jbi90L29wZW5zdXNlLzE3NTk=">openSUSE 国内镜像汇总<i class="fa fa-external-link-alt"></i></span></p>
<p><a href="https://cloud.tencent.com/developer/article/1688182"><strong>解决KDE下KDE Wallet重装系统后每次登陆需要输入密码</strong></a></p>
<p>在每次重装或者配置桌面后<code>kdewallet</code>总是在登陆系统之后提示输入密码，虽然在输入密码后能够继续正常使用，但是每次登陆系统都需要输入一次密码还是很烦人的。</p>
<p>出现的原因：</p>
<p>在重新配置桌面或者重装系统之后KDE Wallet所需要的一些必备需要依赖组件未能找到，所以导致不能正确运行KDE Wallet，所以只要安装其所需的组件即可。而其所需的但是未能自动安装的依赖组件正是 <code>pam_kwallet</code></p>
<p>解决方案 ：</p>
<p>安装缺失的组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zypper <span class="keyword">in</span> kwallet-pam</span><br></pre></td></tr></table></figure>
<p>为了保险起见，查看个人目录下是否存在<code>~/.kde4/share/apps/kwallet</code>文件夹，如果存在则将其删除或者重命名以避免出现冲突，并且还需要确定使用的钱包名为<code>kdewallet</code>并且密码为当前用户的密码。</p>
<p>如此便可完全正常使用<code>KDE Wallet</code></p>
<p>决方案参考<code>arch wiki</code>的<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwP3RpdGxlPUtERV9XYWxsZXRfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nykmb2xkaWQ9NTcwODcw">KDE Wallet<i class="fa fa-external-link-alt"></i></span>小节中。</p>
<p><a href="https://zh.opensuse.org/%E8%A7%A3%E7%A0%81%E5%99%A8#.E9.80.9A.E8.BF.87_Packman_.E5.AE.89.E8.A3.85.E8.A7.A3.E7.A0.81.E5.99.A8"><strong>通过 Packman 安装解码器</strong></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zypper ar -cfp 90 <span class="string">&#x27;https://mirrors.ustc.edu.cn/packman/suse/openSUSE_Leap_$releasever&#x27;</span> packman-essentials</span><br><span class="line"></span><br><span class="line">sudo zypper refresh</span><br><span class="line"></span><br><span class="line">sudo zypper dist-upgrade --from packman-essentials --allow-vendor-change</span><br><span class="line"></span><br><span class="line">sudo zypper install --from packman-essentials ffmpeg gstreamer-plugins-&#123;good,bad,ugly,libav&#125; libavcodec-full vlc-codecs</span><br></pre></td></tr></table></figure>
<p><strong>M17N 源</strong></p>
<p>即多语言支持源，<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLm9wZW5zdXNlLm9yZy9yZXBvc2l0b3JpZXMvTTE3Ti8lRTMlODAlODI=">http://download.opensuse.org/repositories/M17N/。<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jNjg4MTQyODIyZWQ=">为OpenSUSE安装搜狗输入法<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Libpinyin</strong></p>
<p>Fcitx 的 Libpinyin 可以直接在线导入<span class="exturl" data-url="aHR0cDovL3Bpbnlpbi5zb2dvdS5jb20vZGljdC8=">搜狗细胞词库<i class="fa fa-external-link-alt"></i></span>。完全不需要安装sougou输入法，或者使用默认准确度极其低的输入法了。</p>
<p>需要安装 fcitx-pinyin-tools/fcitx-table-tools 这两个包，以<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5zdXNlLm9yZy5jbi90L2xpYnBpbnlpbi8zODE0LzI=">添加处理词库的工具<i class="fa fa-external-link-alt"></i></span>。</p>
<p><a href="https://askubuntu.com/questions/1173618/how-to-make-kde-plasma-taskbar-panel-transparent"><strong>任务栏透明化</strong></a></p>
<p>Go to <em>System Settings | Window Management | Window Rules</em>. Press New… button. Give some description to the new rule, <code>Dock Transparency</code>, for example. Then select only <code>Dock (panel)</code> in “Window type” field.</p>
<p>之后在 Appearance &amp; Fixes 中调整 opacity。</p>
<p><a href="https://forum.suse.org.cn/t/topic/13464/46"><strong>禁用 Discover 与 自带的更新功能</strong></a></p>
<p>禁用桌面自带的更新功能，就是 KDE 任务栏上的那个小箭头，这个用的是 packagekit，和 zypper 有冲突，会导致 zypper 无法启动，用 discover 安装程序也有这个问题。</p>
<p>方案一：把 discover 和 packagekit 的所有相关的包都删掉就行了。</p>
<p>方案二：关闭自带的更新功能通知，不使用这些，只使用zypper和YaST</p>
<p>更新的话，最好用命令行。登录界面出现后按 ctrl+alt+f1，然后用 root 登录，运行 zypper up。</p>
<h3 id="IRC"><a href="#IRC" class="headerlink" title="IRC"></a>IRC</h3><ul>
<li><p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ irssi</span><br></pre></td></tr></table></figure></li>
<li><p>列出服务器列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;network list</span><br></pre></td></tr></table></figure></li>
<li><p>翻页记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgUP, pgDN</span><br></pre></td></tr></table></figure></li>
<li><p>添加服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;network add freenode</span><br></pre></td></tr></table></figure></li>
<li><p>添加服务器地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;server add -network freenode irc.freenode.net</span><br></pre></td></tr></table></figure></li>
<li><p>新建窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;window new</span><br></pre></td></tr></table></figure></li>
<li><p>隐藏窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;window hide</span><br></pre></td></tr></table></figure></li>
<li><p>关闭窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;window close</span><br></pre></td></tr></table></figure></li>
<li><p>关闭指定窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;window close number</span><br></pre></td></tr></table></figure></li>
<li><p>窗口列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;window list</span><br></pre></td></tr></table></figure></li>
<li><p>连接服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;connect freenode</span><br></pre></td></tr></table></figure></li>
<li><p>修改昵称，这个昵称就是用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;nick newname</span><br></pre></td></tr></table></figure></li>
<li><p>注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;msg NickServ register password e-mail</span><br></pre></td></tr></table></figure></li>
<li><p>登陆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;msg NickServ identify name password</span><br></pre></td></tr></table></figure></li>
<li><p>服务器信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;info</span><br></pre></td></tr></table></figure></li>
<li><p>查询服务器admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;admin</span><br></pre></td></tr></table></figure></li>
<li><p>服务器统计信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;lusers</span><br></pre></td></tr></table></figure></li>
<li><p>服务器今日统计信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;motd</span><br></pre></td></tr></table></figure></li>
<li><p>解析当前有几个服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;links</span><br></pre></td></tr></table></figure></li>
<li><p>频道列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;list</span><br></pre></td></tr></table></figure></li>
<li><p>列出当前服务器或指定频道人员名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;names centos-social</span><br></pre></td></tr></table></figure></li>
<li><p>加入频道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;join centos-social</span><br></pre></td></tr></table></figure></li>
<li><p>提示频道对话情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Act:</span><br></pre></td></tr></table></figure></li>
<li><p>切换到1-10编号的频道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt+1~0</span><br></pre></td></tr></table></figure></li>
<li><p>切换到11-20编号的频道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt+q~p</span><br></pre></td></tr></table></figure></li>
<li><p>切换上/下频道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+n&#x2F;p</span><br></pre></td></tr></table></figure></li>
<li><p>查看频道所有人</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;who</span><br></pre></td></tr></table></figure></li>
<li><p>看某人资料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;whois name</span><br></pre></td></tr></table></figure></li>
<li><p>查询是否在线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ison name</span><br></pre></td></tr></table></figure></li>
<li><p>向某人说话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;say name message</span><br></pre></td></tr></table></figure></li>
<li><p>发动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;me action</span><br></pre></td></tr></table></figure></li>
<li><p>查看name所说的话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;lastlog name</span><br></pre></td></tr></table></figure></li>
<li><p>忽略某人聊天内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ignore name</span><br></pre></td></tr></table></figure></li>
<li><p>向某人发注意消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;notice name message</span><br></pre></td></tr></table></figure></li>
<li><p>向某人发私信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;msg name message</span><br><span class="line">&#x2F;query name message</span><br></pre></td></tr></table></figure></li>
<li><p>暂时离开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;away reason</span><br></pre></td></tr></table></figure></li>
<li><p>解除离开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;away</span><br></pre></td></tr></table></figure></li>
<li><p>离开频道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;wc</span><br><span class="line">&#x2F;part centos-social message</span><br></pre></td></tr></table></figure></li>
<li><p>离开服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;disconnect freenode</span><br></pre></td></tr></table></figure></li>
<li><p>离开irssi</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;quit</span><br><span class="line">&#x2F;exit</span><br></pre></td></tr></table></figure></li>
<li><p>自动保存聊天内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;set autolog on</span><br></pre></td></tr></table></figure>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3></li>
</ul>
<p><a href="https://www.fossmint.com/best-programming-fonts/"><strong>The 10 Best Programming Fonts for Developers</strong></a></p>
<p><strong>Wayland</strong></p>
<p>X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架。X由X.Org Foundation维护，遵守MIT协议，当前参考实现为X.Org Server。在架构方面，X使用了C/S模型，客户端和服务器可以在同一个机器上，也可以在不同的机器上，X作为Server为应用程序这个Client提供显示和I/O服务。</p>
<img data-src="/2021/03/03/Linux/XServer.png" class="" title="XServer">

<p>Wayland是一个显示服务协议，服务端为Wayland Compositor，把X的X Server和Compositor合二为一，旨在替换X，作为类Unix操作系统上更现代、简介的窗口系统，遵守MIT协议，提供了Wayland Compositor的参考C语言实现Weston。</p>
<img data-src="/2021/03/03/Linux/Wayland.png" class="" title="Wayland">

<p>时至今日，原本在X Server中做的事很多已被移到kernel或者单独的库中，因此X Server就显得比较累赘了。Wayland在架构上去掉了这个中间层，将compositor作为display server，使client与compositor直接通信，从而在灵活性和性能等方面上能够比前辈更加出色。</p>
<p>查看是否使用 wayland</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$XDG_SESSION_TYPE</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title>03Java的基本程序设计结构</title>
    <url>/2021/04/26/03Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="一个简单的-Java-应用程序"><a href="#一个简单的-Java-应用程序" class="headerlink" title="一个简单的 Java 应用程序"></a>一个简单的 Java 应用程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		program statements;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 区分大小写。如果出现了大小写拼写错误，程序将无法运行。</p>
<p>关键字 public 称为访问修饰符（access modifier), 这些修饰符用于控制程序的其他部分对这段代码的访问级別。</p>
<p>关键字 class 表明 Java 程序中的全部内容都包含在类中。类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。</p>
<p>关键字 class 后面紧跟类名。类名必须以大写字母开头，后面可以跟字母和数字的任意组合，如果类名由多个单词组成，每个单词的第一个字母都应该大写。长度基本上没有限制。不能使用 Java 保留字作为类名。源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名。</p>
<p>运行已编译的程序时，Java 虚拟机将从指定类中的 main 方法开始执行。在 Java SE 1.4 及以后的版本中强制 main 方法是 public 的。每个 Java 应用程序都必须有一个 main 方法。</p>
<p>在 Java 中，用大括号划分程序的各个部分（通常称为块)。Java 中任何方法的代码都用 “{” 开始，用结 ”}“ 束。</p>
<p>在 Java 中，每条语句必须用分号结束。</p>
<p>Java 函数调用通用语法是 object.method(parameters); 对于一个方法， 即使没有参数也需要用空括号。</p>
<p>System.out的println()方法输出后换行，print()方法输出后不换行。</p>
<a id="more"></a>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Java 中的注释不会出现在可执行程序中。</p>
<p>在 Java 中，有 3 种标记注释的方式：</p>
<ol>
<li>使用 // ，其注释内容从 // 开始到本行结尾。</li>
<li>使用 /* 和*/， 将一段比较长的注释括起来，/* */ 注释不能嵌套。</li>
<li>使用 /** 和 */ ，可以用来自动地生成文档。</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 是 一种强类型语言。这就意味着必须为每一个变量声明一种类型。在 Java 中， 一共有 8 种基本类型（ primitive type )。</p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4 字节</td>
<td>-2 147 483 648 ~ 2 147 483 647</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-32 768 ~ 32 767</td>
</tr>
<tr>
<td>long</td>
<td>8 字节</td>
<td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807</td>
</tr>
<tr>
<td>byte</td>
<td>1 字节</td>
<td>-128 ~ 127</td>
</tr>
</tbody></table>
<p>长整型数值有一个后缀 L 或 l。 十六进制数值有一个前缀 0x 或 0X 。八进制有一个前缀 0 ,八进制表示法比较容易混淆， 所以最好不要使用八进制常数。从 Java 7 开始， 加上前缀 0b 或 0B 就可以写二进制数。从 Java 7 开始，还可以为数字字面量加下划线，如用 1_000_000表示一百万。这些下划线只是为了让人更易读。Java 编译器会去除这些下划线。</p>
<h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4 字节</td>
<td>大约 ± 3.402 823 47E+38F</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
<td>大约 ± 1.797 693 134 862 315 70E+308</td>
</tr>
</tbody></table>
<p>float 类型的数值有一个后缀 F 或 f 。没有后缀 F 的浮点数值默认为 double 类型。当然，也可以在浮点数值后面添加后缀 D 或 d。</p>
<p>用于表示溢出和出错情况的三个特殊的浮点数值：正无穷大、负无穷大、NaN (Not a Number）。常量 Double_POSITIVE_INFINITY、 Double.NEGATIVE_INFINITY 和 Double.NaN ( 以及相应的 Float 类型的常量） 分别表示这三个特殊的值。可以使用 Double.isNaN 方法检测一个特定值是否为Double.NaN。</p>
<p>浮点数值不适用于无法接受舍入误差的金融计算中。这种舍入误差的主要原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal 类。</p>
<h5 id="char-类型"><a href="#char-类型" class="headerlink" title="char 类型"></a>char 类型</h5><p>char 类型的字面量值要用单引号括起来。</p>
<p>转义序列都可以出现在加引号的字符字面量或字符串中。转义序列 \u 还可以出现在加引号的字符常量或字符串之外。Unicode 转义序列会在解析代码之前得到处理。</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>名称</th>
<th>Unicode 值</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格</td>
<td>\u0008</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
<td>\u0009</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\u000a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>\u000d</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
<td>\u0022</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
<td>\u0027</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠</td>
<td>\u005c</td>
</tr>
</tbody></table>
<h5 id="Unicode-和-char-类型"><a href="#Unicode-和-char-类型" class="headerlink" title="Unicode 和 char 类型"></a>Unicode 和 char 类型</h5><p>码点（ code point ) 是指与一个编码表中的某个字符对应的代码值。在 Unicode 标准中，码点采用十六进制书写，并加上前缀 U+。第一个代码级别称为基本的多语言级别（ basic multilingual plane ), 码点从 U+0000 到 U+FFFF, 其中包括经典的 Unicode 代码；其余的 16个级别码点从 U+10000 到 U+10FFFF , 其中包括一些辅助字符（supplementary character)。</p>
<p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元（ code unit )；而辅助字符采用一对连续的代码单元进行编码。</p>
<p>在 Java 中，char 类型描述了 UTF-16 编码中的一个代码单元。建议不要在程序中使用 char 类型，除非确实需要处理 UTF-16 代码单元。</p>
<h5 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h5><p>boolean 类型有两个值：false 和 true, 用来判定逻辑条件，整型值和布尔值之间不能进行相互转换。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 Java 中，每个变量都有一个类型（ type )。在声明变量时，变量的类型位于变量名之前。由于声明是一条完整的 Java语句，所以必须以分号结束。</p>
<p>变量名必须是一个以字母开头并由字母或数字构成的序列。与大多数程序设计语言相比，Java 中“ 字母” 和“ 数字” 的范围更大。字母包括 ’A’ ~ ’Z’、’a’ ~  ‘z’、’_’、’$’或在某种语言中表示字母的任何 Unicode 字符。如果想要知道哪些 Unicode 字符属于 Java 中的“ 字母”， 可以使用 Character 类的<br>isJavaldentifierStart 和 isJavaldentifierPart 方法来检查。尽管 $ 是一个合法的 Java 字符， 但不要在你自己的代码中使用这个字符。它只用在 Java 编译器或其他工具生成的名字中。变量名的长度基本上没有限制。不能使用 Java 保留字作为变量名。</p>
<p>可以在一行中声明多个变量：int i, j; 不过，不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。</p>
<p>许多程序员将变量名命名为类型名，还有一些程序员更加喜欢在变量名前加上前缀 “a”。</p>
<h5 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h5><p>声明一个变量之后，必须用赋值语句对变量进行显式初始化， 千万不要使用未初始化的变量。</p>
<p>要想对一个已经声明过的变量进行赋值， 就需要将变量名放在等号（= ) 左侧， 相应取值的 Java 表达式放在等号的右侧。也可以将变量的声明和初始化放在同一行中。</p>
<p>在 Java 中可以将声明放在代码中的任何地方。在 Java 中， 变量的声明尽可能地靠近变量第一次使用的地方， 这是一种良好的程序编写风格。</p>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>在 Java 中， 利用关键字 final 指示常量。关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。</p>
<p>在 Java 中，经常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字 static final 设置一个类常量，定义于 main 方法的外部。</p>
<p>如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>在 Java 中，使用算术运算符 +、-、 *、/ 表示加、减、 乘、除运算。整数的求余操作（有时称为取模） 用 ％ 表示。</p>
<p>可移植性是 Java 语言的设计目标之一 ， 无论在哪个虚拟机上运行， 同一运算应该得到同样的结果。对于浮点数的算术运算， 实现这样的可移植性是相当困难的。double 类型使用 64 位存储一个数值， 而有些处理器使用 80 位浮点寄存器，这些寄存器增加了中间过程的计算精度。例如， 以下运算：double w = x * y / z; 很多 Intel 处理器计算 x * y，并且将结果存储在 80 位的寄存器中， 再除以 z 并将结果截断为 64 位， 这样可以得到一个更加精确的计算结果，并且还能够避免产生指数溢出。但是， 这个结果可能与始终在 64 位机器上计算的结果不一样。</p>
<p>使用 strictfp 关键字标记的方法必须使用严格的浮点计算来生成可再生的结果。</p>
<h5 id="数学函数与常量"><a href="#数学函数与常量" class="headerlink" title="数学函数与常量"></a>数学函数与常量</h5><p>在 Math类中，包含了各种各样的数学函数。</p>
<p>平方根，使用 Math.sqrt() 方法。</p>
<p>幂运算，使用 Math.pow() 方法，pow 方法有两个 double 类型的参数， 其返回结果也为 double 类型。</p>
<p>floorMod 方法的目的是解决一个长期存在的有关整数余数的问题。 如果 n 为负，则 n 取余总为 -1。floorMod 方法使余数总 &gt;= 0，除非是负除数，floorMod 会得到负数结果。</p>
<p>常用的三角函数：Math.sin、Math.cos、Math.tan、Math.atan、Math.atan2。</p>
<p>指数函数以及它的反函数—自然对数以及以 10 为底的对数：Math.exp、Math.log、Math.log10。</p>
<p>用于表示 pi 和 e 常量的近似值：Math.PI、Math.E。</p>
<p>在 Math 类中， 为了达到最快的性能， 所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话， 那么就应该使用 StrictMath 类，它使用“ 自由发布的 Math 库”（fdlibm) 实现算法， 以确保在所有平台上得到相同的结果。</p>
<h5 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h5><p>数值类型之间的合法转换:</p>
<ol>
<li>表示无信息丢失的转换：<br>byte -&gt; short<br>short -&gt; int<br>char -&gt; int<br>int -&gt; long<br>int -&gt; double<br>float -&gt; double</li>
<li>可能有精度损失的转换：<br>int -&gt; float<br>long -&gt; float<br>long -&gt; double</li>
</ol>
<p>当使用两个数值进行二元操作时先要将两个操作数转换为同一种类型，然后再进行计算：</p>
<ol>
<li>如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 </li>
<li>否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。 </li>
<li>否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。</li>
<li>否则， 两个操作数都将被转换为 int 类型。</li>
</ol>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。</p>
<p>如果想对浮点数进行舍人运算， 以便得到最接近的整数那就需要使用 Math.round 方法，round 方法返回的结果为 long 类型。</p>
<h5 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h5><p>可以在赋值中使用二元运算符，这是一种很方便的简写形式。</p>
<p>如果运算符得到一个值， 其类型与左侧操作数的类型不同， 就会发生强制类型转换。</p>
<h5 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h5><p>n++ 将变量 n 的当前值加 1, n– 则将 n 的值减 1。由于这些运算符会改变变量的值，所以它们的操作数不能是数值。</p>
<p>前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。</p>
<p>建议不要在表达式中使用 ++, 因为这样的代码很容易让人闲惑，而且会带来烦人的 bug。</p>
<h5 id="关系和-boolean-运算符"><a href="#关系和-boolean-运算符" class="headerlink" title="关系和 boolean 运算符"></a>关系和 boolean 运算符</h5><p>要检测相等性，可以使用两个等号 ==。</p>
<p>以使用 != 检测不相等。</p>
<p>经常使用的 &lt; (小于、) &gt; (大于)、&lt;=(小于等于）和 &gt;= (大于等于）运算符。</p>
<p>使用 &amp;&amp; 表示逻辑“ 与” 运算符，使用 || 表示逻辑“ 或” 运算符，感叹号！就是逻辑非运算符。&amp;&amp; 和 || 运算符是按照“ 短路” 方式来求值的： 如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p>
<p>Java 支持三元操作符 ？：。如果条件为 true, 表达式 condition ? expression1 : expression2 就为第一个表达式的值，否则为第二个表达式的值。</p>
<h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><p>处理整型类型时，可以直接对组成整型数值的各个位完成操作。</p>
<p>位运算符包括：&amp; (“and”)| (“or”)  ^ (“xor”)  ~ (“not”)。</p>
<p>应用在布尔值上时， &amp; 和丨运算符也会得到一个布尔值，不过 &amp; 和丨运算符不采用“ 短路” 方式来求值。</p>
<p>还有 &gt;&gt; 和 &lt;&lt; 运算符将位模式左移或右移。&gt;&gt;&gt;  运算符会用 0 填充高位。</p>
<h5 id="括号与运算符级别"><a href="#括号与运算符级别" class="headerlink" title="括号与运算符级别"></a>括号与运算符级别</h5><p>如果不使用圆括号， 就按照给出的运算符优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（除了表中给出的右结合运算符外）。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>[]  .  () (方法调用)</td>
<td>从左向右</td>
</tr>
<tr>
<td>!  ~  ++  –  + ( 一元运算） - ( 一元运算）  () ( 强制类型转换）new</td>
<td>从右向左</td>
</tr>
<tr>
<td>* /  %</td>
<td>从左向右</td>
</tr>
<tr>
<td>+  -</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt;  &lt;=  &gt;  &gt;=  instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>==  !=</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>=  +=  -=  *=  /=  %=  &amp;=  ^=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举类型包括有限个命名的值。例如， enum Size { SMALL, MEDIUM, LARGE, EXTRA.LARCE };<br>现在，可以声明这种类型的变量：Size s = Size.MEDIUM;Size 类型的变量只能存储这个类型声明中给定的某个枚举值，或者 null 值，null 表示这个变量没有设置任何值。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Java 字符串就是 Unicode 字符序列。Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了<br>一个预定义类，叫做 String。每个用双引号括起来的字符串都是 String 类的一个实例。</p>
<h5 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h5><p>String 类的 substring 方法可以从一个较大的字符串提取出一个子串。substring 方法的第二个参数是不想复制的第一个位置。字符串 s.substring(a, b) 的长度为 b-a。</p>
<h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><p>Java语言允许使用 + 号连接（拼接）两个字符串。当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。</p>
<p>如果需要把多个字符串放在一起， 用一个定界符分隔，可以使用静态 join 方法。</p>
<h5 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h5><p>String 类没有提供用于修改字符串的方法。由于不能修改 Java 字符串中的字符， 所以在 Java 文档中将 String 类对象称为不可变字符串。</p>
<p>不可变字符串有一个优点：编译器可以让字符串共享。</p>
<h5 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h5><p>可以使用 equals 方法检测两个字符串是否相等。</p>
<p>要想检测两个字符串是否相等，而不区分大小写， 可以使用 equalsIgnoreCase 方法。</p>
<p>一定不要使用 == 运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。当然， 如果字符串放置在同一个位置上， 它们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。如果虚拟机始终将相同的字符串共享， 就可以使用 == 运算符检测是否相等。但实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。</p>
<h5 id="空串与-Null-串"><a href="#空串与-Null-串" class="headerlink" title="空串与 Null 串"></a>空串与 Null 串</h5><p>空串 “” 是长度为 0 的字符串。空串是一个 Java 对象， 有自己的串长度（ 0 ) 和内容（空）。不过， String 变量还可以存放一个特殊的值， 名为 null, 这表示目前没有任何对象与该变量关联。要检查一个字符串是否为 null, 要使用以下条件：if (str == null) 。</p>
<h5 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h5><p>char 数据类型是一个用 UTF-16 编码表示 Unicode 码点的代码单元。大多数的常用 Unicode 字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。</p>
<p>length 方法将返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。</p>
<p>要想得到实际的长度，即码点数量，可以调用 codePointCount 方法。</p>
<p>调用 s.charAt(n) 将返回位置 n 的代码单元，n 介于 0 ~ s.length()-l 之间。</p>
<p>要想得到第 i 个码点，应该使用下列语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = s.offsetByCodePoints(<span class="number">0</span>, i);</span><br><span class="line"><span class="keyword">int</span> cp = s.codePointAt(index);</span><br></pre></td></tr></table></figure>
<p>Java 对字符串中的代码单元和码点从 0 开始计数。</p>
<p>如果想要遍历一个字符串，并且依次査看每一个码点， 可以使用下列语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cp = s.codePointAt(i);</span><br><span class="line"><span class="keyword">if</span> (Character.isSupplementaryCodePoint(cp)) i += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> i++;</span><br></pre></td></tr></table></figure>
<p>可以使用下列语句实现回退操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i--；</span><br><span class="line"><span class="keyword">if</span> (CharacterssSurrogate(s.charAt(i))) i--;</span><br><span class="line"><span class="keyword">int</span> cp = s.codePointAt(i);</span><br></pre></td></tr></table></figure>
<p>更容易的办法是使用 codePoints 方法， 它会生成一个 int 值的“ 流”，每个 int 值对应一个码点。可以将它转换为一个数组再完成遍历：<br>int[] codePoints = str.codePoints().toArray()；<br>反之，要把一个码点数组转换为一个字符串， 可以使用构造函数：<br>String str = new String(codePoints, 0, codePoints.length);</p>
<h5 id="String-API"><a href="#String-API" class="headerlink" title="String API"></a>String API</h5><p>Java 中的 String类包含了 50 多个方法。令人惊讶的是绝大多数都很有用， 可以设想使用的频繁非常高。</p>
<h5 id="阅读联机-API-文档"><a href="#阅读联机-API-文档" class="headerlink" title="阅读联机 API 文档"></a>阅读联机 API 文档</h5><p>学会使用在线 API 文档十分重要，从中可以查阅到标准类库中的所有类和方法。API文档是 JDK 的一部分， 它是HTML 格式的。</p>
<h5 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h5><p>如果需要用许多小段的字符串构建一个字符串， 那么应该按照下列步骤进行:</p>
<ol>
<li>构建一个空的字符串构建器：<br>StringBuilder builder = new StringBuilder();</li>
<li>当每次需要添加一部分内容时， 就调用 append 方法:<br>bui1der.append(str);</li>
<li>在需要构建字符串时就凋用 toString 方法， 将可以得到一个 String 对象， 其中包含了构建器中的字符序列:<br>String completedString = builder.toString();</li>
</ol>
<p>在 JDK5.0 中引入 StringBuilder 类。 这个类的前身是 StringBuffer, 其效率稍有些低， 但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑 ， 则应该用 StringBuilder 替代它。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h5 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h5><p>要想通过控制台进行输人，首先需要构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联：<br>Scanner in = new Scanner(System.in);</p>
<p>nextLine 方法将输入一行。要想读取一个单词（以空白符作为分隔符) ，就调用next方法。要想读取一个整数， 就调用 nextlnt 方法。要想读取下一个浮点数， 就调用 nextDouble 方法。</p>
<p>Scanner 类定义在java.util 包中。 当使用的类不是定义在基本java.lang 包中时，一定要使用<br>import 指示字将相应的包加载进来。</p>
<p>因为输入是可见的， 所以 Scanner 类不适用于从控制台读取密码。Java SE 6 特别引入了 Console 类实现这个目的。要想读取一个密码， 可以采用下列代码：<br>Console cons = System.console();<br>String username = cons.readLine(“User name: “)；<br>char[] passwd = cons.readPassword(“Password:”);<br>为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素。</p>
<h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><p>Java SE 5.0 沿用了 C 语言库函数中的 printf方法。</p>
<p>每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型。</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>十进制整数</td>
<td>159</td>
</tr>
<tr>
<td>x</td>
<td>十六进制整数</td>
<td>9f</td>
</tr>
<tr>
<td>o</td>
<td>八进制整数</td>
<td>237</td>
</tr>
<tr>
<td>f</td>
<td>定点浮点数</td>
<td>15.9</td>
</tr>
<tr>
<td>e</td>
<td>指数浮点数</td>
<td>1.59e+01</td>
</tr>
<tr>
<td>g</td>
<td>通用浮点数</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>十六进制浮点数</td>
<td>0xl.fccdp3</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
<td>Hello</td>
</tr>
<tr>
<td>c</td>
<td>字符</td>
<td>H</td>
</tr>
<tr>
<td>b</td>
<td>布尔</td>
<td>True</td>
</tr>
<tr>
<td>h</td>
<td>散列码</td>
<td>42628b2</td>
</tr>
<tr>
<td>tx 或 Tx</td>
<td>日期时间(T 强制大写）</td>
<td>Date已经过时， 应当改为使用java.time 类</td>
</tr>
<tr>
<td>%</td>
<td>百分号</td>
<td>%</td>
</tr>
<tr>
<td>n</td>
<td>与平台有关的行分隔符</td>
<td></td>
</tr>
</tbody></table>
<p>还可以给出控制格式化输出的各种标志。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>目的</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>打印正数和负数的符号</td>
<td>+3333.33</td>
</tr>
<tr>
<td>空格</td>
<td>在正数之前添加空格</td>
<td>| 3333.33|</td>
</tr>
<tr>
<td>0</td>
<td>数字前面补 0</td>
<td>003333.33</td>
</tr>
<tr>
<td>-</td>
<td>左对齐</td>
<td>|3333.33  |</td>
</tr>
<tr>
<td>(</td>
<td>将负数括在括号内</td>
<td>( 3333.33 )</td>
</tr>
<tr>
<td>,</td>
<td>添加分组分隔符</td>
<td>3,333.33</td>
</tr>
<tr>
<td># ( 对于 f 格式）</td>
<td>包含小数点</td>
<td>3,333.</td>
</tr>
<tr>
<td># (对于 x 或 0 格式）</td>
<td>添加前缀 Ox 或 0</td>
<td>Oxcafe</td>
</tr>
<tr>
<td>$</td>
<td>给定被格式化的参数索引。例如， ％1$d，％1$x 将以十进制和十六进制格式打印第 1 个参数</td>
<td>159 9F</td>
</tr>
<tr>
<td>&lt;</td>
<td>格式化前面说明的数值。 例如，％d%&lt;x 以十进制和十六进制打印同一个数值</td>
<td>159 9F</td>
</tr>
</tbody></table>
<p>可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出。</p>
<p>你可能会在遗留代码中看到Date 类和相关的格式化选项。格式包括两个字母， 以 t 开始，以表 中的任意字母结束。</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>完整的日期和时间</td>
<td>Mon Feb 0918:05:19 PST2015</td>
</tr>
<tr>
<td>F</td>
<td>ISO 8601 日期</td>
<td>2015-02-09</td>
</tr>
<tr>
<td>D</td>
<td>美国格式的日期 （月 / 日 / 年）</td>
<td>02/09/2015</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>可以采用一个格式化的字符串指出要被格式化的参数索引。索引必须紧跟在 ％ 后面， 并以 $ 终止。</p>
<p>参数索引值从 1 开始，而不是从 0 开始，%1$… 对第1个参数格式化这就避免了与0标志混淆.</p>
<p>printf 格式说明符的语法图：<br>% 参数索引值 $ 标志 宽度 . 精度 转换字符<br>% 参数索引值 $ 标志 宽度 t 转换字符</p>
<p>许多格式化规则是本地环境特有的。例如，在德国，组分隔符是句号而不是逗号，Monday 被格式化为 Montag。</p>
<h5 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h5><p>要想对文件进行读取，就需要一个用 File 对象构造一个 Scanner 对象，如下所示：<br>Scanner in = new Scanner(Paths.get(“niyflle.txt”), “UTF-8”);<br>如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠：<br><code>“ c:\\mydirectory\\myfile.txt ”</code> 。<br>如果省略字符编码， 则会使用运行这个 Java 程序的机器的“ 默认编码”。 这不是一个好主意，如果在不同的机器上运行这个程序， 可能会有不同的表现。<br>可以构造一个带有字符串参数的 Scanner, 但这个 Scanner 将字符串解释为数据，而不是文件名。</p>
<p>要想写入文件， 就需要构造一个 PrintWriter 对象。在构造器中，只需要提供文件名：<br>PrintWriter out = new PrintWriter(“myfile.txt”, “UTF-8”);<br>如果文件不存在，创建该文件。 可以使用 print、 println 以及 printf命令。</p>
<p>当指定一个相对文件名时，文件位于 Java 虚拟机启动路径的相对位置。如果使用集成开发环境， 那么启动路<br>径将由 IDE 控制。 可以使用下面的调用方式找到路径的位置：<br>String dir = System.getProperty(“user.dir”);<br>如果觉得定位文件比较烦恼， 则可以考虑使用绝对路径。</p>
<p>如果用一个不存在的文件构造一个 Scanner, 或者用一个不能被创建的文件名构造一个 PrintWriter,<br>那么就会发生异常。Java 编译器认为这些异常比“ 被零除” 异常更严重，应该告知编译器： 已经知道有可能出现“ 输人 / 输出” 异常。这需要在包含文件输入输出方法中用 throws 子句标记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">&quot;myfi1e.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当采用命令行方式启动一个程序时， 可以利用 Shell 的重定向语法将任意文件关联到 System.in 和 System.out:<br>java MyProg &lt; rayfile.txt &gt; output.txt<br>这样，就不必担心处理 IOException 异常了。</p>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>Java 使用条件语句和循环结构确定控制流程。</p>
<h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h5><p>块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。</p>
<p>不能在嵌套的两个块中声明同名的变量。</p>
<h5 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h5><p>条件语句的格式为：<br>if (condition) statement<br>希望在某个条件为真时执行多条语句。在这种情况下， 应该使用块语句 (block statement)。</p>
<p>更一般的条件语句格式 :<br>if (condition) statement1 else statementi2<br>else 子句与最邻近的 if 构成一组。</p>
<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>一般格式为：<br>while ( condition ) statement<br>while 循环语句首先检测循环条件。因此， 循环体中的代码有可能不被执行。如果希望循环体至少执行一次， 则应该将检测条件放在最后:<br>do statement while (condition);</p>
<h5 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h5><p>for 语句的 3 个部分应该对同一个计数器变量进行初始化、 检测和更新。若不遵守这一规则，编写的循环常常晦涩难懂。</p>
<p>在循环中，检测两个浮点数是否相等需要格外小心，由于舍入的误差， 最终可能得不到精确值，循环可能永远不会结束。</p>
<p>如果希望在 for 循环体之外使用循环计数器的最终值，就要确保这个变量在循环语句的前面且在外部声明。</p>
<h5 id="多重选择：switch-语句"><a href="#多重选择：switch-语句" class="headerlink" title="多重选择：switch 语句"></a>多重选择：switch 语句</h5><p>switch语句将从与选项值相匹配的 case 标签处开始执行直到遇到 break 语句，或者执行到 switch 语句的结束处为止。如果没有相匹配的 case 标签， 而有 default 子句， 就执行这个子句。</p>
<p>如果在 case 分支语句的末尾没有 break 语句， 那么就会接着执行下一个 case 分支语句。这种情况相当危险， 常常会引发错误。为此，我们在程序中从不使用 switch 语句。</p>
<p>如果你比我们更喜欢 switch 语句， 编译代码时可以考虑加上 -Xlint:fallthrough 选项：<br>javac -Xlint:fallthrough Test.java<br>这样一来， 如果某个分支最后缺少一个 break 语句， 编译器就会给出一个警告消息。</p>
<p>如果你确实正是想使用这种“ 直通式”（fallthrough) 行为， 可以为其外围方法加一个标注@SuppressWarnings(“fallthrough”)。 这样就不会对这个方法生成警告了 。</p>
<p>case 标签可以是： </p>
<ol>
<li>类型为 char、byte、 short 或 int 的常量表达式。 </li>
<li>枚举常量。 </li>
<li>从 Java SE 7开始， case 标签还可以是字符串字面量。</li>
</ol>
<h5 id="中断控制流程语句"><a href="#中断控制流程语句" class="headerlink" title="中断控制流程语句"></a>中断控制流程语句</h5><p>尽管 Java 的设计者将 goto 作为保留字，但实际上并没有打算在语言中使用它。</p>
<p>无限制地使用 goto 语句确实是导致错误的根源，但在有些情况下，偶尔使用 goto 跳出循环还是有益处的。Java 设计者同意这种看法，在Java语言中增加了一条带标签的 break， 以此来支持这种程序设计风格。</p>
<p>带标签的 break语句，标签必须放在希望跳出的语句块前， 并且必须紧跟一个冒号，通过执行带标签的 break 跳转到带标签的语句块末尾。可以将标签应用到任何语句中，只能跳出语句块，而不能跳入语句块。</p>
<p>continue 语句越过了当前循环体的剩余部分， 立刻跳到循环首部。还有一种带标签的 continue 语句，将跳到与标签匹配的循环首部。</p>
<h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>java.math 包中的两个类：Biglnteger 和 BigDecimal 可以处理包含任意长度数字序列的数值。Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。使用静态的 valueOf方法可以将普通的数值转换为大数值。大数值使用 add 和 multiply 方法进行运算。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种数据结构， 用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。在声明数组变量时， 需要指出数组类型 （ 数据元素类型紧跟 []) 和数组变量的名字。使用 new 运算符创建数组。</p>
<p>可以使用下面两种形式声明数组 int[] a; 或 int a[]；大多数 Java 应用程序员喜欢使用第一种风格， 因为它将类型 int[] ( 整型数组）与变量名分开了。</p>
<p>创建一个数字数组时， 所有元素都初始化为 0，boolean 数组的元素会初始化为 false， 对象数组的元素则初始化为 null。</p>
<p>要想获得数组中的元素个数，可以使用 array.length。</p>
<p>一旦创建了数组， 就不能再改变它的大小（尽管可以改变每一个数组元素）。 如果经常需要在运行过程中扩展数组的大小， 就应该使用另一种数据结构—数组列表（ array list )。</p>
<h5 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for each 循环"></a>for each 循环</h5><p>for each 循环语句的循环变量将会遍历数组中的每个元素， 而不需要使用下标值：<br>for (variable : collection) statement<br>collection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象。</p>
<h5 id="数组初始化以及匿名数组"><a href="#数组初始化以及匿名数组" class="headerlink" title="数组初始化以及匿名数组"></a>数组初始化以及匿名数组</h5><p>创建数组对象并同时赋予初始值的简化书写形式:<br>int[] a = {…};</p>
<p>初始化一个匿名的数组：<br>new int[] {…}<br>使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组：<br>a = new int[] {…}</p>
<p>在 Java 中， 允许数组长度为 0。</p>
<h5 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h5><p>在 Java 中，允许将一个数组变量拷贝给另一个数组变量。这时， 两个变量将引用同一个数组。</p>
<p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法。第 2 个参数是新数组的长度。这个方法通常用来增加数组的大小。如果长度小于原始数组的长度，则只拷贝最前面的数据元素。</p>
<h5 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h5><p>每一个 Java 应用程序都有一个带 String arg[] 参数的 main 方法。这个参数表明 main 方法将接收一个字符串数组， 也就是命令行参数。</p>
<h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h5><p>要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法，这个方法使用了优化的快速排序算法。</p>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>声明一个二维数组：<code>double[][] a</code>;<br>初始化：<code>a = new double[i][j]</code>:<br>使用简化的书写形式对多维数组进行初始化：<code>int[][] a = &#123; &#123;...&#125;, ... &#125;</code>；<br>访问元素：<code>a[i][j]</code>。</p>
<p>for each 循环语句不能自动处理二维数组的每一个元素。它是按照一维教组处理的，要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span>[] row : a)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">double</span> value : row)</span><br><span class="line">		<span class="keyword">do</span> something with value</span><br></pre></td></tr></table></figure>
<p>要想快速地打印一个二维数组的数据元素列表， 可以调用：System.out.println(Arrays.deepToString(a));</p>
<h5 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h5><p>Java 实际上没有多维数组，只有一维数组。多维数组被解释为“ 数组的数组”。可以方便地构造一个“ 不规则” 数组， 即数组的每一行有不同的长度。</p>
<p>要想创建一个不规则的数组， 首先需要分配一个具有所含行数的数组：<br>int[][] a = new int[NMAX + 1] [] ;<br>接下来， 分配这些行。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>09集合</title>
    <url>/2021/04/26/09%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>在实现方法时，选择不同的数据结构会导致其实现风格以及性能存在着很大差异。</p>
<a id="more"></a>

<h3 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h3><p>Java 最初版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet 与Enumeration 接口。</p>
<p>随着Java SE 1.2 的问世，设计人员感到是推出一组功能完善的数据结构的时机了。</p>
<h5 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h5><p>Java 集合类库将接口（ interface ) 与实现( implementation) 分离。</p>
<p>队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; // <span class="title">a</span> <span class="title">simplified</span> <span class="title">form</span> <span class="title">of</span> <span class="title">the</span> <span class="title">interface</span> <span class="title">in</span> <span class="title">the</span> <span class="title">standard</span> <span class="title">library</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>;</span><br><span class="line">	<span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列通常有两种实现方式： 一种是使用循环数组； 另一种是使用链表。每一个实现都可以通过一个实现了Queue 接口的类表示。如果需要一个循环数组队列， 就可以使用ArrayDeque 类。如果需要一个链表队列， 就直接使用LinkedList类。</p>
<p>当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此， 只有在构建集合对象时，使用具体的类才有意义。可以使用接口类型存放集合的引用：<br><code>Queue&lt;Customer&gt; expresslane = new ArrayDeque&lt;&gt;(100);</code><br>利用这种方式，一旦改变了想法， 可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改， 即调用构造器的地方：<br><code>Queue&lt;Custoaer&gt; expressLane = new LinkedList();</code></p>
<p>接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效， 因此多数人优先选择循环数组。循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。</p>
<p>如果想要实现自己的队列类，可以扩展AbstractQueue 类。</p>
<h5 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h5><p>在Java 类库中，集合类的基本接口是Collection 接口。这个接口有两个基本方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">	<span class="function">Ierator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">	. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回true, 如果集合没有发生变化就返回false。</p>
<p>iterator 方法用于返回一个实现了Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</p>
<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>Iterator 接口包含4 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">boolean</span> hasNextO;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反复调用next 方法，可以逐个访问集合中的每个元素。但是， 如果到达了集合的末尾，next 方法将抛出一个NoSuchElementException。因此，需要在调用next 之前调用hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回true。如果想要査看集合中的所有元素，就请求一个迭代器，并在hasNext 返回true 时反复地调用next 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = . . .;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator()；</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">	String element = iter.next()；</span><br><span class="line">	<span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用“ for each” 循环可以更加简练地表示同样的循环操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器简单地将“ for each” 循环翻译为带有迭代器的循环。”for each” 循环可以与任何实现了Iterable 接口的对象一起工作， 这个接口只包含一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java SE 8 中， 甚至不用写循环。可以调用forEachRemaining 方法并提供一lambda表达式。将对迭代器的每一个元素调用这个lambda 表达式，直到再没有元素为止：<br><code>iterator.forEachRemaining(element -&gt; do something with element) ;</code></p>
<p>元素被访问的顺序取决于集合类型。如果对ArrayList 进行迭代， 迭代器将从索引 0 开始， 每迭代一次， 索引值加1。然而， 如果访问HashSet 中的元素， 每个元素将会按照某种随机的次序出现。</p>
<p>Iterator 接口的next 和hasNext 方法与Enumeration 接口的nextElement 和hasMoreElements 方法的作用一样。</p>
<p>Java 集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别。在传统的集合类库中， 迭代器是根据数组索引建模的，查找操作与位置变更是分离的，通过a[i]进行查找，通过 i++ 进行位置变更。但是，Java 迭代器查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用next, 而在执行查找操作的同时， 迭代器的位置随之向前移动。</p>
<p>应该将Java 迭代器认为是位于两个元素之间。当调用next 时， 迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。也可以将Iterator.next 与InputStream.read 看作为等效的。</p>
<p>Iterator 接口的remove 方法将会删除上次调用next 方法时返回的元素。如果调用remove 之前没有调用next 将是不合法的。如果这样做， 将会抛出一个IllegalStateException 异常。</p>
<h5 id="泛型实用方法"><a href="#泛型实用方法" class="headerlink" title="泛型实用方法"></a>泛型实用方法</h5><p>由于Collection 与Iterator 都是泛型接口， 可以编写操作任何集合类型的实用方法。</p>
<p>Collection 接口声明了很多有用的方法，所有的实现类都必须提供这些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span> <span class="params">(Col1ection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span> <span class="params">(Collection&lt;? extends E&gt; from)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span> <span class="params">(Col1ection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Col1ection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] arrayToFill)</span></span></span><br></pre></td></tr></table></figure>
<p>为了能够让实现者更容易地实现Collection 接口， Java 类库提供了一个AbstractCollection 类，它只将基础方法size 和iterator 抽象化了。</p>
<h5 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h5><p>Java 集合框架为不同类型的集合定义了大量接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterable &lt;- Collection &lt;- List, Set, Queue</span><br><span class="line">Set &lt;- SortedSet &lt;- NavigableSet</span><br><span class="line">Queue &lt;- Deque</span><br><span class="line">Map &lt;- SortedMap &lt;- NavigableMap</span><br><span class="line">Iterator &lt; ListIterator</span><br><span class="line">RandomAccess</span><br></pre></td></tr></table></figure>
<p>集合有两个基本接口：Collection 和Map。由于映射包含键/ 值对，所以要用put 方法来插人。可以用迭代器访问元素。不过， 从映射中读取值则要使用get 方法。</p>
<p>List 是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素： 使用迭代器访问， 或者使用一个整数索引来访问。后一种方法称为随机访问（random access ), 因为这样可以按任意顺序访问元素。与之不同， 使用迭代器访问时，必须顺序地访问元素。List 接口定义了多个用于随机访问的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br></pre></td></tr></table></figure>
<p>ListIterator 接口是Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：<br>void add(E element)</p>
<p>实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List 方法并提供一个整数索引来访问。与之不同， 链表尽管也是有序的， 但是随机访问很慢， 所以最好使用迭代器来遍历。</p>
<p>为了避免对链表完成随机访问操作， Java SE 1.4 引入了一个标记接口RandomAccess。这个接口不包含任何方法， 不过可以用它来测试一个特定的集合是否支持高效的随机访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">&#123;</span><br><span class="line">	use random access algorithm</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	use sequential access algorithm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set 接口等同于Collection 接口，不过其方法的行为有更严谨的定义。Set 的add 方法不允许增加重复的元素。要适当地定义集的equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。</p>
<p>SortedSet 和SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。</p>
<p>Java SE 6 引人了接口NavigableSet 和NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法。TreeSet 和TreeMap 类实现了这些接口。</p>
<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p>Java库中的具体集合。除了以Map 结尾的类之外， 其他类都实现了Collection 接口，而以Map 结尾的类实现了Map 接口：</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>一种可以动态增长和缩减的索引序列</td>
</tr>
<tr>
<td>LinkedList</td>
<td>一种可以在任何位置进行高效地插人和删除操作的有序序列</td>
</tr>
<tr>
<td>ArrayDeque</td>
<td>一种用循环数组实现的双端队列</td>
</tr>
<tr>
<td>HashSet</td>
<td>一种没有重复元素的无序集合</td>
</tr>
<tr>
<td>TreeSet</td>
<td>—种有序集</td>
</tr>
<tr>
<td>EnumSet</td>
<td>一种包含枚举类型值的集</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>一种可以记住元素插人次序的集</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td>一种允许高效删除最小元素的集合</td>
</tr>
<tr>
<td>HashMap</td>
<td>一种存储键/ 值关联的数据结构</td>
</tr>
<tr>
<td>TreeMap</td>
<td>—种键值有序排列的映射表</td>
</tr>
<tr>
<td>EnumMap</td>
<td>一种键值属于枚举类型的映射表</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>一种可以记住键/ 值项添加次序的映射表</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>一种其值无用武之地后可以被垃圾回收器回收的映射表</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>一种用 == 而不是用equals 比较键值的映射表</td>
</tr>
</tbody></table>
<p>集合框架中的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Abstract &lt;- AbstractList, AbstractSet, AbstractQueue, ArrayQueue</span><br><span class="line">AbstractList &lt;- AbstractSequentialList, ArrayList</span><br><span class="line">AbstractSequentialList &lt; LinkedList</span><br><span class="line">AbstractSet &lt;- HashSet, EnumSet, TreeSet</span><br><span class="line">HashSet &lt;- LinkedHashSet</span><br><span class="line">AbstractQueue &lt;- PriorityQueue</span><br><span class="line"></span><br><span class="line">AbstractMap &lt;- HashMap, ThreeMap, EnumMap, WeakHashMap, IdentityHashMap</span><br><span class="line">HashMap &lt;- LinkedHashMap</span><br></pre></td></tr></table></figure>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。 在数组中间的位置上插入一个元素也是如此。</p>
<p>链表（ linked list ) 解决了这个问题。链表将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java 程序设计语言中， 所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用。</p>
<p>链表与泛型集合之间有一个重要的区别。链表是一个有序集合（ ordered collection ), 每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。由于迭代器是描述集合中位置的， 所以依赖于位置的add 方法将由迭代器负责。</p>
<p>只有对自然有序的集合使用迭代器添加元素才有实际意义。集合类库提供了子接口Listlterator, 其中包含add 方法，与Collection.add 不同， 这个方法不返回boolean 类型的值， 它假定添加操作总会改变链表。另外， Listlterator 接口有两个方法， 可以用来反向遍历链表：<br>E previous()<br>boolean hasPrevious()<br>与next 方法一样， previous 方法返回越过的对象。</p>
<p>LinkedList 类的listlterator 方法返回一个实现了Listlterator 接口的迭代器对象。add 方法在迭代器位置之前添加一个新对象。如果多次调用add 方法， 将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。</p>
<p>add 方法只依赖于迭代器的位置， 而remove 方法依赖于迭代器的状态。不能连续调用两次remove。</p>
<p>set 方法用一个新元素取代调用next 或previous 方法返回的上一个元素。</p>
<p>如果迭代器发现它的集合被另一个迭代器修改了， 或是被该集合自身的方法修改了， 就会抛出一个ConcurrentModificationException 异常。</p>
<p>为了避免发生并发修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。</p>
<p>有一种简单的方法可以检测到并发修改的问题。集合可以跟踪改写操作（诸如添加或删除元素）的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致， 抛出一个ConcurrentModificationException 异常。</p>
<p>链表只负责跟踪对列表的结构性修改， 例如， 添加元素、删除元素。set 方法不被视为结构性修改。</p>
<p>链表不支持快速地随机访问。如果要查看链表中第n个元素，就必须从头开始， 越过n -1个元素。LinkedList 类还是提供了一个用来访问某个特定元素的get 方法，这个方法的效率并不太高，每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。</p>
<p>列表迭代器接口还有一个方法，可以告之当前位置的索引。由于Java 迭代器指向两个元素之间的位置， 所以可以同时产生两个索引：nextlndex 方法返回下一次调用next 方法时返回元素的整数索引；previouslndex 方法返回下一次调用previous 方法时返回元素的整数索引。这两个方法的效率<br>非常高，这是因为迭代器保持着当前位置的计数值。如果有一个整数索引 n, list.listlterator(n) 将返回一个迭代器， 这个迭代器指向索引为n 的元素前面的位置。</p>
<h5 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h5><p>ArrayList 类实现了List 接口。ArrayList 封装了一个动态再分配的对象数组。</p>
<p>Vector 类的所有方法都是同步的。可以由两个线程安全地访问一个Vector 对象。但是， 如果由一个线程访问Vector, 代码要在同步操作上耗费大量的时间。这种情况还是很常见的。而ArrayList 方法不是同步的，因此， 建议在不需要同步时使用ArrayList, 而不要使用Vector。</p>
<h5 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h5><p>如果不在意元素的顺序， 可以有几种能够快速査找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。</p>
<p>散列表为每个对象计算一个整数， 称为散列码（hashcode)。 散列码是由对象的实例域产生的一个整数。更准确地说， 具有不同数据域的对象将产生不同的散列码。如果自定义类，就要负责实现这个类的hashCode方法。注意，自己实现的hashCode 方法应该与equals 方法兼容，即如果a.equals(b) 为true, a 与b 必须具有相同的散列码。最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。</p>
<p>在Java 中， 散列表用链表数组实现。每个列表被称为桶（ bucket) 。要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。当然， 有时候会遇到桶被占满的情况， 这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。 这时， 需要用新对象与桶中的所有对象进行比较， 査看这个对象是否已经存在。在JavaSE 8 中， 桶满时会从链表变为平衡二叉树。</p>
<p>如果大致知道最终会有多少个元素要插人到散列表中， 就可以设置桶数。通常， 将桶数设置为预计元素个数的75% ~ 150%。有些研究人员认为：尽管还没有确凿的证据， 但最好将桶数设置为一个素数， 以防键的集聚。标准类库使用的桶数是2 的幂， 默认值为16。</p>
<p>如果散列表太满， 就需要再散列（rehashed)。如果要对散列表再散列， 就需要创建一个桶数更多的表，并将所有元素插入到这个新表中， 然后丢弃原来的表。装填因子（load factor ) 决定何时对散列表进行再散列。如果装填因子为0.75 (默认值)，而表中超过75%的位置已经填人元素， 这个表就会用双倍的桶数自动地进行再散列。</p>
<p>散列表可以用于实现几个重要的数据结构。其中最简单的是set 类型。set 是没有重复元素的元素集合。Java 集合类库提供了一个HashSet 类，它实现了基于散列表的集。</p>
<p>散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。</p>
<h5 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h5><p>树集是一个有序集合( sorted collection) 。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p>
<p>正如 TreeSet 类名所示，排序是用树结构完成的（当前实现使用的是红黑树) 。</p>
<p>将一个元素添加到树中要比添加到散列表中慢，如果树中包含 n 个元素， 査找新元素的正确位置平均需要 log2 n 次比较。</p>
<p>要使用树集， 必须能够比较元素。这些元素必须实现 Comparable 接口，或者构造集时必须提供一个 Comparator 。</p>
<h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><p>优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。优先级队列使用了为堆（heap)。堆是一个可以自我调整的二叉树，对树执行添加（ add) 和删除（remore) 操作， 可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>一个优先级队列既可以保存实现了 Comparable 接口的类对象， 也可以保存在构造器中提供的 Comparator 对象。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射用来存放键 / 值对。如果提供了键， 就能够查找到值。</p>
<h5 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h5><p>Java 类库为映射提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了 Map 接口。</p>
<p>散列映射对键进行散列， 树映射用键的整体顺序对元素进行排序， 并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。</p>
<p>每当往映射中添加对象时， 必须同时提供一个键。要想检索一个对象， 必须使用一个键。</p>
<p>如果在映射中没有与给定键对应的信息， get 将返回 null，null 返回值可能并不方便，有时可以有一个好的默认值， 用作为映射中不存在的键，然后使用 getOrDefault 方法。</p>
<p>键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用 put 方法， 第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。</p>
<p>remove 方法用于从映射中删除给定键对应的元素。size 方法用于返回映射中的元素数。</p>
<p>要迭代处理映射的键和值， 最容易的方法是使用 forEach 方法。可以提供一个接收键和值的 lambda 表达式。</p>
<h5 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h5><p>正常情况下，可以得到与一个键关联的原值，完成更新， 再放回更新后的值。不过，必须考虑一个特殊情况， 即键第一次出现。</p>
<p>作为一个简单的补救， 可以使用 getOrDefault 方法。</p>
<p>另一种方法是首先调用 putlfAbsent 方法。只有当键原先存在时才会放入一个值。</p>
<p>merge 方法可以简化这个常见的操作。<br>counts.merge(word, 1, Integer::sum);<br>将把 word 与 1 关联，否则使用 Integer::sum 函数组合原值和 1 。</p>
<h5 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h5><p>集合框架不认为映射本身是一个集合。 不过， 可以得到映射的视图（ View ）——这是实现了Collection 接口或某个子接口的对象。</p>
<p>有 3 种视图： 键集、 值集合（不是一个集） 以及键 / 值对集。下面的方法：<br>Set&lt;K&gt; keySet()<br>Collection&lt;V&gt; values()<br>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()<br>会分别返回这 3 个视图。</p>
<p>keySet 不是 HashSet 或 TreeSet， 而是实现了 Set 接口的另外某个类的对象。Set 接口扩展了 Collection 接口。因此， 可以像使用集合一样使用 keySet。</p>
<p>如果在键集视图上调用迭代器的 remove方法， 实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。条目集视图有同样的限制。</p>
<h5 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h5><p>假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键 / 值对无法从映射中删除。垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的， 它们不能被回收。因此， 需要由程序负责从长期存活的映射表中删除那些无用的值。 或者使用 WeakHashMap 完成这件事情。</p>
<p>WeakHashMap 使用WeakRefrence保存键。WeakReference 对象将引用保存到另外一个对象中，在这里，就是散列键。如果某个对象只能由 WeakReference 引用， 垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列， 以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用， 并且已经被收集起来。于是， WeakHashMap 将删除对应的条目。</p>
<h5 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h5><p>LinkedHashSet 和 LinkedHashMap类用来记住插人元素项的顺序。</p>
<p>链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要想构造这样一个的散列映射表， 请调用:<br>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</p>
<h5 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h5><p>EnumSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1。</p>
<p>EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br></pre></td></tr></table></figure>
<p>EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型：<br>EnumMap&lt;Weekday, Employee&gt; personlnCharge = new EnumMapo(Weekday.class);</p>
<h5 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h5><p>类 IdentityHashMap 有特殊的作用。在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用 System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。</p>
<p>在实现对象遍历算法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</p>
<h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用视图( views) 可以获得其他的实现了 Collection 接口和 Map 接口的对象。keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h5 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h5><p>Arrays 类的静态方法 asList 将返回一个包装了普通 Java 数组的 List 包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。它是一个视图对象， 带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法都会抛出一个UnsupportedOperationException 异常。</p>
<p>asList 方法可以接收可变数目的参数。这个方法调用：<br>Collections.nCopies(n, anObject)<br>将返回一个实现了 List 接口的不可修改的对象， 并给人一种包含n个元素， 每个元素都像是一个 anObject 的错觉。</p>
<p>Collections.singleton(anObject)则将返回一个视图对象。这个对象实现了 Set 接口。返回的对象实现了一个不可修改的单元素集， 而不需要付出建立数据结构的开销。singletonList方法与 singletonMap 方法类似。</p>
<h5 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h5><p>可以为很多集合建立子范围（subrange ) 视图。可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况。</p>
<p>对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。SortedSet 接口声明了 3 个方法：<br>SortedSet&lt;E&gt; subSet(E from, E to)<br>SortedSet&lt;E&gt; headSet(E to)<br>SortedSet&lt;E&gt; tailSet(E from)<br>这些方法将返回大于等于 from 且小于 to 的所有元素子集。有序映射也有类似的方法：<br>SortedMap&lt;K, V&gt; subMap(K from, K to)<br>SortedMap&lt;K, V&gt; headMap(K to)<br>SortedMap&lt;K , V&gt; tailMap(K from)<br>返回映射视图， 该映射包含键落在指定范围内的所有元素。Java SE 6 引人的 NavigableSet 接口赋予子范围操作更多的控制能力。可以指定是否包括边界：<br>NavigableSet&lt;E&gt; subSet(E from, boolean fromlnclusive, E to, boolean tolnclusive)<br>NavigableSet&lt;E&gt; headSet(E to, boolean tolnclusive)<br>NavigableSet&lt;E&gt; tailSet(E from, boolean fromlnclusive)</p>
<h5 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h5><p>Collections 还有几个方法， 用于产生集合的不可修改视图。这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改， 就抛出一个异常，同时这个集合将保持未修改的状态。</p>
<p>可以使用下面 8 种方法获得不可修改视图：<br>Collections. unmodifiableCollection<br>Collections.unmodifiableList<br>Collections.unmodifiableSet<br>Collections.unmodifiableSortedSet<br>Collections.unmodifiableNavigableSet<br>Collections.unmodifiableMap<br>Collections.unmodifiableSortedMap<br>Collections.unmodifiableNavigableMap</p>
<p>不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用对集合进行修改。</p>
<p>由于视图只是包装了接口而不是实际的集合对象， 所以只能访问接口中定义的方法。</p>
<p>unmodifiableCollection 方法将返回一个集合， 它的 equals 方法不调用底层集合的 equals 方法。相反， 它继承了 Object 类的 equals 方法。unmodifiableSet 类和 unmodifiableList 类 却 使 用 底 层 集 合 的 equals 方 法 和 hashCode 方 法。</p>
<h5 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h5><p>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。例如，Collections 类的静态 synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的 Map。</p>
<h5 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h5><p>“ 受査” 视图用来对泛型类型发生问题时提供调试支持。</p>
<p>下面定义了一个安全列表：<br>List&lt;String&gt; safestrings = Collections.checkedList(strings，String.class);<br>视图的 add 方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。</p>
<p>受查视图受限于虚拟机可以运行的运行时检查。 </p>
<h5 id="关于可选操作的说明"><a href="#关于可选操作的说明" class="headerlink" title="关于可选操作的说明"></a>关于可选操作的说明</h5><p>在集合和迭代器接口的 API 文档中， 许多方法描述为“ 可选操作”。是否应该将“ 可选” 方法这一技术扩展到用户的设计中呢？ 我们认为不应该。尽管集合被频繁地使用， 其实现代码的风格也未必适用于其他问题领域。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>泛型集合接口有一个很大的优点， 即算法只需要实现一次。Java 类库中包含了基本的排序、二分查找等实用算法。</p>
<h5 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h5><p>Collections 类中的 sort 方法可以对实现了 List 接口的集合进行排。这个方法假定列表元素实现了 Comparable 接口。如果想采用其他方式对列表进行排序，可以使用 List 接口的 sort方法并传入一个 Comparator 对象。</p>
<p>如果想按照降序对列表进行排序， 可以使用一种非常方便的静态方法 Collections.reverseOrder()。这个方法将返回一个比较器， 比较器则返回 b.compareTo(a)。</p>
<p>Java 程序设计语言直接将所有元素转人一个数组，对数组进行排序，然后，再将排序后的序列复制回列表。集合类库中使用的排序算法比快速排序要慢一些，快速排序是通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定， 即不需要交换相同的元素。如果采用稳定的排序算法， 相同元素的顺序将会保留原排列的顺序。</p>
<p>因为集合不需要实现所有的“ 可选” 方法，因此， 所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法。可以传递什么类型的列表呢？ 根据文档说明，列表必须是可修改的， 但不必是可以改变大小的。</p>
<p>Collections 类有一个算法 shuffle,随机地混排列表中元素的顺序。如果提供的列表没有实现RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>如果数组是有序的，就可以直接査看位于数组中间的元素， 看一看是否大于要查找的元素。如果是， 用同样的方法在数组的前半部分继续查找；否则， 用同样的方法在数组的后半部分继续查找。这样就可以将查找范围缩减一半。一直用这种方式査找下去。</p>
<p>Collections 类的 binarySearch方法实现了这个算法。要想查找某个元素， 必须提供集合（这个集合要实现 List 接口）以及要查找的元素。如果集合没有采用 Comparable 接口的compareTo 方法进行排序， 就还要提供一个比较器对象。<br>i = Collections.binarySearch(c, element);<br>i = Collections.binarySearch(c, element, comparator);</p>
<p>如果 binarySearch 方法返回的数值大于等于 0, 则表示匹配对象的索引。c.get(i) 等于在这个比较顺序下的 element。</p>
<p>如果返回负值， 则表示没有匹配的元素。但是，可以利用返回值计算应该将 element 插人到集合的哪个位置， 以保持集合的有序性。插人的位置是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (i &lt; 0)</span><br><span class="line">	c.add(-i - 1, element);</span><br></pre></td></tr></table></figure>
<p>只有采用随机访问，二分査找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分査找就完全失去了优势。因此，如果为 binarySearch 算法提供一个链表， 它将自动地变为线性查找。</p>
<h5 id="批操作"><a href="#批操作" class="headerlink" title="批操作"></a>批操作</h5><p>很多操作会“ 成批” 复制或删除元素。</p>
<h5 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h5><p>由于 Java 平台 API 的大部分内容都是在集合框架创建之前设计的， 所以，有时候需要在传统的数组和比较现代的集合之间进行转换。</p>
<p>如果需要把一个数组转换为集合，Arrays.asList 包装器可以达到这个目的。</p>
<p>集合得到数组会更困难一些。当然，可以使用 toArray 方法，toArray方法返回的数组是一个 Object[] 数组， 不能改变它的类型（不能强制类型转换）。<br>Object[] values = staff.toArray();<br>可以使用toArray 方法的一个变体形式，提供一个所需类型而且长度为 0 的数组。这样一来， 返回的数组就会创建为相同的数组类型：<br>String[] values = staff.toArray(new String[0]);<br>如果愿意，可以构造一个指定大小的数组：<br>staff.toArray(new String[staff.size()]);<br>在这种情况下，不会创建新数组。<br>为什么不能直接将一个 Class 对象（如 String.class) 传递到 toArray 方法。原因是这个方法有“ 双重职责”， 不仅要填充一个已有的数组（如果它足够长，) 还要创建一个新数组。</p>
<h5 id="编写自己的算法"><a href="#编写自己的算法" class="headerlink" title="编写自己的算法"></a>编写自己的算法</h5><p>如果编写自己的算法（实际上，是以集合作为参数的任何方法，) 应该尽可能地使用更加通用接口，而不要使用具体的实现。</p>
<p>既然将集合接口作为方法参数是个很好的想法， 为什么 Java 类库不更多地这样做呢？之所以没有这样做， 原因很简单： 时间问题。</p>
<p>如果编写了一个返回集合的方法，可能还想要一个返回接口，而不是返回类的方法，因为这样做可以在日后改变想法，并用另一个集合重新实现这个方法。</p>
<h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><p>从 Java 第 1 版问世以来， 在集合框架出现之前已经存在大量“ 遗留的” 容器类。这些类已经集成到集合框架中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack -&gt; Vector -&gt; AbstractList -&gt; List</span><br><span class="line">Vector -&gt; RandomAccess</span><br><span class="line">Properties -&gt; Hashtable -&gt; Map</span><br></pre></td></tr></table></figure>
<h5 id="Hashtable-类"><a href="#Hashtable-类" class="headerlink" title="Hashtable 类"></a>Hashtable 类</h5><p>Hashtable 类与 HashMap 类拥有相同的接口。Hashtable 的方法是同步的。如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 HashMap。如果需要并发访问， 则要使用 ConcurrentHashMap。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>遗留集合使用 Enumeration 接口对元素序列进行遍历。Enumeration 接口有两个方法， 即hasMoreElements 和 nextElement。</p>
<p>静态方法 Collections.enumeration将产生一个枚举对象，枚举集合中的元素。</p>
<h5 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h5><p>属性映射（property map) 是一个类型非常特殊的映射结构。它有下面 3 个特性：</p>
<ul>
<li><p>键与值都是字符串。</p>
</li>
<li><p>表可以保存到一个文件中， 也可以从文件中加载。</p>
</li>
<li><p>使用一个默认的辅助表。</p>
</li>
</ul>
<p>实现属性映射的 Java 平台类称为 Properties。属性映射通常用于程序的特殊配置选项，</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>从 1.0 版开始，标准类库中就包含了 Stack类，其中有大家熟悉的 push 方法和 pop方法。但是， Stack 类扩展为 Vector 类，从理论角度看，Vector 类并不太令人满意，它可以让栈使用不属于栈操作的 insert 和 remove 方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。</p>
<h5 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h5><p>Java 平台的 BitSet 类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适)。如果需要高效地存储位序列就可以使用位集。由于位集将位包装在字节里，所以，使用位集要比使用 Boolean 对象的 ArrayList 更加高效。</p>
<p>BitSet 类提供了一个便于读取、设置或清除各个位的接口。<br>例如，对于一个名为 bucketOfBits 的 BitSet:<br>bucketOfBits.get(i)<br>如果第 i 位处于“ 开” 状态，就返回 true; 否则返回 false。<br>bucketOfBits.set(i)<br>将第 i 位置为“ 开” 状态。<br>bucketOfBits.clear(i)<br>将第 i 位置为“ 关” 状态。</p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>12Swing用户界面组件</title>
    <url>/2021/04/26/12Swing%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="Swing-和模型-视图-控制器设计模式"><a href="#Swing-和模型-视图-控制器设计模式" class="headerlink" title="Swing 和模型-视图 -控制器设计模式"></a>Swing 和模型-视图 -控制器设计模式</h3><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>在解决一个问题时， 不需要从头做起， 而是借鉴过去的经验，或者向做过相关工作的专家请教。设计模式就是一种方法，这种方法以一种结构化的方式展示专家们的心血。</p>
<p>在软件模式的分类中，每种模式都遵循一种特定的格式。这些模式首先描述背景， 即引发设计问题的情形；接着解释问题， 通常这里会有几个冲突的因素；最终， 权衡这些冲突， 给出问题的解决方案。</p>
<p>在“ 模型 -视图-控制器” 模式中， 背景是显示信息和接收用户输人的用户界面系统。这里有几个冲突因素，对于同一数据来说， 可能需要同时更新多个可视化表示。解决方案是将这些功能分布到三个独立的交互组件： 模型、视图和控制器。</p>
<p>模型 -视图 -控制器模式并不是 AWT 和 Swing 设计中使用的唯一模式。下列是应用的另外几种模式：<br>容器和组件是“ 组合（composite )” 模式、带滚动条的面板是“ 装饰器（decorator)” 模式、布局管理器是“ 策略（strategy )” 模式。</p>
<h5 id="模型-视图-控制器模式"><a href="#模型-视图-控制器模式" class="headerlink" title="模型 -视图 -控制器模式"></a>模型 -视图 -控制器模式</h5><p>构成用户界面组件都有三个要素：</p>
<ul>
<li>内容， 如： 按钮的状态（是否按下，) 或者文本框的文本。</li>
<li>外观（颜色，大小等)。</li>
<li>行为（对事件的反应)。</li>
</ul>
<p>Swing 设计者采用了模型 -视图 -控制器（ model-view-controller ) 模式。这种设计模式遵循面向对象设计中的一个基本原则： 限制一个对象拥有的功能数量。模型 -视图 -控制器（MVC) 模式实现三个独立的类：</p>
<ul>
<li>模型 （model): 存储内容。</li>
<li>视图 （view): 显示内容。</li>
<li>控制器（controller ): 处理用户输入。</li>
</ul>
<p>模型存储内容，它没有用户界面。模型必须实现改变内容和查找内容的方法。模型 -视图 -控制器模式的一个优点是一个模型可以有多个视图， 其中每个视图可以显示全部内容的不同部分或不同形式。</p>
<p>控制器负责处理用户输入事件，然后决定是否把这些事件转化成对模型或视图的改变。</p>
<p>在程序员使用 Swing 组件时， 通常不需要考虑模型 -视图 -控制器体系结构。每个用户界面元素都有一个包装器类（如 JButton 或 JTextField ) 来保存模型和视图。当需要查询内容时， 包装器类会向模型询问并且返回所要的结果。当想改变视图时， 包装器类会把此请求转发给视图。然而，有时候包装器转发命令并不得力。</p>
<p>模式只能作为一种指导性的建议而并没有严格的戒律。没有一种模式能够适用于所有情况。</p>
<h5 id="Swing-按钮的模型-视图-控制器分析"><a href="#Swing-按钮的模型-视图-控制器分析" class="headerlink" title="Swing 按钮的模型 -视图 -控制器分析"></a>Swing 按钮的模型 -视图 -控制器分析</h5><p>对于大多数组件来说， 模型类将实现一个名字以 Model 结尾的接口。实现了此接口的类可以定义各种组件的状态。在 Swing 库中有一个名为 DefaultButtonModel 的类就实现了ButtonModel接口。可以通过查看 ButtonModel 接口中的特征来了解按钮模型所维护的数据类别。</p>
<p>每个 JButton 对象都存储了一个按钮模型对象， 可以用下列方式得到它的引用。<br>]Button button = new JButton(“Blue”);<br>ButtonModel model = button.getModel();</p>
<p>模型不存储按钮标签或者图标。</p>
<p>当使用 Metal 观感时，JButton 类用 BasicButtonUI 类作为其视图；用 ButtonUIListener 类作为其控制器。通常， 每个 Swing 组件都有一个相关的后缀为 UI 的视图对象， 但并不是所有的 Swing 组件都有专门的控制器对象。</p>
<h3 id="布局管理概述"><a href="#布局管理概述" class="headerlink" title="布局管理概述"></a>布局管理概述</h3><p>流布局管理器（ flow layout manager)是面板的默认布局管理器。当一行的空间不够时，会将显示在新的一行上。组件总是位于容器的中央，即使用户对框架进行缩放也是如此。流布局管理器完全控制每个<br>组件的放置位置。流布局将维持每个组件的最佳尺寸。</p>
<p>组件放置在容器中， 布局管理器决定容器中的组件具体放置的位置和大小。</p>
<p>组件（Component）可以放置在面板这样的容器中。由于 Container 类继承于 Component 类，所以<br>容器也可以放置在另一个容器中。 </p>
<p>Component 的类层次结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object &lt;- Component &lt;- Container &lt;- Window, JComponent</span><br><span class="line">Window &lt;- Frame &lt;- JFrame</span><br><span class="line">Window &lt;- Dialog &lt;- JDialog</span><br><span class="line">JComponent &lt;- JPanel, JTextComponent, JLabel, JScrollPanel, JComboBox, AbstractButton, JMenuBar</span><br><span class="line">JTextComponent &lt;- JTextField, JTextArea</span><br><span class="line">AbstractButton &lt;- JButton, JToggleButton, JMenuItem</span><br></pre></td></tr></table></figure>
<p>继承层次有两点显得有点混乱。首先， 像 JFrame 这样的顶层窗口是 Container 的子类， 所以也是 Component 的子类， 但却不能放在其他容器内。另外，JComponent 是 Container 的子类， 但不直接继承 Component, 因此， 可以将其他组件添置到 JButton 中。但无论如何， 这些组件无法显示出来。</p>
<p>每个容器都有一个默认的布局管理器，可以用setLayout方法重新进行设置。容器的 add方法将把组件和放置的方位传递给布局管理器。</p>
<h5 id="边框布局"><a href="#边框布局" class="headerlink" title="边框布局"></a>边框布局</h5><p>边框布局管理器（border layout manager) 是每个 JFrame 的内容窗格的默认布局管理器。它允许为每个组件选择一个放置位置。可以选择把组件放在内容窗格的中部、 北部、南部、 东部或者西部。</p>
<p>先放置边缘组件，剩余的可用空间由中间组件占据。当边框布局容器被缩放时，边缘组件的尺寸不会改变，而中部组件的大小会发生变化。在添加组件时可以指定 BorderLayout 类中的 CENTER、 NORTH、SOUTH、EAST和 WEST 常量。并非需要占用所有的位置，如果没有提供任何值，系统默认为 CENTER。</p>
<p>BorderLayout 常 量 定 义 为 字 符 串。 例 如： BorderLayout.SOUTH 定 义 为 字 符 串“ SOUTH”。很多程序员喜欢直接使用字符串， 因为这些字符串比较简短，例如， frame.add (component,“ SOUTH” ）。然而，如果字符串拼写有误， 编译器不会捕获错误。</p>
<p>边框布局会扩展所有组件的尺寸以便填满可用空间，当将一个按钮添加到容器中时会出现问题，解决这个问题的常见方法是使用另外一个面板（panel)。</p>
<h5 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h5><p>网格布局像电子数据表一样， 按行列排列所有的组件。不过，它的每个单元大小都是一样的。在网格布局对象的构造器中，需要指定行数和列数。添加组件， 从第一行的第一列开始， 然后是第一行的第二列， 以此类推。</p>
<p> pack方法使用所有组件的最佳大小来计算框架的高度和宽度。</p>
<h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3><p>文本域（ JTextField) 和文本区（ JTextArea) 组件用于获取文本输人。文本域只能接收单行文本的输人，而文本区能够接收多行文本的输人。JPassword 也只能接收单行文本的输人，但不会将输入的内容显示出来。这三个类都继承于 JTextComponent 类。</p>
<h5 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h5><p>文本域添加到窗口的常用办法是将它添加到面板或者其他容器中，这与添加按钮完全一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JPanel panel &#x3D; new JPanel();</span><br><span class="line">JTextField textField &#x3D; new JTextField(&quot;Default input&quot;, 20);</span><br><span class="line">panel.add(textField);</span><br></pre></td></tr></table></figure>
<p>设置了文本域的宽度。如果希望文本域最多能够输人 n 个字符，就应该把宽度设置为 n 列。一列就是在当前使用的字体下一个字符的宽度。在实际中，应该将最大输人长度再多设 1 ~ 2 个字符。列数只是给 AWT 设定首选（ preferred) 大小的一个提示。如果布局管理器需要缩放这个文本域，它会调整文本域的大小。在 JTextField 的构造器中设定的宽度并不是用户能输人的字符个数的上限，当文本长度超过文本域长度时输人就会滚动。用户通常不喜欢滚动文本域， 因此应该尽量把文本域设置的宽一些。</p>
<p>如果需要在运行时重新设置列数，可以使用 setColumns 方法，之后需要调用包含这个文本框的容器的 revalidate 方法。revalidate 方法会重新计算容器内所有组件的大小，并且对它们重新进行布局。revalidate 方法是 JComponent 类中的方法。它并不是马上就改变组件大小， 而是给这个组件加一个需要改变大小的标记。这样就避免了多个组件改变大小时带来的重复计算。如果想重新计算一个 JFrame 中的所有组件（JFrame 没有扩展 JComponent）， 就调用 validate 方法。</p>
<p>可以在任何时候调用 setText 方法改变文本域中的内容。可以调用 getText 方法来获取用户键人的文本，如果想要将 getText 方法返回的文本域中的内容的前后空格去掉，就应该调用 trim 方法。如果想要改变显示文本的字体，就调用 setFont 方法。</p>
<h5 id="标签和标签组件"><a href="#标签和标签组件" class="headerlink" title="标签和标签组件"></a>标签和标签组件</h5><p>标签是容纳文本的组件，它们没有任何的修饰， 也不能响应用户输入。可以利用标签标识组件。要想用标识符标识这种不带标签的组件， 应该：</p>
<ol>
<li>用相应的文本构造一个 JLabel 组件。</li>
<li>将标签组件放置在距离需要标识的组件足够近的地方， 以便用户可以知道标签所标识的组件。</li>
</ol>
<p>JLabel 的构造器允许指定初始文本和图标， 也可以选择内容的排列方式。可以用 SwingConstants 接口中的常量来指定排列方式。如 LEFT、RIGHT、CENTER、NORTH、 EAST 等。利用 setText 和 setlcon 方法可以在运行期间设置标签的文本和图标。</p>
<p>可以在按钮、标签和菜单项上使用无格式文本或 HTML 文本。不推荐在按钮上使用 HTML 文本，这样会影响观感。 但是 HTML 文本在标签中是非常有效的。只要简单地将标签字符串放置在 <code>&lt;html&gt;...&lt;/html&gt;</code> 中即可。需要说明的是包含 HTML 标签的第一个组件需要延迟一段时间才能显示出来，这是因为需要加载相当复杂的 HTML 显示代码</p>
<h5 id="密码域"><a href="#密码域" class="headerlink" title="密码域"></a>密码域</h5><p>密码域（JPasswordField）中用户输入的字符不显示出来。每个输人的字符都用回显字符（ echo character) 表示， 典型的回显字符是星号(*)。</p>
<h5 id="文本区"><a href="#文本区" class="headerlink" title="文本区"></a>文本区</h5><p>当在程序中放置一个文本区组件（JTextArea）时，用户就可以输人多行文本，并用 ENTER 键换行，每行都以一个“\n” 结尾。</p>
<p>在 JTextArea 组件的构造器中，可以指定文本区的行数和列数。出于稳妥的考虑，参数 columns 应该设置得大一些。用户并不受限于输人指定的行数和列数。当输人过长时，文本会滚动。还可以用setColumns 方法改变列数， 用 setRows 方法改变行数。这些数值只是首选大小——布局管理器可能会对文本区进行缩放。</p>
<p>如果文本区的文本超出显示的范围， 那么剩下的文本就会被剪裁掉。可以通过开启换行特性来避免裁剪过长的行：<br>textArea.setLineWrap(true);<br>换行只是视觉效果；文档中的文本没有改变，在文本中并没有插入“ \n” 字符。</p>
<p>JTextArea 组件只显示无格式的文本， 没有特殊字体或者格式设置。如果想要显示格式化文本（如 HTML ), 就需要使用 JEditorPane 类。</p>
<h5 id="滚动窗格"><a href="#滚动窗格" class="headerlink" title="滚动窗格"></a>滚动窗格</h5><p>在 Swing 中， 文本区没有滚动条。 如果需要滚动条， 可以将文本区插人到滚动窗格(scroll pane) 中：<br>textArea = new JTextArea(8, 40);<br>JScrollPane scrollPane = new JScratlPane(textArea);<br>现在滚动窗格管理文本区的视图。如果文本超出了文本区可以显示的范围， 滚动条就会自动地出现， 并且在删除部分文本后，当文本能够显示在文本区范围内时， 滚动条会再次自动地消失。滚动是由滚动窗格内部处理的， 编写程序时无需处理滚动事件。这是一种为任意组件添加滚动功能的通用机制， 而不是文本区特有的。</p>
<h3 id="选择组件"><a href="#选择组件" class="headerlink" title="选择组件"></a>选择组件</h3><h5 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h5><p>如果想要接收的输人只是“ 是” 或“ 非”，就可以使用复选框组件（JCheckBox）。复选框自动地带有标识标签。用户通过点击某个复选框来选择相应的选项， 再点击则取消选取。当复选框获得焦点时， 用户也可以通过按空格键来切换选择。</p>
<p>在构造器中指定标签文本。可以使用 setSelected 方法来选定或取消选定复选框。isSelected方法将返回每个复选框的当前状态，如果没有选取则为 false, 否则为 true。当用户点击复选框时将触发一个动作事件，可以为复选框设置一个动作监听器。</p>
<p>复选框为正方形， 并且如果被选择， 这个正方形中会出现一个对钩的符号。</p>
<h5 id="单选钮"><a href="#单选钮" class="headerlink" title="单选钮"></a>单选钮</h5><p>用户只选择几个选项当中的一个。当用户选择另一项的时候， 前一项就自动地取消选择。这样一组选框通常称为单选钮组（Radio Button Group)。</p>
<p>要实现单选钮组。需为单选钮组构造一个 ButtonGroup 的对象。然后，再将 JRadioButton 类型的对象添加到按钮组中。按钮组负责在新按钮被按下时，取消前一个被按下的按钮的选择状态。构造器的第二个参数为 true 表明这个按钮初始状态是被选择，其他按钮构造器的这个参数为 false。按钮组仅仅控制按钮的行为，如果想把这些按钮组织在一起布局， 需要把它们添加到容器中。</p>
<p>单选钮是圆形，选择以后圈内出现一个圆点。</p>
<p>当用户点击一个单选钮时， 这个按钮将产生一个动作事件。</p>
<p>不查询组内所有的按钮就知道哪个按钮被选择：ButtonGroup 类中有一个 getSelection 方法，返回附加在那个按钮上的模型 ButtonModel 的引用。ButtonModel 接 口getActionCommand 方法，返回动作命令，一个单选钮的“ 动作命令” 是它的文本标签，但是它的模型的动作命令是 null。只有在通过 setActionCommand 命令明确地为所有单选钮设定动作命令后， 才能够通过调用方法 buttonGroup.getSelection().getActionCommand() 获得当前选择的按钮的动作命令。</p>
<h5 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h5><p>如果在一个窗口中有多组单选按钮，就需要用可视化的形式指明哪些按钮属于同一组。Swing 提供了一组很有用的边框（ borders) 来解决这个问题。可以在任何继承了 JComponent的组件上应用边框。最常用的用途是在一个面板周围放置一个边框，然后用其他用户界面元素（如单选钮）填充面板。</p>
<p>步骤：</p>
<ol>
<li><p>调用 BorderFactory 的静态方法创建边框。下面是几种可选的风格:</p>
<ul>
<li><p>凹斜面（Lowered bevel）</p>
</li>
<li><p>凸斜面（Raised bevel）</p>
</li>
<li><p>蚀刻（Etched）</p>
</li>
<li><p>直 线（Line）</p>
</li>
<li><p>蒙版（Matte）</p>
</li>
<li><p>空（Empty）（只是在组件外围创建一些空白空间）</p>
</li>
</ul>
</li>
<li><p>可以给边框添加标题：BroderFactory.createTitledBorder。</p>
</li>
<li><p>可以调用下列方法将几种边框组合起来使用：BorderFactory.createCompoundBorder。</p>
</li>
<li><p>调用 JComponent 类中 setBorder 方法将结果边框添加到组件中。</p>
</li>
</ol>
<p>不同的边框有不同的用于设置边框的宽度和颜色的选项。</p>
<h5 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h5><p>如果有多个选择项， 使用单选按钮就不太适宜了， 其原因是占据的屏幕空间太大。这时就可以选择组合框。当用户点击这个组件时， 选择列表就会下拉出来， 用户可以从中选择一项。</p>
<p>如果下拉列表框被设置成可编辑 （setEditable 方法 ), 就可以像编辑文本一样编辑当前的选项内容。鉴于这个原因， 这种组件被称为组合框（ JComboBox )，它将文本域的灵活性与一组预定义的选项组合起来。</p>
<p>在 Java SE 7中，JComboBox 类是一个泛型类。</p>
<p>调用 getSelectedltem 方法获取当前的选项。对于可编辑组合框， 其中的选项可以是任何类型，这取决于编辑器（即由编辑器获取用户输人并将结果转换为一个对象)。如果你的组合框不是可编辑的， 最好调用：<br>combo.getltemAt(combo.getSelectedlndex());<br>这会为所选选项提供正确的类型。</p>
<p>可以调用 addltem 方法增加选项。这个方法将字符串添加到列表的尾部。可以利用 insertltemAt 方法在列表的任何位置插人一个新选项：<br>combo.insertltemAt(“Monospaced”, 0); // add at the beginning<br>可以增加任何类型的选项，组合框可以调用每个选项的 toString 方法显示其内容。</p>
<p>如果需要在运行时删除某些选项，可以使用 removeltem 或者 removeltemAt 方法。调用 removeAllltems 方法将立即移除所有的选项。</p>
<p>如果需要往组合框中添加大量的选项，需构造一个 DefaultComboBoxModel。</p>
<p>当用户从组合框中选择一个选项时，组合框就将产生一个动作事件。为了判断哪个选项被选择， 可以通过事件参数调用 getSource 方法来得到发送事件的组合框引用，接着调用getSelectedltem 方法获取当前选择的选项。需要把这个方法的返回值转化为相应的类型，通常是 String 型。</p>
<p>如果希望持久地显示列表， 而不是下拉列表， 就应该使用 JList 组件。</p>
<h5 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h5><p>滑动条允许进行连续值的选择。使用下列方式构造无格式滑动条：<br>JSlider slider = new JSlider(min, max, initialValue);<br>如果省略最小值、 最大值和初始值， 其默认值分别为 0、100 和 50。</p>
<p>构造无格式垂直滑动条：<br>JSlider slider = new JSIider(SwingConstants.VERTICAL, min, max , initialValue);</p>
<p>当用户滑动滑动条时， 滑动条的值就会在最小值和最大值之间变化。当值发生变化时， ChangeEvent 就会发送给所有变化的监听器。 为了得到这些改变的通知，需要调用 addChangeListener 方法并且安装一个实现了 ChangeListener 接口的对象。这个接口只有一个方法 StateChanged。在这个方法中，可以用方法获取滑动条的当前值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ChangeListener listener &#x3D; event -&gt; &#123;</span><br><span class="line">	JSlider slider &#x3D; (JSlider) event.getSource()；</span><br><span class="line">    int value &#x3D; slider.getValue();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以通过显示标尺（ tick ) 对滑动条进行修饰：<br>slider.setMajorTickSpacing(20);<br>slider.setMinorTickSpacing(5);<br>slider.setPaintTicks(true);<br>滑动条在每 20 个单位的位置显示一个大标尺标记，每 5 个单位的位置显示一个小标尺标记，然后显示出来。单位是指滑动条值， 而不是像素。大标尺和小标尺标记是相互独立的。</p>
<p>可以强制滑动条对齐标尺。这样一来，只要用户完成拖放滑动条的操作， 滑动条就会立即自动地移到最接近的标尺处：<br>slider.setSnapToTicks(true);</p>
<p>可以调用下列方法为大标尺添加标尺标记标签（tick mark labels）：<br>slider.setPaintLabels(true);<br>还可以提供其他形式的标尺标记， 如字符串或者图标。 首先需要填充一个键为 Integer 类型且值为 Component 类型的散列表。 然后再调用setLabelTable 方法，组件就会放置在标尺标记处。通常组件使用的是JLabel对象：<br>labelTable.put(0, new JLabel(“A”));<br>labelTable.put(20, new JLabel(“B”));<br>…<br>labelTable.put(100, new Jabel(“F”));<br>slider.setLabelTable(labelTable);</p>
<p>隐藏滑动条移动的轨迹：<br>slider.setPaintTrack(false);</p>
<p>使滑动条逆向：<br>slider.setInverted(true)</p>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>位于窗口顶部的菜单栏 （menubar ) 包括了下拉菜单的名字。点击一个名字就可以打开包含菜单项 （ menu items) 和子菜单（ submenus) 的菜单。 当用户点击菜单项时， 所有的菜单都会被关闭并且将一条消息发送给程序。</p>
<h5 id="菜单创建"><a href="#菜单创建" class="headerlink" title="菜单创建"></a>菜单创建</h5><p>首先要创建一个菜单栏：<br>JMenuBar menuBar = new JMenuBar();<br>通常放在框架的顶部：<br>frame.setJMenuBar(menuBar):<br>要为每个菜单建立一个菜单对象：<br>JMenu editMenu = new JMenu(“Edit”);<br>然后将顶层菜单添加到菜单栏中：<br>menuBar.add(editMenu);<br>向菜单对象中添加菜单项、分隔符和子菜单：<br>JMenuItem pasteltem = new JMenuItem(“Paste”)；<br>editMenu.add(pasteltem);<br>editMenu.addSeparator();<br>JMenu optionsMenu = . . .; // a submenu<br>editMenu.add(optionsMenu);</p>
<p>当用户选择菜单时，将触发一个动作事件。需要为每个菜单项安装一个动作监听器。</p>
<p>可以使用 JMenu.add(String s) 方法将菜单项插入到菜单的尾部：<br>editMenu.add(“Paste”);<br>add 方法返回创建的菜单项。</p>
<p>在通常情况下， 菜单项触发的命令也可以通过其他用户界面元素（如工具栏上的按钮）激活。</p>
<p>可在 AbstractAction 对象的构造器中指定菜单项标签并且覆盖 actionPerformed方法来获得菜单动作处理器。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Action exitAction &#x3D; new AbstractAction(&quot;Exit&quot;) &#123;</span><br><span class="line">	public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">		&#x2F;&#x2F; action code goes here</span><br><span class="line">		System.exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后将动作添加到菜单中：<br>JMenuItem exitltem = fileMenu.add(exitAction);<br>这个命令利用动作名将一个菜单项添加到菜单中。这个动作对象将作为它的监听器。这条语句是下面两条语句的快捷形式：<br>JMenuItem exitltem = new JMenuItem(exitAction);<br>fileMenu.add(exitltem);</p>
<h5 id="菜单项中的图标"><a href="#菜单项中的图标" class="headerlink" title="菜单项中的图标"></a>菜单项中的图标</h5><p>JMenuItem 类扩展了 AbstractButton 类。与按钮一样，菜单可以包含文本标签、 图标，也可以两者都包含。既可以利用 JMenuItem(String，Icon) 或者 JMenuItem(Icon) 构造器为菜单指定一个图标，也可以利用 JMenuItem 类中的 setlcon方法(继承自 AbstractButton 类）指定一个图标。</p>
<p>在默认情况下，菜单项的文本被放置在图标的右侧。如果喜欢将文本放置在左侧， 可以调用 JMenuItem类中的 setHorizontalTextPosition方法（继承自 AbstractButton 类）设置。</p>
<p>也可以将一个图标添加到一个动作上：<br>cutAction.putValue(Action.SMALL_ICON, new Imagelcon(“cut.gif”))；<br>当使用动作构造菜单项时，Action.NAME 值将会作为菜单项的文本，而 Action.SMALL_ICON 将会作为图标。</p>
<p>可以利用 AbstractAction 构造器设置图标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cutAction &#x3D; new AbstractAction(&quot;Cut&quot;, new ImageIcon(&quot;cut.gif&quot;)) &#123;</span><br><span class="line">	public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="复选框和单选钮菜单项"><a href="#复选框和单选钮菜单项" class="headerlink" title="复选框和单选钮菜单项"></a>复选框和单选钮菜单项</h5><p>复选框菜单项（JCheckBoxMenuItem）和单选钮菜单项（JRadioButtonMenuItem）在文本旁边显示了一个复选框或一个单选钮。当用户选择一个菜单项时，菜单项就会自动地在选择和未选择间进行切换。除了按钮装饰外，同其他菜单项的处理一样。单选钮菜单项与普通单选钮的工作方式一样， 必须将它们加人到按钮组中。</p>
<h5 id="弹出菜单"><a href="#弹出菜单" class="headerlink" title="弹出菜单"></a>弹出菜单</h5><p>弹出菜单（pop-up menu) 是不固定在菜单栏中随处浮动的菜单。弹出菜单没有标题：<br>JPopupMenu popup = new JPopupMenu();<br>然后用常规的方法添加菜单项。弹出菜单必须调用 show方法菜单才能显示出来。调用时需要给出父组件以及相对父组件坐标的显示位置：<br>popup.show(panel , x, y);</p>
<p>通常， 当用户点击某个鼠标键时弹出菜单。 这就是所谓的弹出式触发器（pop-up trigger）。 在 Windows 或者 Linux中， 弹出式触发器是鼠标右键。要想在用户点击某一个组件时弹出菜单， 需要按照下列方式调用方法：<br>component.setComponentPopupMenu(popup);</p>
<p>偶尔会遇到在一个含有弹出菜单的组件中放置一个组件的情况。这个子组件可以调用下列方法继承父组件的弹出菜单：<br>child.setInheritsPopupMenu(true);</p>
<h5 id="快捷键和加速器"><a href="#快捷键和加速器" class="headerlink" title="快捷键和加速器"></a>快捷键和加速器</h5><p>可以通过在菜单项的构造器中指定一个快捷字母来为菜单项设置快捷键：<br>JMenuItem aboutltem = new JMenuItem(“About”, ‘A’);<br>快捷键会自动地显示在菜单项中， 并带有一条下划线。</p>
<p>有时候不希望在菜单项的第一个快捷键字母下面加下划线。可以调用 setDisplayedMnemonicIndex 方法指定希望加下划线的字符。</p>
<p>如果有一个 Action 对象， 就可以把快捷键作为 Action. MNEMONIC_KEY 的键值添加到对象中：<br>cutAction.putValue(Action.MNEMONIC_KEY, new Integer(‘A’)))；</p>
<p>如果想为菜单设置快捷键， 需要调用 setMnemonic 方法：<br>JMenu helpMenu = new JMenu(“Help”);<br>helpMenu. setMnemonic(‘H’);<br>可以同时按下 ALT 键和菜单的快捷键来实现在菜单栏中选择一个顶层菜单的操作。</p>
<p>加速器是在不打开菜单的情况下选择菜单项的快捷键。可以使用 setAccelerator 将加速器键关联到一个菜单项上。这个方法使用 Keystroke 类型的对象作为参数：<br>openItem.setAccelerator(KeyStroke.getKeyStroke(“ctrl O”));</p>
<p>加速器只能关联到菜单项上， 不能关联到菜单上。加速器键并不实际打开菜单。它将直接地激活菜单关联的动作事件。当加速器添加到菜单项时， 对应的组合键就会自动地显示在相应的菜单上。</p>
<p>在 Windows 下，ALT+F4 用于关闭窗口。 但这不是 Java 程序设定的加速键。这是操作系统定义的快捷键。这个组合键总会触发活动窗口的 WindowClosing 事件， 而不管菜单上是否有 Close 菜单项。</p>
<h5 id="启用和禁用菜单项"><a href="#启用和禁用菜单项" class="headerlink" title="启用和禁用菜单项"></a>启用和禁用菜单项</h5><p>在有些时候， 某个特定的菜单项可能只能够在某种特定的环境下才可用。可以将这个菜单项设为禁用状态， 以便屏蔽掉这些暂时不适用的命令。被禁用的菜单项被显示为灰色，不能被选择它：<br>saveltem.setEnabled(false);</p>
<p>启用和禁用菜单项有两种策略：</p>
<ul>
<li>每次环境发生变化就对相关的菜单项或动作调用 setEnabled。</li>
<li>在显示菜单之前禁用这些菜单项。这里必须为“ 菜单选中” 事件注册监听器。javax.swing.event 包定义了 MenuListener 接口， 它包含三个方法：<br>void menuSelected(MenuEvent event)<br>void menuDeselected(MenuEvent event)<br>void menuCanceled(MenuEvent event)<br>由于在菜单显示之前调用 menuSelected 方法， 所以可以在这个方法中禁用或启用菜单项。</li>
</ul>
<p>在显示菜单之前禁用菜单项是一种明智的选择， 但这种方式不适用于带有加速键的菜单项。这是因为在按下加速键时并没有打开菜单， 因此动作没有被禁用， 致使加速键还会触发这个行为。</p>
<h5 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h5><p>工具栏是在程序中提供的快速访问常用命令的按钮栏。工具栏的特殊之处在于可以将它随处移动。 可以将它拖拽到框架的四个边框上。释放鼠标按钮后， 工具栏将会停靠在新的位置上。工具栏可以完全脱离框架。 这样的工具栏将包含在自己的框架中。当关闭包含工具栏的框架时， 它会冋到原始的框架中。</p>
<p>工具栏只有位于采用边框布局或者任何支持 North、 East、South 和 West 约束布局管理器的容器内才能够被拖拽。</p>
<p>创建工具栏：<br>JToolBar bar = new JToolBar();<br>可以将组件或Action对象添加（add方法）到工具栏中。<br>可以用分隔符将按钮分组：<br>bar.addSeparator()；<br>当工具栏没有停靠时，可以指定工具栏的标题：<br>bar = new JToolBar(titleString) ;<br>工具栏最初为水平的。如果想要将工具栏垂直放置， 可以使用下列代码：<br>bar = new JToolBar(SwingConstants.VERTICAL)<br>bar = new JToolBar(titleString, SwingConstants.VERTICAL)</p>
<h5 id="工具提示"><a href="#工具提示" class="headerlink" title="工具提示"></a>工具提示</h5><p>当光标停留在工具栏某个按钮上片刻时，工具提示就会被激活。工具提示文本显示在一个有颜色的矩形里。当用户移开鼠标时，工具提示就会自动地消失。</p>
<p>调用 setToolText 方法将工具提示添加到 Component 上：<br>exitButton.setToolTipText(“Exit”);</p>
<p>如果使用 Action 对象， 就可以用SHORT_DESCRIPTION 关联工具提示：<br>exitAction.putValue(Action.SHORT_DESCRIPTION , “Exit”);</p>
<h3 id="复杂的布局管理"><a href="#复杂的布局管理" class="headerlink" title="复杂的布局管理"></a>复杂的布局管理</h3><p>自从 Java 1.0 以来，AWT 就含有网格组布局（grid bag layout), 这种布局将组件按行和列排列。行和列的大小可以灵活改变， 并且组件可以横跨多行多列。这种布局管理器非常灵活，但也非常复杂。</p>
<p>在 2005 年， NetBeans 开发队伍发明了 Matisse 技术， 这种技术将布局工具与布局管理器结合起来。用户界面设计者可以使用工具将组件拖拽到容器中， 并指出组件的排列方式。工具将设计者的意图转换成组布局管理器的可以理解的指令，与手工地编写布局管理的代码相比，这样做要便捷得多。组布局管理器现在是 Java SE 6中的一部分。即使没有用 NetBeans作为 IDE, 也应该考虑使用它的 GUI 生成工具。可以用 NetBeans 设计 GUI, 然后再将得到的代码粘贴到所选择的 IDE 中。</p>
<h5 id="网格组布局"><a href="#网格组布局" class="headerlink" title="网格组布局"></a>网格组布局</h5><p>网格组布局是所有布局管理器之母。可以将网格组布局看成是没有任何限制的网格布局。在网格组布局中，行和列的尺寸可以改变。可以将相邻的单元合并以适应较大的组件。组件不需要填充整个单元格区域， 并可以指定它们在单元格内的对齐方式。</p>
<p>要想使用网格组管理器进行布局， 必须经过下列过程：</p>
<ol>
<li>建立一个 GridBagLayout 的对象。不需要指定网格的行数和列数。布局管理器会根据后面所给的信息猜测出来。</li>
<li>将 GridBagLayout 对象设置成组件的布局管理器。</li>
<li>为每个组件建立一个 GridBagConstraints 对象。设置 GridBagConstraints 对象的域以便指出组件在网格组中的布局方案。</li>
<li>最后，通过下面的调用添加组件的约束：<br>add(component, constraints )；</li>
</ol>
<p>设置 GridBagConstraints 对象的状态:</p>
<ul>
<li>gridx、gridy、gridwidth 和 gridheight 参数：这些约束定义了组件在网格中的位置。gridx 和 gridy 指定了被添加组件左上角的行、列位置。gridwidth 和 gridheight 指定了组件占据的行数和列数。网格的坐标从 0 开始。gridx=0 和 gridy=0 代表最左上角。</li>
<li>增量域：在网格布局中，需要为每个区域设置增量域（weightx 和 weighty)。如果将增量设置为0, 则这个区域将永远为初始尺寸。如果将所有区域的增量都设置为 0, 容器就会集聚在为它分配的区域中间， 而不是通过拉伸来填充它。增量并不实际给出列的相对大小。当容器超过首选大小时， 增量表示分配给每个区域的扩展比例值。</li>
<li>fill 和 anchor 参数：如果不希望组件拉伸至整个区域， 就需要设置 fill 约束。它有四个有效值——GridBagConstraints.NONE、 GridBagConstraints.HORIZONTAL、GridBagConstraints. VERTICAL 和GridBagConstraints.BOTH。如 果 组 件 没 有 填 充 整 个 区 域， 可 以 通 过 设 置 anchor 域 指 定 其 位 置。 有 效 值 为GridBagConstraints.CENTER ( 默 认 值 ）、GridBagConstraints.NORTH、 GridBagConstraints.NORTHEAST 和 GridBagConstraints.EAST 等。</li>
<li>填充：可以通过设置 GridBagLayout 的 insets 域在组件周围增加附加的空白区域。通过设置 Insets 对象的 left、top、right 和 bottom 指定组件周围的空间量。这被称作外部填充（或外边距 )<br>( external padding。)通过设置 ipadx 和 ipady 指定内部填充（或内外距)( internal padding )。这两个值被加到组件的最小宽度和最小高度上。这样可以保证组件不会收缩至最小尺寸之下。</li>
<li>指定 gridx, gridy, gridwidth 和 gridheight 参數的另一种方法：AWT 文档建议不要将 gridx 和 gridy 设置为绝对位置，应该将它们设置为常量 GridBagConstraints.RELATIVE。 然后，按照标准的顺序，将组件添加到网格组布局中。即第一行从左向右，然后再开始新的一行，以此类推。还需要通过为 gridheight 和 gridwidth 域指定一个适当的值来设置组件横跨的行数和列数。除此之外，如果组件扩展至最后一行或最后一列，则不要给出一个实际的数值， 而是用常量 GridBagConstraints.REMAINDER 替代，这样会告诉布局管理器这个组件是本行上的最后一个组件。这种方案看起来能起作用，但似乎显得有点笨拙。这是因为这样做会将实际位置信息对布局管理器隐藏起来，而日后又希望它能够重新发现这些信息。</li>
<li>使用帮助类来管理网格组约束：网格组布局最乏味的工作就是为设置约束编写代码。为此，很多程序员编写帮助函数或者帮助类来满足上面的目的。</li>
</ul>
<p>下面的策略可以让网格组布局的使用相对简单一些：</p>
<ol>
<li>在纸上画出组件布局草图。</li>
<li>找出一种网格， 小组件被放置在一个单元格内，大组件将横跨多个单元格。</li>
<li>用 0, 1 , 2 标识网格的行和列。现在可以读取 gridx, gridy, gridwidth 和 gridheight的值。</li>
<li>对于每个组件，需要考虑下列问题： 是否需要水平或者垂直填充它所在的单元格？ 如果不需要， 希望如何排列？ 这些就是 fill 和 anchor 参数的设置。</li>
<li>将所有的增量设置为 100。如果需要某行或某列始终保持默认的大小， 就将这行或这列中所有组件的 weightx 和 weighty 设置为 0。</li>
<li>编写代码。仔细地检查 GridBagConstraints 的设置。错误的约束可能会破坏整个布局。</li>
<li>编译、运行。</li>
</ol>
<h5 id="组布局"><a href="#组布局" class="headerlink" title="组布局"></a>组布局</h5><p>可以通过将组件放人 GroupLyout.SequentialGroup 或者 GroupLayout.ParallelGroup 对象中将它们组织起来。这些类是 GroupLayout.Group 的子类。在组中可以包含组件、 间距和内嵌的组。由于组类中的各种 add 方法都返回组对象， 因此可以将方法调用串联在一起。</p>
<p>组布局分别对水平和垂直布局进行计算。为了能够看到水平计算的效果， 假设组件都被压平了， 因此高度为 0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.addCroup(layout.createSequentialCroup()</span><br><span class="line">    .addContainerCap()</span><br><span class="line">	.addCroup(layout.createParallelCroup(GroupLayout.Alignment.LEADING)</span><br><span class="line">		.addComponent(jLabel1, GroupLayout.Alignment.TRAILING)</span><br><span class="line">		.addComponent(jLabel2, GroupLayout.A1ignment.TRAILING))</span><br><span class="line">	.addPreferredCap(LayoutStyle.ComponentPlacement.RELATED)</span><br><span class="line">	.addGroup(layout.createParallelCroup(CroupLayout.Alignment.LEADING)</span><br><span class="line">		.addComponent(jTextFieldl)</span><br><span class="line">		.addComponent(jPasswordFieldl))</span><br></pre></td></tr></table></figure>
<p>为了能够看到垂直计算的效果， 假设组件都被压扁了， 因此宽度为 0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout.createSequentialGroup()</span><br><span class="line">	.addContainerCap()</span><br><span class="line">	.addGroup(layout.createParailelCroup(CroupLayout.Alignment.BASELINE)</span><br><span class="line">		.addComponent(jLabel1)</span><br><span class="line">		.addComponent(jTextFieldl))</span><br><span class="line">	.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)</span><br><span class="line">	.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)</span><br><span class="line">		.addComponent(jLabel2)</span><br><span class="line">		.addComponent(jPasswordFieldl))</span><br></pre></td></tr></table></figure>
<h5 id="不使用布局管理器"><a href="#不使用布局管理器" class="headerlink" title="不使用布局管理器"></a>不使用布局管理器</h5><p>有时候用户可能不想使用任何布局管理器， 而只想把组件放在一个固定的位置上（通常称为绝对定位)。</p>
<p>下面是将一个组件定位到某个绝对定位的步骤：</p>
<ol>
<li>将布局管理器设置为 null。</li>
<li>将组件添加到容器中。</li>
<li>指定想要放置的位置和大小。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.setLayout(null);</span><br><span class="line">JButton ok &#x3D; new JButton(&quot;OK&quot;)；</span><br><span class="line">frame.add(ok);</span><br><span class="line">ok.setBounds(1O, 10, 30, 15);</span><br></pre></td></tr></table></figure>
<h5 id="定制布局管理器"><a href="#定制布局管理器" class="headerlink" title="定制布局管理器"></a>定制布局管理器</h5><p>可以通过自己设计 LayoutManager 类来实现特殊的布局方式。定制布局管理器必须实现 LayoutManager接口。</p>
<p>AWT 还有第二个接口 LayoutManager2。这个接口的主要特点是允许用户使用带有约束的 add 方法。例如， BorderLayout 和 GridBagLayout 都实现了 LayoutManager2 接口。</p>
<h5 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h5><p>当把很多组件添加到窗口中时， 需要考虑遍历顺序（ traversal order) 的问题。窗口被初次显示时，遍历序列的第一个组件会有键盘焦点。每次用户按下 TAB 键， 下一个组件就会获得焦点。</p>
<p>遍历顺序很直观，它的顺序是从左至右，从上至下。当焦点给予另外一个容器时，那个容器左上角的组件就会自动地获得焦点，然后再遍历那个容器中的所有组件。最后，将焦点移交给紧跟着那个容器的组件。</p>
<p>调用 component.setFocusable(false); 可以从焦点遍历中删除一个组件。</p>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>AWT 也分为模式对话框和无模式对话框。所谓模式对话框是指在结束对它的处理之前， 不允许用户与应用程序的其余窗口进行交互。所谓无模式对话框是指允许用户同时在对话框和应用程序的其他窗口中输入信息。</p>
<h5 id="选项对话框"><a href="#选项对话框" class="headerlink" title="选项对话框"></a>选项对话框</h5><p>Swing 有一套简单的对话框， 用于获取用户的一些简单信息。JOptionPane 有 4 个用于显示这些对话框的静态方法：</p>
<ul>
<li><p>showMessageDialog: 显示一条消息并等待用户点击 OK</p>
</li>
<li><p>showConfirmDialog: 显示一条消息并等待用户确认（与 OK/Cancel 类似）</p>
</li>
<li><p>showOptionDialog: 显示一条消息并获得用户在一组选项中的选择</p>
</li>
<li><p>showInputDialog: 显示一条消息并获得用户输人的一行文本。文本域或组合框。</p>
</li>
</ul>
<p>这些对话框的确切布局和为标准消息类型选择的图标都取决于具体的观感。</p>
<p>左侧的图标将由下面 5 种消息类型决定：<br>ERROR.MESSAGE<br>INFORMATION_MESSAGE<br>WARNING_MESSAGE<br>QUESTION_MESSAGE<br>PLAIN_MESSAGE<br>PLAIN_MESSAGE 类型没有图标。每个对话框类型都有一个方法，可以用来提供自己的图标， 以替代原来的图标。</p>
<p>可以为每个对话框类型指定一条消息。 下面是显示消息对象的基本方式:<br>String: 绘制字符串<br>Icon：显示图标<br>Component：显示组件<br>Object[]: 显示数组中的所有对象， 依次叠加<br>任何其他对象： 调用 toString 方法来显示结果字符串<br>消息字符串中可以包含换行符 （’\n’)。</p>
<p>位于底部的按钮取决于对话框类型和选项类型。当调用 showMessageDialog 和 showInputDialog 时，只能看到一组标准按钮（分别是 OK/Cancel)。当调用 showConfirmDialog时， 可以选择下面四种选项类型之一：<br>DEFAULT_0PTI0N<br>YES_NO_OPTION<br>YES_N0_CANCEL_0PTI0N<br>OK_CANCEL_OPTION<br>使用 showOptionDialog 可以指定任意的选项。这里需要为选项提供一个对象数组。每个数组元素可以是下列类型之一：<br>String： 使用字符串标签创建一个按钮<br>Icon： 使用图标创建一个按钮<br>Component： 显示这个组件<br>其他类型的对象：使用 toString 方法，然后用结果字符串作为标签创建按钮</p>
<p>下面是这些方法的返回值：<br>showMessageDialog 无<br>showConfirmDialog 表示被选项的一个整数<br>showOptionDialog 表示被选项的一个整数<br>showInputDialog 用户选择或输入的字符串<br>用户没有选择可选项， 而是关闭了对话框，返回值为CLOSED_OPTION。</p>
<h5 id="创建对话框"><a href="#创建对话框" class="headerlink" title="创建对话框"></a>创建对话框</h5><p>要想实现一个对话框，需要从 JDialog 派生一个类。具体过程如下：</p>
<ol>
<li>在对话框构造器中，调用超类 JDialog 的构造器。在调用超类构造器时，需要提供拥有者框架（ownerframe、) 对话框标题及模式特征。拥有者框架控制对话框的显示位置，如果将拥有者标识为 null, 那么对话框将由一个隐藏框架所拥有。模式特征将指定对话框处于显示状态时，应用程序中其他窗口是否被锁住。</li>
<li>添加对话框的用户界面组件。</li>
<li>添加事件处理器。</li>
<li>设置对话框的大小。</li>
</ol>
<p>在 Java SE 6 中， 有个额外的模式特征类型——文档 -模式对话框。</p>
<p>要想显示对话框， 需要建立一个新的对话框对象， 并让它可见：<br>JDialog dialog = new AboutDialog(this);<br>dialog.setVisible(true);</p>
<h5 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h5><p>对话框应该提供设置默认数据的方法。</p>
<p>对于模式对话框。调用 setVisible(true) 阻塞。希望知道用户是接收对话框， 还是取消对话框。可设置了 OK 标志， 在对话框显示之前是 false。只有 OK 按钮的事件处理器可以将它设置为 true。这样， 就可以获得对话框中的用户输入。</p>
<p>无模式对话框数据传输就没有那么简单了。当无模式对话框显示时， 调用 setVisible(true) 并不阻塞， 在对话框显示时， 其他程序仍继续运行。如果用户选择了无模式对话框中的一项， 并点击 OK , 对话框就会将一个事件发送给程序中的某个监听器。</p>
<p>在构造一个 JDialog 对象时，需要指定拥有者框架。但是， 在很多情况下，一个对话框可能会有多个拥有者框架，所以最好在准备显示对话框时再确定拥有者框架。</p>
<p>有时， 拥有者框架并不总是可用的。利用任意的 parent 组件可以很容易地得到它：<br>owner = (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);</p>
<p>很多对话框都有默认按钮。 如果用户按下一个触发器键（在大多数“ 观感” 实现中是 ENTER) 就自动地选择了它。默认按钮通常用加粗的轮廓给予特别标识。可以在对话框的根窗格（root pane ) 中设置默认按钮：<br>dialog.getRootPane().setDefaultButton(okButton);</p>
<h5 id="文件对话框"><a href="#文件对话框" class="headerlink" title="文件对话框"></a>文件对话框</h5><p>Swing中提供了 JFileChooser 类，它可以显示一个文件对话框， 其外观与本地应用程序中使用的文件对话框基本一样。JFileChooser 是一个模式对话框。调用 showOpenDialog显示打开文件的对话框，调用 showSaveDialog 显示保存文件的对话框。接收文件的按钮被自动地标签为 Open 或者 Save。调用 showDialog 方法为按钮设定标签。</p>
<p>建立文件对话框并且获取用户选择信息的步骤：</p>
<ol>
<li>建立一个 JFileChooser 对象。允许在多个框架中重用一个文件选择器。重用一个文件选择器对象是一个很好的想法，其原因是 JFileChooser 的构造器相当耗费时间。</li>
<li>调用 setCurrentDirectory 方法设置当前目录。需要提供一个 File 对象。构造器 File (String fileName ) 能够将一个文件或目录名转化为一个 File 对象。</li>
<li>如果有一个想要作为用户选择的默认文件名， 可以使用 setSelectedFile 方法进行指定。</li>
<li>如果允许用户在对话框中选择多个文件，需要调用 setMultiSelectionEnabled 方法。</li>
<li>如果想让对话框仅显示某一种类型的文件，需要设置文件过滤器（setFileFilter 方法）。需要创建一个实现了抽象类javax.swing.filechooser.FileFilter 的对象。文件选择器将每个文件传递给文件过滤器， 只有文件过滤器接受的文件才被最终显示出来。有两个子类可用：可以接受所有文件的默认过滤器和可以接受给定扩展名的所有文件的过滤器（FileNameExtensionFilter）。设计专用文件过滤器只要实现 FileFilter 超类中的两个方法即可：<br>public boolean accept(File f);<br>public String getDescription();<br>第一个方法检测是否应该接受一个文件，第二个方法返回显示在文件选择器对话框中显示的文件类型的描述信息。可以为一个文件选择器安装多个过滤器。用户可以从文件对话框底部的组合框中选择过滤器。在默认情况下， All files 过滤器总是显示在组合框中。如果你想禁用 All files 过滤器，需要调用：chooser.setAcceptAllFileFilterUsed(false); 如果为加载和保存不同类型的文件重用一个文件选择器， 就需要调用：chooser.resetChoosableFilters(); 这样可以在添加新文件过滤器之前清除旧文件过滤器。</li>
<li>如果希望选择目录，需要调用setFileSelectionMode 方法。 参数值为：JFileChooser.FILES_ONLY ( 默认值）， JFileChooser.DIRECTORIES_ONLY 或者 JFileChooser.FILES_AND_DIRECTORIES。</li>
<li>调用 showOpenDialog 或者 showSaveDialog 方法显示对话框。必须为这些调用提供父组件。返回值可以是 JFileChooser.APPROVE_OPTION、 JFileChooser.CANCEL_OPTION 或者 JFileChooser.ERROR_OPTION。</li>
<li>调 用 getSelectedFile() 或者 getSelectedFiles() 方法获取用户选择的一个或多个文件。这些方法将返回一个文件对象或者一组文件对象。 如果需要知道文件对象名时，可以调用 getPath方法。</li>
</ol>
<p>可以通过为文件选择器显示的每个文件提供特定的图标和文件描述来定制文件选择器。这需要应用一个扩展于 javax.swing.filechooser 包中的 FileView 类的对象。然后，调用 setFileView 方法将文件视图安装到文件选择器中。文件选择器为每个希望显示的文件或目录调用这些方法。如果方法返回的图标、名字或描述信息为 null, 那么文件选择器将会构造当前观感的默认文件视图。这样处理很好，其原因是这样只需处理具有不同显示的文件类型。文件选择器调用 isTraversable 方法来决定是否在用户点击一个目录的时候打开这个目录。</p>
<p>可以通过添加一个附件组件来定制文件对话框。附件可以是任何 Swing组件。</p>
<h5 id="颜色选择器"><a href="#颜色选择器" class="headerlink" title="颜色选择器"></a>颜色选择器</h5><p>Swing提供了一种颜色选择器—JColorChooser。颜色选择器是一个组件， 它包含了用于创建包含颜色选择器组件的对话框方法。</p>
<p>何利用颜色选择器显示模式对话框:<br>Color selectedColor = JColorChooser.showDialog(parent,titl e, initialColor);<br>也可以显示无模式颜色选择器对话框， 需要提供：一个父组件、对话框的标题、选择模式 / 无模式对话框的标志、颜色选择器、0K 和 Cancel 按钮的监听器（如果不需要监听器可以设置为 null)。</p>
<p>如果想要监视颜色的选择，那就需要获得选择器的选择模型并添加改变监听器，这会将颜色选择立即反馈给用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chooser.getSelectionModel().addChangeListener(event -&gt; &#123;</span><br><span class="line">	do something with chooser.getColor();</span><br><span class="line">&#125;；)</span><br></pre></td></tr></table></figure>
<h3 id="GUI-程序排错"><a href="#GUI-程序排错" class="headerlink" title="GUI 程序排错"></a>GUI 程序排错</h3><h5 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h5><p>按下 Ctrl+Shift+F1 得到所有Swing组件的层次结构输出。</p>
<p>可以使用 JComponent 类的 setDebugGraphicsOptions 方法打开对一个 Swing 组件的调试。有以下几个选项：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DebugGraphics.FLASH_OPTION</td>
<td>绘制前用红色闪烁地显示各条线、 矩形和文本</td>
</tr>
<tr>
<td>DebugGraphics.LOG_OPTION</td>
<td>为每个绘制操作打印一个消息</td>
</tr>
<tr>
<td>DebugGraphics.BUFFERED_OPTION</td>
<td>显示在离屏缓冲区完成的操作</td>
</tr>
<tr>
<td>DebugGraphics.NONE_OPTION</td>
<td>关闭图形调试</td>
</tr>
</tbody></table>
<p>要让闪烁选项起作用， 必须禁用“ 双缓冲”——这是 Swing 更新窗口时为减少闪烁所用的策略：<br>RepaintManager.currentManager(getRootPane()).setDoubleBufferingEnabled(false);<br>((JComponent) getContentPane()).setDebugCraphicsOptions(DebugCraphics.FLASH_OPTION);<br>只需要把这些代码行放在 feme 窗口构造器的末尾。程序运行时， 你将看到会用慢动作填充内容窗格。</p>
<p>如果希望得到 GUI 应用中生成的每一个 AWT 事件的记录， 可以在发出事件的每一个组件中安装一个监听器。利用反射， 可以很容易地自动完成这个工作。</p>
<h5 id="让-AWT-机器人完成工作"><a href="#让-AWT-机器人完成工作" class="headerlink" title="让 AWT 机器人完成工作"></a>让 AWT 机器人完成工作</h5><p>Robot 类可以向任何 AWT 程序发送按键和鼠标点击事件。这个类就是用来自动测试用户界面的。</p>
<p>要得到一个机器人，首先需要得到一个 GraphicsDevice 对象：<br>CraphicsEnvironment environment = CraphicsEnvironment.getlocalCraphicsEnvironment();<br>CraphicsDevice screen = environinent.getDefaultScreenDevice():<br>然后构造一个机器人：<br>Robot robot = new Robot(screen);<br>若要发送一个按键事件， 需告知机器人模拟按下和松开按键:<br>robot.keyPress(KeyEvent.VK_TAB):<br>robot.keyRelease(KeyEvent.VK_TAB);<br>对于鼠标点击事件，首先需要移动鼠标， 然后按下再释放鼠标按钮:<br>robot.mouseMove(x, y); // x and y are absolute screen pixel coordinates,<br>robot.nousePress(InputEvent.BUTTON1_MASK);<br>robot.mouseRelease(InputEvent.BUTTON1_MASK);<br>首先模拟按键和鼠标输入， 然后截屏来查看应用是否完成了它该完成的工作。截屏需要使用 createScreenCapture 方法：<br>Rectangle rect = new Rectangle(x, y, width, height);<br>Bufferedlmage image = robot.createScreenCapture(rect):<br>通常我们都希望在机器人指令之间增加一个很小的延迟，使应用能跟得上。可以使用 delay 方法并提供延迟时间（毫秒数) ：<br>robot.delay(1000); </p>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeBSD</title>
    <url>/2020/11/17/FreeBSD/</url>
    <content><![CDATA[<blockquote><p>FreeBSD 計劃的目標在於提供可作任意用途的軟體而不附帶任何限制條文。 我們之中許多人對程式碼 (以及計畫本身) 都有非常大的投入， 因此，當然不介意偶爾有一些資金上的補償，但我們並沒打算堅決地要求得到這類資助。 我們認為我們的首要“使命”是為任何人提供程式碼， 不管他們打算用這些程式碼做什麼， 因為這樣程式碼將能夠被更廣泛地使用，從而發揮其價值。 我認為這是自由軟體最基本的，同時也是我們所倡導的一個目標。</p>
<p>我們程式碼樹中，有若干是以 GNU 通用公共授權條款 (GPL) 或者 GNU 較寬鬆通用公共授權條款 (LGPL) 發佈的那些程式碼帶有少許的附加限制，還好只是強制性的要求開放程式碼而不是別的。 由於使用 GPL 的軟體在商業用途上會增加若干複雜性，因此，如果可以選擇的話， 我們會比較喜歡使用限制相對更寬鬆的 BSD 版權來發佈軟體。</p>
<footer><strong>Jordan Hubbard</strong><cite><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvZG9jL3poX1RXL2Jvb2tzL2hhbmRib29rLw==">FreeBSD Handbook<i class="fa fa-external-link-alt"></i></span></cite></footer></blockquote>

<a id="more"></a>

<h3 id="Install-FreeBSD"><a href="#Install-FreeBSD" class="headerlink" title="Install FreeBSD"></a>Install FreeBSD</h3><h5 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h5><p>Disable unused and unwanted options.</p>
<h5 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h5><ul>
<li><p>To put the image on the pendrive we will use the dd tool available on almost any Mac OS X (macOS) and Linux system. For Windows You will have to download it from here – <span class="exturl" data-url="aHR0cDovL3d3dy5jaHJ5c29jb21lLm5ldC9kZA==">dd for windows<i class="fa fa-external-link-alt"></i></span>( bs=1M on Linux/Windows ).（可用 Rufus 替代）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dd if=FreeBSD-11.1-RELEASE-amd64-memstick.img of=/dev/da1 bs=1m</span><br></pre></td></tr></table></figure></li>
<li><p>When we have a new machine there is always a problem with new name for it. The RFC 1178 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzExNzg=">Choosing a Name for Your Computer<i class="fa fa-external-link-alt"></i></span> from 1990 year tries to address that issue </p>
</li>
</ul>
<ul>
<li>We will use ZFS because we want to use Boot Environments with sysutils/beadm port.<ul>
<li>Hit [ENTER] on the <code>Pool Type/Disks</code> to select target disk to install FreeBSD on.</li>
<li>Now (in FreeBSD 12.x) it is possible to install FreeBSD on GELI encrypted root on ZFS pool without any additional partitions or filesystems. You need to select is <code>Yes</code> for the <code>Encryption</code> part .</li>
<li>I advice using <code>GPT (BIOS+UEFI)</code> as it will support both system types so when you are running BIOS system now and will move the disk to other system that boots with UEFI it will also just work out of the box.</li>
<li>We will set SWAP size to <code>0</code> (no SWAP) as it will not be needed. If we will need SWAP in the future, then we will create ZVOL on ZFS and use it as a SWAP device.</li>
</ul>
</li>
</ul>
<img data-src="/2020/11/17/FreeBSD/freebsd-install-03.png" class="" title="FreeBSD">

<ul>
<li>Select services as shown below.</li>
</ul>
<img data-src="/2020/11/17/FreeBSD/freebsd-11-1-laptop-install-23.png" class="" title="FreeBSD">

<ul>
<li>Enable all security hardening features as shown below.</li>
</ul>
<img data-src="/2020/11/17/FreeBSD/freebsd-11-1-laptop-install-24.png" class="" title="FreeBSD">

<h3 id="X11-Window-System"><a href="#X11-Window-System" class="headerlink" title="X11 Window System"></a>X11 Window System</h3><p>X 最初設計是以網路為中心，採用 “client-server” 架構。在此架構下 “X 伺服器” 在有鍵盤、螢幕、滑鼠的電腦上運作。該伺服器負責的工作包含管理顯示、處理來自鍵盤、滑鼠的輸入及來自其他設備)的輸入或輸出。</p>
<p>每個 X 應用程式，如 XTerm、Firefox 都是 “客戶端”。</p>
<p>視窗管理程式規定螢幕上的視窗該長什麼樣、要如何移動滑鼠指標、 要用什麼鍵來在視窗切換、每個視窗的標題列長相，及是否該有關閉按鈕，等等。視窗管理程式負責滑鼠指標的聚焦政策。 聚焦政策指的是如何決定使用中及接收鍵盤輸入的視窗。通常較為人熟悉的聚焦政策叫做 “click-to-focus”，這個模式中，滑鼠點選到的視窗便會處於作用中 (Active) 的狀態。</p>
<p>KDE 與 GNOME 會被稱作桌面環境是因為包含了完整常用桌面作業的應用程式。</p>
<h5 id="BIOS-or-UEFI"><a href="#BIOS-or-UEFI" class="headerlink" title="BIOS or UEFI"></a>BIOS or UEFI</h5><p>If you find a device that is not supported by any ‘accelerated’driver like <code>intel</code> or <code>nvidia</code>. You would use <code>vesa</code> driver (Video Electronics Standards Association) while booting in BIOS mode and You will use <code>scfb</code> driver (System Console Frame Buffer) while booting on UEFI mode. This can be checked by </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl machdep.bootmethod</span><br></pre></td></tr></table></figure>
<h5 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install xorg</span><br></pre></td></tr></table></figure>
<h5 id="Xorg-Configuration"><a href="#Xorg-Configuration" class="headerlink" title="Xorg Configuration"></a>Xorg Configuration</h5><ul>
<li><p>顯示卡、顯示器以及輸入裝置會自動偵測，無須任何手動設置。除非自動設置失敗，否則請勿建立 xorg.conf 或執行 -configure 步驟。</p>
</li>
<li><p>加入要執行 Xorg 的使用者到 <code>video</code> 或 <code>wheel</code> 群組，以便在可用時能開啟 3D 加速。要加入使用者 <em><code>jru</code></em> 到任一個可用的群組：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pw groupmod video -m jru || pw groupmod wheel -m jru</span><br></pre></td></tr></table></figure></li>
<li><p>Login Class(可解决中文乱码，powershell 字符显示方形)</p>
<p>  Add this login class to the <code>/etc/login.conf</code> file.</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">video:\</span><br><span class="line">        :charset=UTF-8:\</span><br><span class="line">        :lang=en_US.UTF-8:\</span><br><span class="line">        :tc=default:</span><br></pre></td></tr></table></figure>
<p>  Rebuild the login class database.</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cap_mkdb /etc/login.conf</span><br></pre></td></tr></table></figure>
<p>  Lets set the login class to video for the vuk user.</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pw usermod -L video -n vuk</span><br></pre></td></tr></table></figure>
<p>  How the account looks after setting the login class.</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep vuk /etc/master.passwd</span><br><span class="line">vuk:&#123;REMOVED&#125;:1000:1000:video:0:0:vuk:/home/vuk:/bin/sh</span><br></pre></td></tr></table></figure>
<p>  Now logout and login again to make that work. View the changes through the <code>locale</code> command.</p>
</li>
<li><p>显卡驱动：使用多檔，每一個檔案只設定一個指定項目會較傳統使用單一 <code>/etc/X11/xorg.conf</code> 設定來的簡單。完整路徑為 <code>/usr/local/etc/X11/xorg.conf.d/</code>。（安装 intel 显卡驱动与 nvidia 驱动难，scfb 与 vesa 驱动无法调整分辨率）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/local/etc/X11/xorg.conf.d/driver-intel.conf</span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier &quot;Card0&quot;</span><br><span class="line">    Driver     &quot;scfb&quot;</span><br><span class="line">    BusID    &quot;PCI:0:2:0&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<p>  若有多張顯示卡，可取消註解 <code>BusID</code> identifier 然後設定為想要的顯示卡，顯示卡的 Bus ID 清單可以使用 <code>pciconf -lv | grep -B3 display</code> 取得。</p>
</li>
<li><p>手動設定</p>
<ul>
<li><p>設定檔可由 Xorg 根據偵測到的硬體產生，這個檔案對一開始自訂設定很有幫助。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xorg -configure</span><br></pre></td></tr></table></figure></li>
<li><p>設定檔會儲存至 <code>/root/xorg.conf.new</code>，做任何需要的更改，然後使用以下指令測試該檔案：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Xorg -config /root/xorg.conf.new</span><br></pre></td></tr></table></figure>

<p>  在新設定檔調整與測試過後，便可分開成較小的檔案放置到正常的位置 <code>/usr/local/etc/X11/xorg.conf.d/</code>。</p>
</li>
</ul>
</li>
</ul>
<h5 id="Install-Desktop-Enviroment"><a href="#Install-Desktop-Enviroment" class="headerlink" title="Install Desktop Enviroment"></a>Install Desktop Enviroment</h5><ul>
<li><p>FreeBSD 桌面发行版</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2hvc3Ric2Qub3JnLw==">GhostBSD<i class="fa fa-external-link-alt"></i></span> 是 FreeBSD 桌面发行版，注意使用 Official 版本，不能直接使用 FreeBSD 源升级。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub21hZGJzZC5vcmcv">nomadbsd<i class="fa fa-external-link-alt"></i></span> 是个非常漂亮的 FreeBSD 桌面发行版 ，德国产。</li>
<li>可以在虚拟机里面安装 FreeBSD 桌面发行版，然后找到自己想用的桌面工具，再定制自己的 FreeBSD 桌面。</li>
</ul>
</li>
<li><p>Install Desktop Environment</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install gnome3</span><br><span class="line">sudo pkg install gnome3-lite</span><br><span class="line">sudo pkg install x11/kde5</span><br><span class="line">sudo pkg install xfce</span><br><span class="line">sudo pkg install mate</span><br></pre></td></tr></table></figure></li>
<li><p>Install/Enable Display Manager: You have to decide how You want to start your X11 Window Server, you may login in plan text console and then type <code>xinit</code> or <code>startx</code> to read your <code>~/.xinitrc</code> configuration and daemons (The difference between <code>xinit</code> and <code>startx</code> is that <code>startx</code> command executes <code>xinit</code> command with arguments.) or You may want to use X11 Login manager such as <code>xdm/sddm/slim</code> with <code>~/.xsession</code> configuration to load after successful login. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install xdm</span><br><span class="line">sudo pkg install slim			# xfce,mate，slim 有个 slim-themes 软件包</span><br><span class="line">sudo pkg install x11/sddm		# kde</span><br></pre></td></tr></table></figure>
<p>While <code>xinit</code> run commands based on the <code>~/.xinitrc</code> file the XDM login manager looks for the <code>~/.xsession</code> file. As You will be loading same stuff regardless of the startup method we will create a link of <code>~/.xsession</code> pointing to the <code>~/.xinitrc</code> file. This way either method You choose You will always end with started X11 session.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s ~/.xinitrc ~/.xsession</span><br></pre></td></tr></table></figure>
<p>One more case about the <code>~/.xinitrc</code> (or <code>~/.xsession</code>) file. It is interpreted as a shell script (and yes you can do <code>if/then/else/fi</code> and <code>case/esac</code> or <code>for/while</code> POSIX shell scripting in it) but it does not need to be executable. The last command in this file MUST NOT to be put in the background (must be without the <code>&amp;</code> char at the end) because the X11 session will end.</p>
</li>
<li><p>Setting</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/ttys		# xdm</span><br><span class="line">ttyv8   &quot;/usr/local/bin/xdm -nodaemon&quot;  xterm  on secure</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/fstab		# gnome, kde</span><br><span class="line">proc           /proc       procfs  rw  0   0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/rc.conf</span><br><span class="line">moused_enalbe=&quot;YES&quot;</span><br><span class="line">dbus_enable=&quot;YES&quot;		# gnome, kde, xfce</span><br><span class="line">hald_enable=&quot;YES&quot;		# gnome, kde, mate</span><br><span class="line">gdm_enalbe=&quot;YES&quot;		# gnome 启动</span><br><span class="line">sddm_enable=&quot;YES&quot;		# kde 启动</span><br><span class="line">slim_enable=&quot;YES&quot;		# xfce,mate</span><br><span class="line">gnome_enable=&quot;YES&quot;		# gnome 服务</span><br></pre></td></tr></table></figure></li>
<li><p>slim Usage(Failed to execute login command)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.xinitrc</span><br><span class="line">exec mate-session		# mate</span><br><span class="line">exec xfce4-session		# xfce</span><br></pre></td></tr></table></figure>
<h5 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h5></li>
<li><p>Window Manager: <span class="exturl" data-url="aHR0cDovL29wZW5ib3gub3JnL3dpa2kvTWFpbl9QYWdl">Openbox<i class="fa fa-external-link-alt"></i></span>…</p>
</li>
<li><p>Status Bar: Also known as information bar, the place on the screen that would provide You needed information such as current date and time, CPU, RAM and storage usage, current network information or battery status.</p>
<ul>
<li><p>While <code>Xmobar</code> is nice solution it comes with about 2 GB of dependencies of Haskell and Haskell libraries.</p>
</li>
<li><p>While <code>Polybar</code> can look very nice on screenshots it is a lot more heavy on resources and is limited only to modules/features that were implemented in it.</p>
<img data-src="/2020/11/17/FreeBSD/openbox-polybar.jpg" class="" title="FreeBSD">
</li>
<li><p>I have used <code>Conky</code> for quite long time but after recent tests I made <code>Dzen2</code> is a lot less on resources then Conky while doing the same thing. </p>
</li>
</ul>
</li>
<li><p>Task Bar: A taskbar is an element of a graphical user interface which has various purposes. It typically shows which programs are currently running.</p>
<ul>
<li><p>You can use classic taskbar like <code>XFCE Panel</code> used in the XFCE desktop environment.</p>
<img data-src="/2020/11/17/FreeBSD/taskbar-xfce.png" class="" title="FreeBSD">
</li>
<li><p>You can also configure <code>Tint2</code> that way. But it only shows applications that are active on the current desktop.</p>
<img data-src="/2020/11/17/FreeBSD/taskbar-tint-classic.jpg" class="" title="FreeBSD">
</li>
<li><p>One of the greatest taskbars of all time was/is the Mac OS X Dock (now macOS Dock).  It also has an indicator showing if application is launched. Currently the best and lightest solution for providing the dock-like functionality on open desktops seems to be <code>Plank</code>.</p>
<img data-src="/2020/11/17/FreeBSD/taskbar-plank-eos.png" class="" title="FreeBSD">
</li>
</ul>
</li>
<li><p>Application Launcher: While not being any crucial role of the desktop environment it have its uses and sometimes save time.</p>
<p>Lets start with resources, the <code>Rofi</code> implementation of application launcher uses almost 3 times more RAM  then <code>Dmenu</code> solution.</p>
<ul>
<li><p>Desktop with Dmenu launched and with <code>alc</code> characters inserted to ‘filter’ commands in the search of a calculator application.</p>
<img data-src="/2020/11/17/FreeBSD/launcher-dmenu-run.jpg" class="" title="FreeBSD">
</li>
<li><p>The Rofi requires simple command.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rofi -show run -theme solarized_alternate -font &quot;Monaco 8&quot;</span><br></pre></td></tr></table></figure>
<img data-src="/2020/11/17/FreeBSD/launcher-rofi.jpg" class="" title="FreeBSD">
</li>
</ul>
</li>
<li><p>Blue Light Spectrum Suppress: Automatically adjusts color temperature of the screen according to your current time in your location.</p>
<ul>
<li><p>While <span class="exturl" data-url="aHR0cHM6Ly9qdXN0Z2V0Zmx1eC5jb20v">F.lux<i class="fa fa-external-link-alt"></i></span>  (closed source) does not provide a native binary for FreeBSD it does offer such binary for Linux and as FreeBSD provides Linux Binary Compatibility its possible to use it on FreeBSD. To use F.lux just start it in the <code>~/.xinitrc</code> or <code>~/.xsession</code> file like that.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/path/to/bin/xflux -l 33.54321 -g 11.12345 &amp;</span><br></pre></td></tr></table></figure>
<p>Of course 33.54321 is latitude and 11.12345 is longitude of your localization.</p>
</li>
<li><p><code>Redshift</code> is the solution that I propose to use as open source blue light spectrum suppressor. Similarly like with the F.lux to start Redshift just put it in the <code>~/.xinitrc</code> or <code>~/.xsession</code> file like that.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redshift -l 33.54321:11.12345 -g 0.9 &amp;</span><br></pre></td></tr></table></figure></li>
<li><p>Someone else suggested trying <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXIvc2N0ZA==">sctd<i class="fa fa-external-link-alt"></i></span> which is sct but rewritten/modified to be a daemon that will automatically change the color temperature during the day (or night). The sctd uses smaller about of RAM memory, uses less libraries and size of these libraries is smaller then what redshfit needs. </p>
</li>
</ul>
</li>
</ul>
<h3 id="Binary-套件"><a href="#Binary-套件" class="headerlink" title="Binary 套件"></a>Binary 套件</h3><p>搜寻软件：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvcG9ydHMvaW5kZXguaHRtbA==">FreeBSD Ports<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlc2hwb3J0cy5vcmcv">FreshPorts<i class="fa fa-external-link-alt"></i></span></p>
<p>因編譯選項不同，有些 Port 會有多個版本可使用。</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnVzdGMuZWR1LmNuL2hlbHAvZnJlZWJzZC1wa2cuaHRtbA==">USTC Mirrors<i class="fa fa-external-link-alt"></i></span>：注意使用 Latest 源，有很多流行软件。创建 <code>/usr/local/etc/pkg/repos/FreeBSD.conf</code> 覆盖官方源 <code>/etc/pkg/FreeBSD.conf</code> 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/local/etc/pkg/repos/FreeBSD.conf</span><br><span class="line">FreeBSD: &#123;</span><br><span class="line">  url: &quot;pkg+http://mirrors.ustc.edu.cn/freebsd-pkg/$&#123;ABI&#125;/latest&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sudo pkg update -f		# 更新索引</span><br></pre></td></tr></table></figure></li>
<li><p><span class="exturl" data-url="aHR0cDovL21pcnJvcnMuMTYzLmNvbS9mcmVlYnNkLXBrZy9GcmVlQlNEJTNhMTIlM2FhbWQ2NC9sYXRlc3Qv">163 Mirrors<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: &quot;pkg+http:&#x2F;&#x2F;mirrors.163.com&#x2F;freebsd-pkg&#x2F;$&#123;ABI&#125;&#x2F;latest&quot;,</span><br></pre></td></tr></table></figure></li>
<li><p>要啟動 (Bootstrap) 系統，請執行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/sbin/pkg</span><br></pre></td></tr></table></figure></li>
<li><p>當升級原使用舊版 pkg_* 工具的既有系統時，必須將資料庫轉換成新的格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg2ng</span><br></pre></td></tr></table></figure></li>
<li><p>Update the available remote repositories as listed in pkg.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg update</span><br></pre></td></tr></table></figure></li>
<li><p>Search for a package</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg search perl</span><br></pre></td></tr></table></figure></li>
<li><p>在指定要安裝的套件時，最好使用 Port 來源來指定該應用程式，Port 來源是指應用程式在 Port 樹中的路徑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg search -o perl</span><br></pre></td></tr></table></figure></li>
<li><p>Install a package: Installing must specify a unique origin or version otherwise it will try installing all matches</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install perl-5.14</span><br></pre></td></tr></table></figure></li>
<li><p>列出已經安裝的 Port 中有那些已過時</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg version -l &quot;&lt;&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>Upgrade from remote repository</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg upgrade</span><br></pre></td></tr></table></figure></li>
<li><p>Delete an installed package</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg delete perl-5.14</span><br></pre></td></tr></table></figure></li>
<li><p>Remove unneeded dependencies</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg autoremove</span><br></pre></td></tr></table></figure></li>
<li><p>List installed packages</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg info</span><br></pre></td></tr></table></figure></li>
<li><p>Display information about installed packages</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg info perl-5.14</span><br></pre></td></tr></table></figure></li>
<li><p>Show the pkg-message of a package</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg info -D perl-5.14</span><br></pre></td></tr></table></figure></li>
<li><p>要查詢已安在系統上的軟體是否有任何已知的漏洞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg audit -F</span><br></pre></td></tr></table></figure></li>
<li><p>因為相依所安裝的套件稱作自動 (Automatic) 套件，而非自動套件即套件被安裝的原因不是因為其他套件所相依</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg prime-list		# deprecated</span><br></pre></td></tr></table></figure></li>
<li><p>Clean the local cache of fetched remote packages</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>Packages</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install linux-sublime3</span><br><span class="line">sudo pkg install mysql180-server mysql180-client</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Port-套件"><a href="#Port-套件" class="headerlink" title="Port 套件"></a>Port 套件</h3><p>優點：</p>
<ul>
<li>可更改編譯選項</li>
<li>部份軟體的授權條款中禁止以 Binary 格式發佈。 這種軟體必須以原始碼發佈並由終端使用者編譯。</li>
<li>原始碼可套用自訂的修補。</li>
</ul>
<p>Port 中並不含實際的原始碼，在編譯 Port 解壓縮時會自動下載的原始碼到 <code>/usr/ports/distfiles</code>。</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnVzdGMuZWR1LmNuL2hlbHAvZnJlZWJzZC1wb3J0cy5odG1s">USTC Mirrors<i class="fa fa-external-link-alt"></i></span>：在 <code>/etc/make.conf</code> 中添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASTER_SITE_OVERRIDE?&#x3D;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;freebsd-ports&#x2F;distfiles&#x2F;$&#123;DIST_SUBDIR&#125;&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p><span class="exturl" data-url="aHR0cDovL21pcnJvcnMuMTYzLmNvbS9mcmVlYnNkLXBvcnRzL2Rpc3RmaWxlcy8=">163 Mirrors<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MASTER_SITE_OVERRIDE?&#x3D;http:&#x2F;&#x2F;mirrors.163.com&#x2F;freebsd-ports&#x2F;distfiles&#x2F;$&#123;DIST_SUBDIR&#125;&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><p>安裝 Port 套件集：下載壓縮後的 Port 套件集快照 (Snapshot) 到 /var/db/portsnap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo portsnap fetch</span><br></pre></td></tr></table></figure></li>
<li><p>第一次執行 Portsnap 時，要先解壓縮快照到 /usr/ports</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo portsnap extract</span><br></pre></td></tr></table></figure></li>
<li><p>執行以下指令來更新 /usr/ports</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo portsnap fetch</span><br><span class="line">sudo portsnap update</span><br></pre></td></tr></table></figure></li>
<li><p>要找到 Port 所在的分類</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo whereis lsof</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Port 套件集內建的搜尋機制來找軟體</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cd /usr/ports</span><br><span class="line">sudo make search name=lsof</span><br><span class="line">sudo make quicksearch name=lsof		# 不接受多資訊</span><br></pre></td></tr></table></figure></li>
<li><p>若要進行更有深度的搜尋</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make search key=string</span><br><span class="line">sudo make quicksearch key=string</span><br></pre></td></tr></table></figure></li>
<li><p>一次設定所有Port 編譯選項</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make config-recursive</span><br></pre></td></tr></table></figure></li>
<li><p>重新進入 Port 的編譯選項清單</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make config			# or</span><br><span class="line">sudo make showconfig		# or</span><br><span class="line">sudo make rmconfig</span><br></pre></td></tr></table></figure></li>
<li><p>編譯並安裝 Port</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cd /usr/ports/sysutils/lsof</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li>
<li><p>編譯在 /usr/ports Port 並安裝到 /usr/home/example/local</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make WRKDIRPREFIX=../ports PREFIX=../local install</span><br></pre></td></tr></table></figure></li>
<li><p>安裝過程中會建立工作用的子目錄用來儲存編譯時暫存的檔案。可移除此目錄來節省磁碟空間並漸少往後升級新版 Port 時造成問題</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make clean</span><br></pre></td></tr></table></figure></li>
<li><p>移除已安裝的 Port</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cd /usr/ports/sysutils/lsof</span><br><span class="line">sudo make deinstall</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/ports/java/linux-oracle-jdk18</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>安裝後的注意事項：</p>
</li>
<li><p>大部份應用程式安裝會在 <code>/usr/local/etc</code> 安裝至少一個預設的設定檔。</p>
</li>
<li><p>應用程式提供的文件會安裝到 <code>/usr/local/share/doc</code>。</p>
</li>
<li><p>部份應用程式會以服務的方式執行，在啟動應用程式前前需要加入設定到 <code>/etc/rc.conf</code>。這些應用程式通常會安裝啟動 Script 到 <code>/usr/local/etc/rc.d</code>。</p>
</li>
</ul>
<h3 id="Linux®-Binary-相容性"><a href="#Linux®-Binary-相容性" class="headerlink" title="Linux® Binary 相容性"></a>Linux® Binary 相容性</h3><p>FreeBSD 提供 Linux® Binary 的相容性，允許使用者在 FreeBSD 系統上不需要修改就可以安裝和執行大部份的 Linux® Binary。</p>
<p>最好不要直接安装 Linux 的软件，而使用 FreeBSD 源中的 Linux 软件，一般以 <code>linux-package</code> 命名。</p>
<ul>
<li><p>載入 Linux® 核心模組</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kldload linux</span><br></pre></td></tr></table></figure></li>
<li><p>對 64-位元的相容性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kldload linux64</span><br></pre></td></tr></table></figure></li>
<li><p>確認模組已載入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kldstat</span><br></pre></td></tr></table></figure></li>
<li><p>安裝基本的 Linux® 程式庫和 Binary</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install emulators/linux_base-c7</span><br></pre></td></tr></table></figure></li>
<li><p>Add the following line</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/fstab</span><br><span class="line">linprocfs   /compat/linux/proc	linprocfs	rw	0	0</span><br><span class="line">linsysfs    /compat/linux/sys	linsysfs	rw	0	0</span><br><span class="line">tmpfs    /compat/linux/dev/shm	tmpfs	rw,mode=1777	0	0</span><br></pre></td></tr></table></figure></li>
<li><p>開機時開啟 Linux® 相容性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/rc.conf</span><br><span class="line">linux_enable=&quot;YES&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>安裝 Linux® ELF Binary</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo brandelf -t Linux my-linux-elf-binary</span><br></pre></td></tr></table></figure></li>
<li><p>安裝以 Linux® RPM 為基礎的應用程式,需先安裝 archivers/rpm4 套件或 Port</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install rpm4</span><br><span class="line">sudo cd /compat/linux</span><br><span class="line">sudo rpm2cpio &lt; /path/to/linux.archive.rpm | cpio -id</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="手動安裝其他程式庫"><a href="#手動安裝其他程式庫" class="headerlink" title="手動安裝其他程式庫"></a>手動安裝其他程式庫</h5><ul>
<li><p>在 Linux® 系統，可使用 ldd 來找出應用程式需要哪個共用程式庫</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd linuxdoom</span><br><span class="line">libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0</span><br></pre></td></tr></table></figure></li>
<li><p>複製 Linux® 系統輸出結果中最後一欄需要的的檔案到 FreeBSD 系統的 /compat/linux。 複製完後，建立符號連結 (Symbolic link) 至輸出結果第一欄的名稱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;compat&#x2F;linux&#x2F;usr&#x2F;X11&#x2F;lib&#x2F;libXt.so.3.1.0</span><br><span class="line">&#x2F;compat&#x2F;linux&#x2F;usr&#x2F;X11&#x2F;lib&#x2F;libXt.so.3 -&gt; libXt.so.3.1.0</span><br></pre></td></tr></table></figure>
<h3 id="自訂核心"><a href="#自訂核心" class="headerlink" title="自訂核心"></a>自訂核心</h3></li>
</ul>
<h5 id="為何要編譯自訂的核心"><a href="#為何要編譯自訂的核心" class="headerlink" title="為何要編譯自訂的核心?"></a>為何要編譯自訂的核心?</h5><p> 自訂核心有許多項優點，如：</p>
<ul>
<li>加速開機，因為自訂的核心只需要偵測您系統上存在的硬體，所以讓啟動所花的過程更流暢快速。</li>
<li>減少記憶體使用，自訂的核心通常會比 <code>GENERIC</code> 核心使用更少的記憶體，這很重要，因為核心必須一直存放在實體記憶體內。</li>
<li>支援額外的硬體，自訂的核心可以增加一些 <code>GENERIC</code> 核心沒有提供的硬體支援。</li>
</ul>
<h5 id="偵測系統硬體"><a href="#偵測系統硬體" class="headerlink" title="偵測系統硬體"></a>偵測系統硬體</h5><ul>
<li><p> <code>dmesg</code>  or <code>/var/run/dmesg.boot</code> or <code>/var/log/messages</code></p>
</li>
<li><p><code>pciconf -lv</code></p>
</li>
<li><p>在 man指令加上 -k 旗標可列出有包含指定裝置品牌或名稱的手冊頁面清單：<code>man -k Intel</code></p>
</li>
</ul>
<h5 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h5><p><code>/usr/src/sys</code> 下子目錄代表著支援的硬體架構 (Architecture)，每個支援的硬體架構中會有 <code>conf</code> 子目錄，裡面含有供該架構使用的 <code>GENERIC</code> 核心設定檔。</p>
<p>說明在<code>GENERIC</code> 同目錄的 <code>NOTES</code> 檔案中。所有架構通用選項，參考 <code>/usr/src/sys/conf/NOTES</code>。</p>
<h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvZG9jL2hhbmRib29rL2JhY2t1cC1iYXNpY3MuaHRtbA==">备份与恢复<i class="fa fa-external-link-alt"></i></span></h3><h5 id="dump-amp-restore"><a href="#dump-amp-restore" class="headerlink" title="dump &amp; restore"></a>dump &amp; restore</h5><p>FreeBSD 系统的备份就是对系统文件的打包，然后放到一个安全的地方，使用的打包工具是 <code>dump</code>；FreeBSD 系统的恢复就是把你保存好的系统文件从安全的地方里面拿出来放到你的硬盘上去，使用的恢复工具是 <code>restore</code>；</p>
<ul>
<li><p>需要备份的目录：</p>
<ul>
<li><code>/</code> 这个目录存放很多基本工具，包括内核，需要备份；</li>
<li><code>/home</code> 用户数据，需要备份；</li>
<li><code>/usr</code> 很多工具以及系统的源代码都放在这里面，需要备份；</li>
<li><code>/usr/local</code> 所有安装的软件基本上都在这里，需要备份；</li>
<li><code>/var</code> 系统的日志，ports系统的数据库，需要备份；</li>
</ul>
</li>
<li><p>备份方法：以 <code>/</code> 目录为例，把移动硬盘挂载在 <code>/mnt/fender_01</code> 目录，<code>/</code> 目录对应硬盘上面的 <code>/dev/ad12s1a</code> 分区，备份整个目录的命令如下：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dump -0Lauf /mnt/fender_01/dump/ad12sa1.dump /dev/ad12s1a</span><br></pre></td></tr></table></figure>

<ul>
<li>-0 备份所有的文件系统中的内容，也就是不使用增量备份；</li>
<li>-f 指定备份结果存放的文件名；</li>
<li>-a 告诉 dump 不考虑备份的介质的大小问题，早期备份使用磁带，dump 会预先计算一下需要的空间，使用这个选项告诉 dump 忽略这个问题；</li>
<li>-u 告诉 dump 更新一下 /etc/dumpdates，这个文件记录了你在系统上搜有的备份活动；</li>
<li>-L 备份已经挂载的文件系统时需要，这个选项会使用 UFS2 的 snapshot 功能来保证文件系统的一致性。</li>
</ul>
</li>
<li><p>恢复方法</p>
<ul>
<li><p>恢复 <code>/</code> 以外的目录：以恢复  <code>/home</code> 目录为例，重启系统进入单用户模式，挂载 <code>/tmp</code> 分区，挂载移动硬盘，这时备份生成的文件保存在 <code>/mnt/01/dump/dev/ad12s1h.dump</code>，格式化 <code>/dev/ad12s1h</code>：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">newfs -U /dev/ad12s1h		# -U 选型来打开 softupdate</span><br></pre></td></tr></table></figure>
<p>  挂载这个分区，例如 <code>/mnt/02/</code>，恢复目录：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /mnt/02</span><br><span class="line">restore -rf /mnt/01/dump/ad12s1h.dump</span><br></pre></td></tr></table></figure></li>
<li><p>恢复 <code>/</code>：因为 restore 在 <code>/</code> 目录中，所以不能使用上面方法恢复 <code>/</code> 目录。解决办法是使用 freebsd_livefs_cd 启动系统。</p>
</li>
</ul>
</li>
<li><p>备份 MBR</p>
<ul>
<li><p>备份</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/da0 of=/path/to/mbr.img bs=512 count=1</span><br></pre></td></tr></table></figure></li>
<li><p>恢复</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/path/to/mbr.img of=/dev/da0 bs=512 count=1</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjAzMDYxNjYtaWQtMzE2MDM3Lmh0bWw=">FreeBSD dump 备份<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="rsync（remote-sync）"><a href="#rsync（remote-sync）" class="headerlink" title="rsync（remote sync）"></a>rsync（remote sync）</h5><p>可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件，且仅传输有变动的部分。</p>
<ul>
<li><p>将源目录同步到目标目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -r source1 source2 destination		# -r 表示递归，即包含子目录</span><br><span class="line">rsync -a source/ destination		# -a 除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）</span><br></pre></td></tr></table></figure></li>
<li><p>排除文件：同步时排除某些文件或目录，这时可以用 <code>--exclude</code> 参数指定排除模式，多个排除模式，可以用多个 <code>--exclude</code> 参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av --exclude dir source/ destination		# 排除所有 TXT 文件</span><br></pre></td></tr></table></figure></li>
<li><p>增量备份：除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。<code>--link-dest</code> 参数用来指定同步时的基准目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a --delete --link-dest /compare/path /source/path /target/path</span><br></pre></td></tr></table></figure></li>
<li><p>远程同步：rsync 默认使用 SSH 进行远程登录和数据传输</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av source/ username@remote_host:destination		# 将本地内容同步到远程服务器</span><br><span class="line">rsync -av username@remote_host:source/ destination		# 将远程内容同步到本地</span><br></pre></td></tr></table></figure></li>
<li><p>使用 rsync 来备份系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -aH --delete --exclude dir --link-dest /compare/path source destination</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-H</code> 选项用来保持硬链接</li>
<li>默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果你想让那些在源目录里被删除的文件在目标目录里也被删除，那么你可以加上 <code>--delete</code> 选项来删除。<code>--delete</code> 参数会使得 <code>destination</code> 成为 <code>source</code> 的一个镜像。</li>
</ul>
</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMjAvMDgvcnN5bmMuaHRtbA==">rsync 用法教程<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTgyMzctMS5odG1s">使用 rsync 来备份 Linux 系统<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Z-檔案系統-ZFS"><a href="#Z-檔案系統-ZFS" class="headerlink" title="Z 檔案系統 (ZFS)"></a>Z 檔案系統 (ZFS)</h3><p>ZFS 的設計目標主要有三個：</p>
<ul>
<li>資料完整性：所有資料都會有一個資料的校驗碼 (checksum)，資料寫入時會計算校驗碼然後一併寫入，往後讀取資料時會再計算一次校驗碼，若校驗碼與當初寫入時不相符，便可偵測到資料錯誤，此時若有可用的資料備援 (Data redundancy)，ZFS 會嘗試自動修正錯誤。</li>
<li>儲存池：實體的儲存裝置都會先被加入到一個儲存池 (Pool)，這個共用的儲存池可用來配置儲存空間，儲存池的空間可被所有的檔案系統使用且透過加入新的儲存裝置來增加空間。</li>
<li>效能：提供多個快取機制來增加效能。先進、以記憶體為基礎的讀取快取可使用 ARC。第二層以磁碟為基礎的讀取快取可使用 L2ARC，以磁碟為基礎的同步寫入快取則可使用 ZIL。</li>
</ul>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><h5 id="Screen-resolution-on-FreeBSD-on-VirtualBox"><a href="#Screen-resolution-on-FreeBSD-on-VirtualBox" class="headerlink" title="Screen resolution on FreeBSD on VirtualBox"></a>Screen resolution on FreeBSD on VirtualBox</h5><p>问题描述：在virtualbox虚拟机下，无法改变桌面分辨率为1366x768</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VBoxManage setextradata &quot;FreeBSD&quot; VBoxInternal2/EfiGraphicsResolution 1366x768</span><br></pre></td></tr></table></figure>
<h5 id="Disable-the-Forward-Back-buttons-on-my-mouse"><a href="#Disable-the-Forward-Back-buttons-on-my-mouse" class="headerlink" title="Disable the Forward/Back buttons on my mouse"></a>Disable the Forward/Back buttons on my mouse</h5><p>问题描述：浏览网页时，鼠标滑轮滚动浏览器就会前进后退。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMDU1MC9ob3ctdG8tZGlzYWJsZS10aGUtZm9yd2FyZC1iYWNrLWJ1dHRvbnMtb24tbXktbW91c2U=">Salved<i class="fa fa-external-link-alt"></i></span>：</p>
<ul>
<li><p>执行下面命令后，上下滑动鼠标滑轮，看看映射到那些button，一般是buttons 8 and 9</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xev | grep -A2 ButtonPress</span><br></pre></td></tr></table></figure></li>
<li><p>then disable button 8 and 9（前提是有上面的问题，否则就不要禁）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.Xmodmap</span><br><span class="line">pointer = 1 2 3 4 5 6 7 0 0 0 0 0</span><br></pre></td></tr></table></figure></li>
<li><p>test it with the command,command automatically when you log in; if yours doesn’t, arrange for it to run when X starts.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo xmodmap ~/.Xmodmap</span><br></pre></td></tr></table></figure>
<h5 id="Install-chinese-font"><a href="#Install-chinese-font" class="headerlink" title="Install chinese font"></a>Install chinese font</h5></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pkg install zh-CJKUnifonts		# CJK（中日韩统一表意文字）</span><br></pre></td></tr></table></figure>
<h5 id="设单使用模式为不安全"><a href="#设单使用模式为不安全" class="headerlink" title="设单使用模式为不安全"></a>设单使用模式为不安全</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/ttys</span><br><span class="line">console none	unknown off insecure</span><br></pre></td></tr></table></figure>
<h5 id="No-space-left-on-device"><a href="#No-space-left-on-device" class="headerlink" title="No space left on device"></a>No space left on device</h5><p>问题描述：使用 pkg update 时提示这个问题。原因是 /tmp is too small。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bXMuZnJlZWJzZC5vcmcvdGhyZWFkcy9uby1zcGFjZS1sZWZ0LW9uLWRldmljZS42MTIzMi8=">Salved<i class="fa fa-external-link-alt"></i></span>: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/fstab</span><br><span class="line">tmpfs	/tmp	tmpfs	rw,size=256000000	0	0		# size 以Byte为单位</span><br></pre></td></tr></table></figure>
<h5 id="VirtualBox™-guest-additions"><a href="#VirtualBox™-guest-additions" class="headerlink" title="VirtualBox™ guest additions"></a>VirtualBox™ guest additions</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cd /usr/ports/emulators/virtualbox-ose-additions &amp;&amp; make install clean</span><br><span class="line"></span><br><span class="line">sudo vi /etc/rc.conf</span><br><span class="line">vboxguest_enable=&quot;YES&quot;</span><br><span class="line">vboxservice_enable=&quot;YES&quot;</span><br><span class="line">vboxservice_flags=&quot;--disable-timesync&quot;		# 若有使用 ntpd或 ntpdate，便可關閉主機時間同步功能</span><br></pre></td></tr></table></figure>
<h5 id="Fish"><a href="#Fish" class="headerlink" title="Fish"></a>Fish</h5><p>Fish 是”the <strong>f</strong>riendly <strong>i</strong>nteractive <strong>sh</strong>ell”的简称，最大特点就是方便易用。</p>
<p>Fish 会自动在光标后面给出建议，表示可能的选项，颜色为灰色。如果采纳建议，可以按下<code>→</code>或<code>Control + F</code>。如果只采纳一部分，可以按下<code>Alt + →</code>。</p>
<p>输入命令时，Fish 会自动显示匹配的上一条历史记录。如果没有匹配的历史记录，Fish 会猜测可能的结果，自动补全各种输入。</p>
<h5 id="How-to-start-things-at-boot-time"><a href="#How-to-start-things-at-boot-time" class="headerlink" title="How to start things at boot time"></a><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnNkZGlhcnkub3JnLw==">How to start things at boot time<i class="fa fa-external-link-alt"></i></span></h5><ul>
<li><p>主流的桌面环境都自带应用程序自启动设置程序。</p>
</li>
<li><p>These directories are defined in <code>/etc/defaults/rc.conf</code>（主要是运行脚本）</p>
<ul>
<li><p>Default startup directory is <code>/usr/local/etc/rc.d/</code>. if you need the files to be executed in a specific order, try numbering the files. For example:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000This.Will.Run.First.sh</span><br><span class="line">020This.Will.Run.Next.sh</span><br><span class="line">030And.Then.This.sh</span><br></pre></td></tr></table></figure></li>
<li><p>deprecated: <code>/etc/rc.local</code>        </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>DSBAutostart is a Qt program that allows you to add commands to be executed at session start.</p>
<p>（本质就是在 <code>.xinitrc</code> 调用程序指令，GUI 程序开机启动都需放入 <code>.xinitrc</code>，在 Xorg 启动后运行）</p>
<ul>
<li><p>Installation</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/ports/x11/dsbautostart &amp;&amp; make install distclean</span><br></pre></td></tr></table></figure>
</li>
<li><p>Usage</p>
<ul>
<li><p>Manual</p>
<ul>
<li><p>Setup: Add the following command to your <code>~/.xinitrc</code>, or to your window manager’s startup script (e.g. <code>~/.config/openbox/autostart.sh</code>)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh ~&#x2F;.config&#x2F;DSB&#x2F;autostart.sh&amp;</span><br></pre></td></tr></table></figure></li>
<li><p><code>~/.config/DSB/autostart.sh</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plank&amp;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>GUI: <code>Setting -&gt; DSBAutostart -&gt; Add Command</code>, example <code>plank</code>, then <code>Save</code> and <code>Quit</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="FreeBSD-Insall-Oracle-JDK"><a href="#FreeBSD-Insall-Oracle-JDK" class="headerlink" title="FreeBSD Insall Oracle JDK"></a>FreeBSD Insall Oracle JDK</h5><ul>
<li>安装 Linux Compact</li>
<li>在 <code>/usr/ports/java/linux-oracle-jdk18</code> 运行 <code>sudo make install</code></li>
<li>根据提示在 <span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9vcmFjbGUtamF2YS1hcmNoaXZlLWRvd25sb2Fkcy5odG1s">Oracle Java Archive<i class="fa fa-external-link-alt"></i></span> 下载需要的 JDK 版本安装包，复制到 <code>/usr/ports/distfiles</code></li>
<li>在 <code>/usr/ports/java/linux-oracle-jdk18</code> 运行 <code>sudo make install</code>，安装成功</li>
</ul>
<h5 id="FreeBSD-Install-Python-and-pip"><a href="#FreeBSD-Install-Python-and-pip" class="headerlink" title="FreeBSD Install Python and pip"></a>FreeBSD Install Python and pip</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pkg install python</span><br><span class="line"></span><br><span class="line">python --version</span><br><span class="line">Python 3.7.9</span><br><span class="line"></span><br><span class="line">sudo pkg install py37-pip</span><br></pre></td></tr></table></figure>
<h5 id="简化启动"><a href="#简化启动" class="headerlink" title="简化启动"></a>简化启动</h5><p>FreeBSD 默认启动过程相当详细，包含大量调试信息以及内核消息。</p>
<ul>
<li>Add the <code>boot_mute=YES</code> option to the <code>/boot/loader.conf</code> file. </li>
<li>Add <code>autoboot_delay=2</code> parameter to the <code>/boot/loader.conf</code> file.</li>
<li>Add <code>rc_startmsgs=&quot;NO&quot;</code> to your <code>/etc/rc.conf</code> file.</li>
</ul>
<h5 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h5><p>If You will have attached LAN cable and your interface is <code>em0</code> (check <code>ifconfig</code> command output) then <code>dhclient em0</code> command should grant You the working connection to the Internet – assuming that You have DHCP server on that network. </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig em0 up</span><br><span class="line">dhclient em0</span><br></pre></td></tr></table></figure>
<p>To test the network connectivity use the <code>ping</code> command.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping -c 3 freebsd.org</span><br></pre></td></tr></table></figure>
<p>If You would like to connect to the World with wireless connection then here are the needed commands. First lets check what wireless card You have.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl net.wlan.devices</span><br></pre></td></tr></table></figure>
<p>We will now create <code>wlan</code> virtual device on top of our <code>iwn0</code> device and bring it up.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig wlan0 create wlandev iwn0</span><br><span class="line">ifconfig wlan0 up</span><br></pre></td></tr></table></figure>
<p>We can scan for existing nearby WiFi access points if needed.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig wlan0 scan</span><br></pre></td></tr></table></figure>
<p>Now we need to add the desired WiFi network to the <code>/etc/wpa_supplicant.conf</code> file as shown below.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network&#x3D;&#123;</span><br><span class="line">  ssid&#x3D;&quot;WIFI-NETWORK-NAME&quot;</span><br><span class="line">  psk&#x3D;&quot;PASSWORD&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then You may connect to it using the <code>wpa_supplicant</code> daemon. Hit the <code>[CTRL]+[Z]</code> key combination to put the process into suspended state. Then we type the <code>bg</code> command to put it back into running state, but in the background so we can continue to type next commands.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>
<p>Now we will request for the IP address from the access point DHCP server.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dhclient wlan0</span><br></pre></td></tr></table></figure>
<h5 id="How-To-Add-and-Remove-Users-on-FreeBSD"><a href="#How-To-Add-and-Remove-Users-on-FreeBSD" class="headerlink" title="How To Add and Remove Users on FreeBSD"></a>How To Add and Remove Users on FreeBSD</h5><ul>
<li><p>Add a User: <code>adduser</code></p>
</li>
<li><p>Grant Sudo Privileges: On FreeBSD, users that are members of the <code>wheel</code> group are allowed to use <code>sudo</code>. This is due to the following line in the default <strong>sudoers</strong> file, <code>/usr/local/etc/sudoers</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%wheel ALL&#x3D;(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure></li>
<li><p>Remove a User: <code>rmuser</code></p>
</li>
<li><p>Lock a User Account: <code>pw lock username</code></p>
</li>
<li><p>Unlock a User: <code>pw unlock username</code></p>
</li>
</ul>
<h3 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h3><p>NetBSD: <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9OZXRCU0Qv">huaweicloud<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmFsaXl1bi5jb20vbmV0YnNkLz9zcG09YTJjNmguMTM2NTExMDQuMC4wLjRkODQzYmY0QXpKWVRY">aliyun<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuLw==">tsinghua<i class="fa fa-external-link-alt"></i></span></p>
<p>OpenBSD: <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9PcGVuQlNELw==">huaweicloud<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmFsaXl1bi5jb20vb3BlbmJzZC8/c3BtPWEyYzZoLjEzNjUxMTA0LjAuMC4xNGRiNWE1MHFGblhsNg==">aliyun<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuLw==">tsinghua<i class="fa fa-external-link-alt"></i></span></p>
<p>一篇好文：<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9xaWhoL2Jsb2cvNzg3NDM=">FreeBSD的现状和未来<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly92ZXJtYWRlbi53b3JkcHJlc3MuY29tL2ZyZWVic2QtZGVza3RvcC8=">FreeBSD Desktop<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvZG9jL3poX1RXL2Jvb2tzL2hhbmRib29rLw==">FreeBSD 使用手冊<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2020/12/10/Hexo/</url>
    <content><![CDATA[<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvaW5kZXguaHRtbA==">Hexo<i class="fa fa-external-link-alt"></i></span></h3><p>Hexo 是一个快速、简洁且高效的博客框架。</p>
<a id="more"></a>

<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul>
<li><p>安装 Git：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop install git</span><br></pre></td></tr></table></figure></li>
<li><p>安装 node.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop install nodejs</span><br></pre></td></tr></table></figure></li>
<li><p>安装 Hexo：-g 表示全局安装，会将 Hexo 命令加入环境变量中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install	 # 不必执行，在执行 hexo init 的过程中就已经自动安装好了项目依赖。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules		&#x2F;&#x2F;依赖安装目录</span><br><span class="line">├── scaffolds			&#x2F;&#x2F;模板文件夹，Hexo的模板是指在新建的文章文件中默认填充的内容。</span><br><span class="line">|   ├── draft.md		&#x2F;&#x2F;草稿模板</span><br><span class="line">|   ├── page.md			&#x2F;&#x2F;页面模板</span><br><span class="line">|   └── post.md			&#x2F;&#x2F;文章模板</span><br><span class="line">├── source				&#x2F;&#x2F;资源文件夹</span><br><span class="line">|   └── _posts			&#x2F;&#x2F;文章目录</span><br><span class="line">├── themes				&#x2F;&#x2F;主题文件夹，Hexo 会根据主题来生成静态页面。</span><br><span class="line">|   └── landscape		&#x2F;&#x2F;默认主题</span><br><span class="line">├── .gitignore			&#x2F;&#x2F;指定不纳入git版本控制的文件</span><br><span class="line">├── _config.yml			&#x2F;&#x2F;站点配置文件</span><br><span class="line">├── db.json            </span><br><span class="line">├── package.json		&#x2F;&#x2F;应用程序的信息</span><br><span class="line">└── package-lock.json</span><br></pre></td></tr></table></figure>
<p>source：资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支援多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。如 <code>Asia/Shanghai</code>。</td>
</tr>
<tr>
<td align="left"><code>url</code></td>
<td align="left">网址 http://<code>or</code>https://</td>
</tr>
<tr>
<td align="left"><code>root</code></td>
<td align="left">网站根目录</td>
</tr>
<tr>
<td align="left"><code>theme</code></td>
<td align="left">当前主题名称。值为<code>false</code>时禁用主题</td>
</tr>
<tr>
<td align="left"><code>deploy</code></td>
<td align="left">部署部分的设置</td>
</tr>
</tbody></table>
<h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><ul>
<li><p>version 显示 Hexo 版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure></li>
<li><p>list 列出网站资料：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo list</span><br></pre></td></tr></table></figure></li>
<li><p>新建一篇文章：如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo n [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Hexo 有三种默认布局：</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
</li>
<li><p>预览草稿，publish 发表草稿：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server --draft</span><br><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li>
<li><p>generate 生成静态文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>启动 hexo 的内置 Web 服务器：该命令将会调用 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWFya2Rvd25ndWlkZS5vcmcvYmFzaWMtc3ludGF4">Markdown<i class="fa fa-external-link-alt"></i></span> 引擎解析项目中的博客内容生成网页资源，资源将会存于内存中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">hexo s --debug		# 开启调试模式（--debug）</span><br><span class="line">hexo s --port 8000	# 添加 -p &#x2F; --port 参数来设置 Web 服务监听的端口号</span><br><span class="line">hexo s --static		# 加 -s &#x2F; --static 参数，本地改动不触发 hexo 实时解析更新。</span><br></pre></td></tr></table></figure></li>
<li><p>deploy 部署网站：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h5 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h5></li>
<li><p>Front-matter： 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> 		<span class="comment"># 布局</span></span><br><span class="line"><span class="attr">title:</span> 			<span class="comment"># 标题</span></span><br><span class="line"><span class="attr">date:</span> 			<span class="comment"># 建立日期</span></span><br><span class="line"><span class="attr">updated:</span> 		<span class="comment"># 更新日期</span></span><br><span class="line"><span class="attr">comments:</span> 		<span class="comment"># 开启文章的评论功能</span></span><br><span class="line"><span class="attr">tags:</span>			<span class="comment"># 标签</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="attr">categories:</span> [<span class="string">分类1</span>, <span class="string">分类2</span>]		<span class="comment"># 分类, 不适用与分页</span></span><br><span class="line"><span class="attr">permalink:</span> 		<span class="comment"># 覆盖文章网址</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>  标签是一种列表结构，而分类是一种树结构。</p>
</li>
<li><p>文本居中标签：在引用单行文本时使用</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class&#x3D;&quot;blockquote-center&quot;&gt;blah blah blah&lt;&#x2F;blockquote&gt;		# HTML方式</span><br><span class="line"></span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;		# 标签方式</span><br><span class="line"></span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;		# 标签别名</span><br></pre></td></tr></table></figure></li>
<li><p>引用块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96; [language] [title] [url] [link text]</span><br><span class="line">code snippet</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>langugae</code>：语言名称，引导渲染引擎正确解析并高亮显示关键字</li>
<li><code>title</code>：代码块标题，将会显示在左上角</li>
<li><code>url</code>：链接地址，如果没有指定 link text 则会在右上角显示 link</li>
<li><code>link text</code>：链接名称，指定 url 后有效，将会显示在右上角</li>
<li>如果设置语言为 diff，可以在代码前添加 <code>+</code> 和 <code>-</code> 来使用如上所示的高亮增删行提示效果，在展示代码改动痕迹时比较实用。</li>
</ul>
</li>
<li><p>note 标签：通过 note 标签可以为段落添加背景色</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持的 class 种类包括 default、primary、success、info、warning、danger</li>
</ul>
</li>
<li><p>label 标签：通过 label 标签可以为文字添加背景色</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label [class]@text  %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持的 class 种类包括 default、primary、success、info、warning、danger</li>
</ul>
</li>
<li><p>button 按钮：通过 button 标签可以快速添加带有主题样式的按钮</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% button &#x2F;path&#x2F;to&#x2F;url&#x2F;, text, icon [class], title %&#125;</span><br><span class="line">&#123;% btn &#x2F;path&#x2F;to&#x2F;url&#x2F;, text, icon [class], title %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>tab 标签：tab 标签用于快速创建 tab 选项卡</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs [Unique name], [index] %&#125;</span><br><span class="line">  &lt;!-- tab [Tab caption]@[icon] --&gt;</span><br><span class="line">  标签页内容（支持行内标签）</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Unique name: 全局唯一的 Tab 名称，将作为各个标签页的 id 属性前缀</li>
<li>index: 当前激活的标签页索引，如果未定义则默认选中显示第一个标签页，如果设为 - 1 则默认隐藏所有标签页</li>
<li>Tab caption: 当前标签页的标题，如果不指定则会以 Unique name 加上索引作为标题</li>
<li>icon: 在标签页标题中添加 Font awesome 图标</li>
</ul>
</li>
<li><p>引用站内链接</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_path slug %&#125;</span><br><span class="line">&#123;% post_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>slug</code> 表示 <code>_post</code> 目录下的 Markdown 文件名。</li>
<li>post_path 标签将会渲染为文章的地址，即 permalink；而 post_link 标签将会渲染为链接，可以通过 title 指定链接标题。</li>
</ul>
</li>
<li><p>插入 Swig 代码：通过 raw 标签来禁止 Markdown 引擎渲染标签内的内容。该标签通常用于在页面内引入三方脚本实现特殊功能。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入 Gist</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% gist gist_id [filename] %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>gist_id: Gist 仓库页面 url 中最后一段随机字符串</li>
<li>filename: Gist 中的文件名，如果 Gist 中只有一个文件，可以不用指定 filename，如果 Gist 中有多个文件，可以在标签内输入 filename 来指定只引入某个文件，如果没有指定 filename，将会引入 Gist 中的所有文件。</li>
</ul>
</li>
<li><p>插入图片：</p>
<ul>
<li><p>Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。</p>
</li>
<li><p>相对路径引用的标签插件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img slug [title] %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>slug 是资源文件夹下的图片名</p>
</li>
<li><p>Embedding an image using markdown：allows you to embed an image in markdown without using asset_img tag plugin.</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>  <code>![](image.jpg)</code> will be rendered as <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0QwbjlYMW4vaGV4by1ibG9nLWVuY3J5cHQ=">文章加密<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>Install</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure></li>
<li><p>Quick start: Add the “password” value to your post’s front matter like</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">password: mikemessi</span><br><span class="line">---</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9zdXlpbi1ibG9nLmNsdWIvMjAxOS8zS1pNQkFGLw==">Hexo 添加文章时自动打开编辑器<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>在 Hexo 目录下的 scripts 目录中创建一个 JavaScript 脚本文件。通过这个脚本，我们用其来监听 <code>hexo new</code> 这个动作，并在检测到 <code>hexo new</code> 之后，执行编辑器打开的命令。</p>
</li>
<li><p>将下列内容写入你的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var spawn &#x3D; require(&#39;child_process&#39;).exec;</span><br><span class="line"></span><br><span class="line">hexo.on(&#39;new&#39;, function(data)&#123;</span><br><span class="line">  spawn(&#39;start  &quot;markdown编辑器绝对路径.exe&quot; &#39; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文章置顶</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">sticky: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h5 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h5></li>
</ul>
<p>资源（Asset）代表 source 文件夹中除了文章以外的所有文件。</p>
<p><strong>文章资源文件夹</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们。</p>
<h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><p><strong>持续集成（Continuous Integration，简称 CI）</strong></p>
<p>Simply Push to Deploy：热部署，只需要将代码 push 到 Git 远程仓库即可自动构建及更新。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubmV0bGlmeS5jb20v">Netlify<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlL2FjdGlvbnMvaGV4by1hY3Rpb24=">GitHub Action<i class="fa fa-external-link-alt"></i></span>：</p>
<ul>
<li><p>Add your ssh key pair</p>
<ul>
<li><p>Run the following terminal command, replacing the email with one connected to your GitHub account.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;username@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>Windows 下自定义 ssh key 文件需写成 <code>GIT\BlogSrc/.ssh/id_rsa</code></p>
</li>
<li><p>In Github Pages repo: Add the contents of the <strong>public key（id_rsa.pub）</strong> within your repositories deploy keys menu. You can find this option by going to <code>Settings &gt; Deploy Keys</code>, you can name the public key whatever you want, but you do <strong>need to give it write access</strong>.</p>
</li>
<li><p>In hexo source code repo: Add the contents of the <strong>private key（id_rsa）</strong> to the <code>Settings &gt; Secrets</code> menu as <code>DEPLOY_KEY</code>.</p>
</li>
</ul>
</li>
<li><p>Configure github workflows：Create a workflow .yml file in your .github/workflows directory.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">A</span> <span class="string">job</span> <span class="string">to</span> <span class="string">deploy</span> <span class="string">blog.</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span> <span class="comment"># Checkout private submodules(themes or something else).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Deploy hexo blog website.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deploy</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">user_name:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">username</span>  <span class="comment"># (or delete this input setting to use bot account)</span></span><br><span class="line">        <span class="attr">user_email:</span> <span class="string">your</span> <span class="string">github</span> <span class="string">useremail</span>  <span class="comment"># (or delete this input setting to use bot account)</span></span><br><span class="line">        <span class="attr">commit_msg:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span>  <span class="comment"># (or delete this input setting to use hexo default settings)</span></span><br><span class="line">    <span class="comment"># Use the output from the `deploy` step(use for test action)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">the</span> <span class="string">output</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; steps.deploy.outputs.notify &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一键部署</strong></p>
<ul>
<li><p>新建一个空的 repository（没有init任何内容）。你的 repository 必须直接命名为 <code>&lt;你的 GitHub 用户名.github.io&gt;</code>。从而能通过 <code>&lt;你的 GitHub 用户名.github.io&gt;</code> 域名直接访问你的blog。</p>
</li>
<li><p>安装 hexo-deployer-git。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>_config.yml</code>配置。</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li><p>生成站点文件并推送至远程库。执行 <code>hexo clean</code> &amp;  <code>hexo deploy</code>。</p>
</li>
<li><p>登入 Github，在库设置（Repository Settings）中将默认分支设置为<code>_config.yml</code>配置中的分支名称。稍等片刻（Blog 不会立马加载出来，需多刷新几下），您的站点就会显示在您的Github Pages中。</p>
</li>
<li><p>这是如何发生的：当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p>
</li>
<li><p>部署分支与写作分支：<code>hexo d</code> 部署到 GitHub 的是 hexo 编译后的文件，不包含源文件。可以利用git的分支管理，将源文件上传到 GitHub。一个好的实践是放在两个不同的 Git 仓库中。</p>
</li>
</ul>
<h5 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h5><p>创建 Hexo 主题非常容易，您只要在 <code>themes</code> 文件夹内，新增一个任意名称的文件夹，并修改 <code>_config.yml</code> 内的 <code>theme</code> 设定，即可切换主题。</p>
<ul>
<li><code>_config.yml</code>：主题的配置文件。和 Hexo 配置文件不同，主题配置文件修改时会自动更新，无需重启 Hexo Server。</li>
<li><code>languages</code>：语言文件夹。</li>
<li><code>layout</code>：布局文件夹。</li>
<li><code>scripts</code>：脚本文件夹。</li>
<li><code>source</code>：资源文件夹。</li>
</ul>
<p>在 GitHub 搜索 Hexo 即可找到流行的 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">Hexo 主题<i class="fa fa-external-link-alt"></i></span>。各主题都有相应的使用文档。</p>
<h3 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzLw==">NexT<i class="fa fa-external-link-alt"></i></span></h3><h5 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h5><p><strong>Installation</strong></p>
<ul>
<li><p>Installation</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo-site</span><br><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure></li>
<li><p>Usage, theme config file</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure></li>
<li><p>Update</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo-site</span><br><span class="line">npm update hexo-theme-next</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Configuration</strong></p>
<p>Installed through npm</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>
<h5 id="Theme-Settings"><a href="#Theme-Settings" class="headerlink" title="Theme Settings"></a>Theme Settings</h5><p><em>Choosing Scheme</em>: </p>
<p>By using Scheme NexT gives you different views. And nearly all config can be used by those Schemes. </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br></pre></td></tr></table></figure>
<p><em>Configuring Favicon</em>: </p>
<p>By default the Hexo site use NexT favicons in <code>hexo-site/themes/next/source/images/</code> directory with different size for different device. </p>
<p>You can replace them with your own favicons.</p>
<p>For example, you can put your favicons in <code>hexo-site/source/images/</code> directory. Then you need to rename them and change the settings in favicon section in theme config file.</p>
<p><em>Creative Commons</em>:</p>
<p>NexT supports the display of <em>Creative Commons 4.0 International License</em> in sidebar and post.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">en</span></span><br></pre></td></tr></table></figure>
<p>通行的版权协议是一种限制性的协议，就是说，只有它明文许可你可以做的事，你才能做，否则就是侵权行为。</p>
<p>而”开放内容许可证”（open content licenses）只明文禁止使用者不能做的事，除此以外，可以随意使用这些作品。创作共用许可证（Creative Commons licenses，简称cc），就是这样一种许可证。</p>
<p>使用创作共用许可证，作者可以选择保留四种权利：</p>
<ol>
<li>署名（Attribution，简写为by）：必须提到原作者。</li>
<li>非商业用途（Noncommercial，简写为nc）：不得用于盈利性目的。</li>
<li>禁止演绎（No Derivative Works，简写为nd）：不得修改原作品。</li>
<li>相同方式共享（Share Alike，简写为sa）：如果允许修改原作品，那么必须使用相同的许可证发布。</li>
</ol>
<p><em>Configuring Menu Items</em>:</p>
<p>Menu settings items have format <code>Key: /link/ || icon</code> which contains 3 values:</p>
<ul>
<li>Key → is the name of menu item (home, archives, etc.).</li>
<li>/link/ → is the target link to relative url inside your site.</li>
<li>icon → is the name of <span class="exturl" data-url="aHR0cHM6Ly9mb250YXdlc29tZS5jb20v">Font Awesome icon<i class="fa fa-external-link-alt"></i></span>.</li>
</ul>
<p>To customize menu items, edit the following content in theme config file:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL3RoZW1lLXNldHRpbmdzL2N1c3RvbS1wYWdlcy5odG1s">Google Calendar Page<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">schedule:</span> <span class="string">/schedule/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-calendar</span></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWdlbmVyYXRvci1zaXRlbWFw">sitemap<i class="fa fa-external-link-alt"></i></span>：为了让博文被google或百度检索，需要使用hexo的sitemap功能。 </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Install</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li>
<li><p>Hexo Config</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure>
<p>Except home and archives, all custom pages under menu section need to be created manually!</p>
</li>
</ul>
<p><strong>Sidebar Setting</strong></p>
<p><em>Configuring Avatar</em>：</p>
<p>Put your avatar under site directory <code>source/uploads/</code> (create directory if it doesn’t exists).And then change option to <code>url: /uploads/avatar.png</code>.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/uploads/avatar.png</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>点击头像回到首页：</p>
<p>主要是将<code>&lt;img class=&quot;site-author-image&quot; ... /&gt;</code>加入到<code>&lt;a href=&quot;/&quot;&gt;&lt;/a&gt;</code>。</p>
<p><em>Sidebar Social Links</em>：</p>
<ul>
<li><p>Edit the <code>social</code> section in theme config file as following:</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@example.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br></pre></td></tr></table></figure></li>
<li><p>取消社交图标前的小圆点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># create hexo-site&#x2F;source&#x2F;_data&#x2F;styles.styl</span><br><span class="line">.links-of-author a,</span><br><span class="line">.links-of-author .exturl &#123;</span><br><span class="line">  &amp;:before &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>Sidebar Blogrolls</em> (友链):</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">Title1:</span> <span class="string">https://example.com/</span></span><br></pre></td></tr></table></figure>
<p><em>Sidebar TOC</em>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>Footer</strong></p>
<p><em>Site Footer Icon</em>:</p>
<p>By default NexT shows red heart icon between year and copyright information in the footer. </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><em>Site Copyright Name</em>:</p>
<p>By default NexT shows the name of author from site config file. </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">YourName</span></span><br></pre></td></tr></table></figure>
<p><em>Site Platform Information</em>:</p>
<p>By default NexT shows Hexo and Theme &amp; scheme information.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><em>Site Beian Information</em>:</p>
<p>Beian information is for Chinese users.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">icp:</span> <span class="string">京ICP备</span> <span class="number">1234567890</span><span class="string">号-1</span></span><br><span class="line">    <span class="attr">gongan_id:</span> <span class="number">1234567890</span></span><br><span class="line">    <span class="attr">gongan_num:</span> <span class="string">京公网安备</span> <span class="number">1234567890</span><span class="string">号</span></span><br><span class="line">    <span class="attr">gongan_icon_url:</span> <span class="string">/uploads/beian.png</span></span><br></pre></td></tr></table></figure>
<p><strong>Post Settings</strong></p>
<p><em>Preamble Text</em>:</p>
<p>You can use following ways to show summary of articles and a Read More button.</p>
<p>Use <code>&lt;!-- more --&gt;</code> in your article to break your article manually, which is recommended by Hexo. (recommended)</p>
<p>If you have added <code>description</code> and set its value to your article summary in front-matter, NexT excerpts <code>description</code> as preamble text in homepage by default. Without <code>description</code>, the full contents would be the preamble text in homepage.</p>
<p><em>Post Wordcount</em>:</p>
<ul>
<li><p>Installation</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo-site</span><br><span class="line">npm install hexo-word-counter</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li>
<li><p>Hexo Config</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span>	<span class="comment"># By default NexT shows the number of all posts words in footer section.</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span>		<span class="comment"># By default NexT shows the estimated reading time of all posts in footer section. </span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>Donate Settings</em>:</p>
<ul>
<li><p>Get your WeChat / Alipay receive money QRcode image(s) and put into <code>source/images</code> .</p>
</li>
<li><p>Set needed values in <code>theme config file</code>:</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">Buy</span> <span class="string">me</span> <span class="string">a</span> <span class="string">coffee</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>Follow Me</em>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">follow_me:</span></span><br><span class="line">  <span class="attr">WeChat:</span> <span class="string">/images/wechat_channel.jpg</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-weixin</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure>
<ul>
<li>安装RSS插件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-generator-feed</span><br></pre></td></tr></table></figure>
<ul>
<li>配置站点配置文件(/_config.yml)的Extensions</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugin:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment"># Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编辑主题配置文件(/theme/next/_config.yml)的<code>social links</code>，开启RSS的页面功能</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关注RSS：把 <code>https://vanehsiung.github.io/atom.xml</code> 复制到RSS阅读器上，就能关注了。</li>
</ul>
<p><strong>Custom Pages</strong></p>
<p><em>Custom Page Support</em>:</p>
<ul>
<li><p>Adding New Page</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo-site</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li><p>Setting Front-matter Values</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    ---</span><br><span class="line">    title: Tags</span><br><span class="line">    date: title: 2020-11-14 22:50:2</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">    ---</span><br></pre></td></tr></table></figure>
</li>
<li><p>Editting Menu</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>Custom 404 Page</em>:</p>
<ul>
<li><p>Create a new page called 404</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo-site</span><br><span class="line">hexo new page 404</span><br><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">permalink: &#x2F;404.html		# 在 Github Docs 中 Github Pages 章有写</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li><p>Make sure relative_link is disabled in site config file</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li><p>Whether users can be redirected to the 404 page depends on the settings of the website hosting service or web server, not Hexo. </p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZnJlZS1wcm8tdGVhbUBsYXRlc3QvZ2l0aHViL3dvcmtpbmctd2l0aC1naXRodWItcGFnZXMvY3JlYXRpbmctYS1jdXN0b20tNDA0LXBhZ2UtZm9yLXlvdXItZ2l0aHViLXBhZ2VzLXNpdGU=">为 GitHub Pages 站点创建自定义 404 页面<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p><strong>Misc Theme Settings</strong></p>
<p><em>Mobile Devices Adaptation</em>:</p>
<p>reduce padding/margin indents on devices with narrow width</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><em>Codeblock Style</em>:</p>
<p>NexT uses the <span class="exturl" data-url="aHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcv">Highlight.js<i class="fa fa-external-link-alt"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9wcmlzbWpzLmNvbS8=">Prism<i class="fa fa-external-link-alt"></i></span> package to support code highlight</p>
<ul>
<li><p>Read Hexo’s documentation on <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc3ludGF4LWhpZ2hsaWdodA==">Syntax Highlighting<i class="fa fa-external-link-alt"></i></span> first, and set it up in site config file（在 <code>_config.yml</code> 中开启 Highlight 或 Prism）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>Preview all available Code Highlight themes here: <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9oaWdobGlnaHQv">NexT Highlight Theme Preview<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Change the value of theme and prism to choose the highlight style you like</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">xcode</span></span><br></pre></td></tr></table></figure>
<p>NexT supports the copy-and-paste functionality of codeblock</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span>		<span class="comment"># Mac Panel风格代码块</span></span><br></pre></td></tr></table></figure>
<p><em>Back To Top</em>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><em>Fonts Customization</em>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://fonts.loli.net</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Architects</span> <span class="string">Daughter,</span> <span class="string">Ma</span> <span class="string">Shan</span> <span class="string">Zheng</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Share</span> <span class="string">Tech</span> <span class="string">Mono</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>host：查看字体与使用字体的网址是不一样的；可能不能查看字体，但可以使用字体</p>
<ul>
<li><p>查看 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9mb250cw==">Google Fonts<i class="fa fa-external-link-alt"></i></span>，使用 Google Fonts <code>https://fonts.googleapis.com</code>，以下为镜像</p>
<ul>
<li><p><code>https://fonts.loli.net</code></p>
</li>
<li><p><code>https://fonts.googleapis.cnpmjs.org</code></p>
</li>
<li><p><code>https://fonts.proxy.ustclug.org</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>查看<span class="exturl" data-url="aHR0cDovL3d3dy5nb29nbGVmb250cy5jbi9lbmdsaXNo">谷歌字体中文版<i class="fa fa-external-link-alt"></i></span>，使用 <code>https://fonts.font.im</code></p>
</li>
<li><p>技巧：先放 latin 文字，再放 chinese 文字，就可以分别定制英文与中文（有些中文字体包含英文字母）。手机无法显示自定义的中文字体，但可以显示自定义的英文字体。</p>
</li>
</ul>
<p><strong>SEO</strong></p>
<p><em>SEO Setting</em>:</p>
<p>Next provides useful options for better Search Engine Optimization (SEO).</p>
<p>By default a canonical link tag is created in Hexo after you have set up your URL <code>url: http://example.com</code> in site config file.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># theme config file</span></span><br><span class="line"><span class="attr">disable_baidu_transformation:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><em>Webmaster Tools</em>:</p>
<ul>
<li><p>Google Webmaster Tools</p>
<ul>
<li><p>Login to <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3Rvb2xz">Google Webmaster Tools<i class="fa fa-external-link-alt"></i></span> and go to verification methods and choose <code>HTML Tag</code>, you will get some code:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;google-site-verification&quot; content&#x3D;&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Copy <code>XXXXXXXXXXXXXXXXXXXXXXX</code> value of <code>content</code> key.Edit theme config file and add or change <code>google_site_verification</code> section:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">google_site_verification:</span> <span class="string">XXXXXXXXXXXXXXXXXXXXXXX</span></span><br></pre></td></tr></table></figure></li>
<li><p>submit sitemap</p>
</li>
<li><p>That the new console says ‘couldnt fetch’ is a bug in the console. Pending is the real status!</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Bing Webmaster Tools</p>
<ul>
<li><p>Login to <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmluZy5jb20vd2VibWFzdGVyLw==">Bing Webmaster Tools<i class="fa fa-external-link-alt"></i></span> and go to verification methods and choose <code>HTML Tag</code>, you will get some code:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;msvalidate.01&quot; content&#x3D;&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Copy <code>XXXXXXXXXXXXXXXXXXXXXXX</code> value of <code>content</code> key. Edit theme config file and add or change <code>bing_site_verification</code> section:</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">bing_site_verification:</span> <span class="string">XXXXXXXXXXXXXXXXXXXXXXX</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>submit sitemap</p>
</li>
<li><p>Bing 收录最快，立马就可以看到</p>
</li>
</ul>
</li>
<li><p>Baidu Webmaster Tools</p>
<ul>
<li><p>Login to <span class="exturl" data-url="aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tL3NpdGUvIy8=">Baidu Webmaster Tools<i class="fa fa-external-link-alt"></i></span> and go to verification methods and choose <code>HTML Tag</code>, you will get some code:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;baidu-site-verification&quot; content&#x3D;&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Copy <code>XXXXXXXXXXXXXXXXXXXXXXX</code> value of <code>content</code> key.Edit theme config file and add or change <code>baidu_site_verification</code> section:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_site_verification:</span> <span class="string">XXXXXXXXXXXXXXXXXXXXXXX</span></span><br></pre></td></tr></table></figure></li>
<li><p>Push the url to baidu automatically</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>submit sitemap</p>
</li>
</ul>
</li>
</ul>
<h5 id="Third-party-Services"><a href="#Third-party-Services" class="headerlink" title="Third-party Services"></a>Third-party Services</h5><p><strong>Comment Systems</strong></p>
<p><em>LiveRe (Korea)</em>:</p>
<ul>
<li><p>Create an account or log into <span class="exturl" data-url="aHR0cHM6Ly9saXZlcmUuY29tLw==">LiveRe<i class="fa fa-external-link-alt"></i></span>, click on the <code>installation</code> button and select the free city version, then click on the <code>install now</code> button.</p>
</li>
<li><p>Copy the <code>data-uid</code> field in the installation code to get your LiveRe UID.</p>
</li>
<li><p>Add the obtained LiveRe UID to the <code>livere_uid</code> section in the theme config file as following:</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livere_uid:</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<p>*Valine (China)*：</p>
<ul>
<li><p>Create an account or log into <span class="exturl" data-url="aHR0cHM6Ly9sZWFuY2xvdWQuY24v">LeanCloud<i class="fa fa-external-link-alt"></i></span>, and then click on the bottom left corner to create the application in dashboard.</p>
</li>
<li><p>Go to the application you just created, select <code>Settings → App Keys</code> in the lower left corner, and you will see your APP ID and APP Key.</p>
</li>
<li><p>Edit configurations in <code>valine</code> section in the theme config file as following:</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appId:</span> </span><br><span class="line">  <span class="attr">appKey:</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>评论数据管理：请自行登录<code>Leancloud应用</code>管理。具体步骤：<code>登录</code>&gt;<code>选择你创建的应用</code>&gt;<code>存储</code>&gt;选择Class <code>Comment</code></p>
</li>
</ul>
<p><strong>Statistics and Analytics</strong></p>
<p><em>Analytics Tools</em>:</p>
<ul>
<li><p>Baidu Analytics (China)</p>
<ul>
<li><p>Login to <span class="exturl" data-url="aHR0cHM6Ly90b25namkuYmFpZHUuY29tLw==">Baidu Analytics<i class="fa fa-external-link-alt"></i></span> and locate to site code getting page.</p>
</li>
<li><p>Copy the script ID after <code>hm.js?</code>.</p>
</li>
<li><p>Edit theme config file and change section <code>baidu_analytics</code> to your script ID.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Google Analytics</p>
<ul>
<li><p>Create an account and log into <span class="exturl" data-url="aHR0cHM6Ly9hbmFseXRpY3MuZ29vZ2xlLmNvbS8=">Google Analytics<i class="fa fa-external-link-alt"></i></span>.</p>
</li>
<li><p>Edit theme config file and fill <code>tracking_id</code> under section <code>google_analytics</code> with your Google track ID. Google track ID always starts with <code>UA-</code> (最新版 Google Analytics 是 <code>G-</code>).</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span> <span class="string">G-XXXXXXXX</span></span><br><span class="line">  <span class="attr">only_pageview:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><em>Counting Tools</em>:</p>
<p>Busuanzi Counting (China), Edit busuanzi_count option in theme config file.</p>
<p>不蒜子是基于域名来进行统计计算的。数据比百度统计多很多。网络不好的话，数据与图标不一定显示得出来。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>Search Services</strong></p>
<p><em>Local Search</em>:</p>
<p>This search method is recommended for most users.</p>
<ul>
<li><p>Installation</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure></li>
<li><p>Hexo Config</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure></li>
<li><p>NexT Config</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>External Libraries</strong></p>
<p><em>PJAX</em>：</p>
<ul>
<li><p>You can enable it by setting value <code>pjax</code> to <code>true</code> in <code>theme config file</code>.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>It listens to every click on links you want (by default all of them).When an internal link is clicked, Pjax fetches the page’s HTML via AJAX.</p>
</li>
<li><p>Please use the absolute path of the image or <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdGFnLXBsdWdpbnMjSW5jbHVkZS1Bc3NldHM=">Hexo asset_img tag<i class="fa fa-external-link-alt"></i></span> in your posts, otherwise the images may fail to load during Pjax refresh.</p>
</li>
<li><p>例子：添加音乐播放器并保持跳转时不中断播放状态；fireworks 特效更流畅，不存在点击链接时的卡顿现象（点击链接时不会触发fireworks）。</p>
</li>
</ul>
<p><em>Fancybox</em>:</p>
<p>A jQuery lightbox script for displaying images, videos and more.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/ApoorvSaxena/lozad.js"><em>Lazyload</em></a>:</p>
<p>It delays loading of images in long web pages. Images outside of viewport will not be loaded before user scrolls to them.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lazyload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><em>Progress Bar</em>:</p>
<p>NProgress will automatically monitor your Ajax requests, event loop lag, document ready state and elements on your page to decide on the progress.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nprogress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">spinner:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><em>Canvas Ribbon</em>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span>			<span class="comment"># The width of the ribbon.</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span>		<span class="comment"># The transparency of the ribbon.</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span>		<span class="comment"># The display level of the ribbon.</span></span><br></pre></td></tr></table></figure>
<p><em>粒子漂浮聚合</em>：</p>
<p>该功能由 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1jYW52YXMtbmVzdA==">theme-next-canvas-nest<i class="fa fa-external-link-alt"></i></span> 插件提供：</p>
<ul>
<li><p>Create a file named <code>footer.njk </code> in <code>hexo/source/_data</code> directory, Edit this file and add the following content</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script color&#x3D;&quot;0,0,255&quot; opacity&#x3D;&quot;0.5&quot; zIndex&#x3D;&quot;-1&quot; count&#x3D;&quot;99&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;canvas-nest.js@1&#x2F;dist&#x2F;canvas-nest.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>In the NexT <code>_config.yml</code>, uncomment <code>footer</code> under the <code>custom_file_path</code> section.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.njk</span></span><br></pre></td></tr></table></figure>
<h5 id="Tag-Plugins"><a href="#Tag-Plugins" class="headerlink" title="Tag Plugins"></a>Tag Plugins</h5></li>
</ul>
<p><a href="https://github.com/mermaid-js/mermaid"><strong>Mermaid</strong></a></p>
<ul>
<li>Settings  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>Usage  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid type %&#125;</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Advanced-Settings"><a href="#Advanced-Settings" class="headerlink" title="Advanced Settings"></a>Advanced Settings</h5></li>
</ul>
<p><strong>Custom Files</strong></p>
<ul>
<li><p>uncomment under the section in <code>theme config file</code>.<code>stylecustom_file_path</code>。</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.njk</span></span><br><span class="line">  <span class="attr">header:</span> <span class="string">source/_data/header.njk</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure></li>
<li><p>Edit in site root directory and add files:<code>source/_data/...</code>。</p>
</li>
<li><p>Then use it。</p>
</li>
<li><p>Stylus 是 CSS 的预处理框架，给 CSS 添加了可编程的特性。Stylus支持三种注释，单行注释（<code>//</code>)，多行注释(<code>/* */</code>)。</p>
</li>
<li><p>Nunjucks 是 jinja2 的 javascript 的实现，可以使用 <code>&#123;#` and `#&#125;</code> 来写注释，渲染时将会去除所有的注释。</p>
</li>
<li><p>不要直接修改 model 文件，而要使用 custom file，方便之后升级。</p>
</li>
</ul>
<p><strong>Front Matter</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">photos: &#x2F;uploads&#x2F;png.png</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="Misc-Settings"><a href="#Misc-Settings" class="headerlink" title="Misc Settings"></a>Misc Settings</h3><p>想要什么功能可以搜一下，看是否有现成的 model 可以使用。</p>
<p><strong>网易云音乐</strong></p>
<ul>
<li>在网页版云音乐中找到歌曲，点击生成外链播放器</li>
<li>根据个人喜好选择播放器尺寸和播放模式</li>
<li>将获取到的 iframe 代码添加到页面中</li>
</ul>
<p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RJWWdvZC9BUGxheWVy">Aplayer<i class="fa fa-external-link-alt"></i></span> 音频播放器</strong></p>
<ul>
<li><p>借助 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9oZXhvLXRhZy1hcGxheWVy">hexo-tag-aplayer<i class="fa fa-external-link-alt"></i></span> 插件，可以通过标签的形式方便快捷的插入音频组件。</p>
</li>
<li><p>Installation</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure></li>
<li><p>Usage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;title&quot; &quot;author&quot; &quot;url&quot; [&quot;picture_url&quot;, &quot;narrow&quot;, &quot;autoplay&quot;, &quot;width:xxx&quot;, &quot;lrc:xxx&quot;] %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>title: 曲目标题</li>
<li>author: 曲目作者</li>
<li>url: 音乐文件 URL 地址</li>
<li>picture_url: (可选) 音乐对应的图片地址</li>
<li>narrow: （可选）播放器袖珍风格</li>
<li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li>
<li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li>
<li>lrc:xxx: （可选）歌词文件 URL 地址</li>
</ul>
</li>
<li><p>当开启 Hexo 的 文章资源文件夹功能时，可直接引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RJWWdvZC9EUGxheWVy">Dpalyer<i class="fa fa-external-link-alt"></i></span> 视频播放器</strong></p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9oZXhvLXRhZy1kcGxheWVy">Installation<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure></li>
<li><p>Usage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer &quot;url&#x3D;video-url&quot; &quot;pic&#x3D;image-url&quot; ... [&quot;key&#x3D;value&quot;] %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>部分重要 key</p>
<ul>
<li>播放器<ul>
<li>autoplay：是否开启视频自动播放，默认为 <code>fasle</code></li>
<li>loop：是否开启视频循环播放，默认为 <code>false</code></li>
<li>screenshot：是否开启截图，默认为 <code>false</code></li>
<li>mutex：是否禁止多个播放器同时播放，默认为 <code>true</code></li>
<li>dmunlimited：是否开启海量弹幕模式，默认为 <code>false</code></li>
<li>preload：预加载模式，可选 <code>note</code> <code>metadata</code> <code>auto</code></li>
<li>theme：主题色</li>
<li>lang：语言，可选 <code>en</code> <code>zh-cn</code> <code>zh-tw</code></li>
<li>logo：左上角的 Logo</li>
<li>volume：默认音量，默认为 0.7</li>
<li>width：播放器宽度</li>
<li>height：播放器长度</li>
</ul>
</li>
<li>视频<ul>
<li>url：视频链接</li>
<li>pic：视频封面</li>
<li>thumbnails：视频缩略图，可以使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9EUGxheWVyLXRodW1ibmFpbHM=">DPlayer-thumbnails<i class="fa fa-external-link-alt"></i></span> 生成</li>
<li>vidtype：视频类型，可选 <code>auto</code> <code>hls</code> <code>flv</code> <code>dash</code> 或其他自定义类型</li>
</ul>
</li>
<li>字幕<ul>
<li>suburl：字幕链接</li>
<li>subtype：字幕类型，可选 <code>webvtt</code> <code>ass</code>，目前只支持 <code>webvtt</code></li>
<li>subbottom：字幕距离播放器底部的距离，如 <code>10px</code> <code>10%</code></li>
<li>subcolor：字幕颜色</li>
</ul>
</li>
<li>弹幕<ul>
<li>id：弹幕 id</li>
<li>api：弹幕 api</li>
<li>token：弹幕后端验证 token</li>
<li>addition：额外外挂弹幕</li>
<li>dmuser：弹幕用户名</li>
<li>maximum：弹幕最大数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>看板娘</strong></p>
<p>该功能由 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk">hexo-helper-live2d<i class="fa fa-external-link-alt"></i></span> 插件支持</p>
<ul>
<li><p>Installation</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure></li>
<li><p>Config：在站点配置文件中设置，主题配置文件中设置没用</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-shizuku</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure></li>
<li><p>Models：可以从 <span class="exturl" data-url="aHR0cHM6Ly9odWFqaTgudG9wL3Bvc3QvbGl2ZTJkLXBsdWdpbi0yLjAv">hexo live2d 模型预览<i class="fa fa-external-link-alt"></i></span> 里找到你喜欢的角色，然后根据 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYXpleXUvbGl2ZTJkLXdpZGdldC1tb2RlbHM=">live2d-widget-models<i class="fa fa-external-link-alt"></i></span> 中提供的方法来下载模型数据.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/next-theme/hexo-next-fireworks"><strong>Fireworks</strong></a></p>
</li>
</ul>
<p>一个鼠标点击动画特效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install next-theme/hexo-next-fireworks</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/suyin-long/activate-power-mode"><strong>activate-power-mode</strong></a></p>
<p>一个为博客添加酷炫打字特效的插件</p>
<ul>
<li><p>编辑 <code>/hexo-site/source/_data/footer.njk</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;suyin-long&#x2F;activate-power-mode@1.0&#x2F;dist&#x2F;activate-power-mode.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">POWERMODE.colorful &#x3D; true; &#x2F;&#x2F; make power mode colorful</span><br><span class="line">POWERMODE.shake &#x3D; false; &#x2F;&#x2F; turn off shake</span><br><span class="line">document.body.addEventListener(&#39;input&#39;, POWERMODE);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>取消<code>footer: source/_data/footer.njk</code>的注释</p>
</li>
</ul>
<p><strong>搞怪网页标题</strong></p>
<ul>
<li><p>编辑 <code>/hexo-site/source/_data/head.njk</code>，添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;# 搞怪网页标题 #&#125; &#123;% if theme.title_trick.enable %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var OriginTitile &#x3D; document.title;</span><br><span class="line">  var titleTime;</span><br><span class="line">  document.addEventListener(&quot;visibilitychange&quot;, function() &#123;</span><br><span class="line">    if (document.hidden) &#123;</span><br><span class="line">      document.title &#x3D; &quot;&#123;&#123; theme.title_trick.leave &#125;&#125;&quot;;</span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      document.title &#x3D; &quot;&#123;&#123; theme.title_trick.enter &#125;&#125;&quot;;</span><br><span class="line">      titleTime &#x3D; setTimeout(function() &#123;</span><br><span class="line">        document.title &#x3D; OriginTitile;</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在主题配置文件中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a trick on website title</span></span><br><span class="line"><span class="attr">title_trick:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">leave:</span> <span class="string">&quot;(つェ⊂)我藏好了哦~&quot;</span></span><br><span class="line">  <span class="attr">enter:</span> <span class="string">&quot;(*´∇｀*) 被你发现啦~&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我先是放在 <code>sorce/_data/head.njk</code> 中，问题是改变一次标题后就只显示网址。我认为 script 可能在 <code>&lt;title&gt;</code> 之前加载，所以就放在 <code>source/_data/header.njk</code>，正常运行。</p>
</li>
</ul>
<p><a href="https://github.com/next-theme/hexo-next-three"><strong>Hexo NexT Three</strong></a></p>
<ul>
<li><p>Install</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install next-theme/hexo-next-three</span><br></pre></td></tr></table></figure></li>
<li><p>Configure</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-next-three</span></span><br><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">defer:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span></span><br><span class="line">  <span class="attr">waves:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">cdn:</span></span><br><span class="line">  <span class="attr">lines:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">cdn:</span></span><br><span class="line">  <span class="attr">sphere:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">cdn:</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/jiangtj-lab/hexo-cake-moon-menu"><strong>hexo-cake-moon-menu</strong></a></p>
</li>
<li><p>How to use</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cake-moon-menu</span><br></pre></td></tr></table></figure></li>
<li><p>Config: In hexo <code>_config.yml</code> </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">moon_menu:</span></span><br><span class="line">  <span class="attr">back2top:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-chevron-up</span></span><br><span class="line">    <span class="attr">func:</span> <span class="string">back2top</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">back2bottom:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-chevron-down</span></span><br><span class="line">    <span class="attr">func:</span> <span class="string">back2bottom</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>permalink</strong></p>
<ul>
<li><p>默认的文章 url 地址为 <code>http://yoursite.com/:year/:month/:day/:title/</code>，这种 url 格式层级太多，并且如果文章标题是中文的话可能会发生转义而出现一堆乱码，不利于搜索引擎的爬取分析，因此建议在站点配置中修改 <code>permalink</code> 的格式来简化页面 url，并尽量采用英文命名 Markdown 文件。(这个根据个人选择，我认为有更有组织的文件结构更重要)</p>
</li>
<li><p>这个 front matter 必须是 html 文件，文件会生成到 public 根目录。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">permalink: &#x2F;post-name.html</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>robots.txt</strong></p>
<p>robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。</p>
<p><span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9yb2JvdHMv">robots.txt在线生成器<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN 的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络“边缘”的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。</p>
<img data-src="/2020/12/10/Hexo/CDN.webp" class="" title="CDN">

<h5 id="CDN-工作原理"><a href="#CDN-工作原理" class="headerlink" title="CDN 工作原理"></a>CDN 工作原理</h5><p>传统访问过程：</p>
<img data-src="/2020/12/10/Hexo/CDN1.webp" class="" title="CDN">

<ol>
<li>用户输入访问的域名，操作系统向 LocalDns 查询域名的ip地址</li>
<li>LocalDns 向 ROOT DNS 查询域名的授权服务器（这里假设LocalDns缓存过期）</li>
<li>ROOT DNS 将域名授权 dns 记录回应给 LocalDns</li>
<li>LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 ip 地址</li>
<li>域名授权 dns 查询域名记录后，回应给 LocalDns</li>
<li>LocalDns 将得到的域名 ip 地址，回应给用户端</li>
<li>用户得到域名 ip 地址后，访问站点服务器</li>
<li>站点服务器应答请求，将内容返回给客户端</li>
</ol>
<p>CDN 访问过程：</p>
<img data-src="/2020/12/10/Hexo/CDN2.webp" class="" title="CDN">

<ol>
<li>用户输入访问的域名，操作系统向 LocalDns 查询域名的 ip 地址</li>
<li>LocalDns 向 ROOT DNS 查询域名的授权服务器（这里假设LocalDns缓存过期）</li>
<li>ROOT DNS 将域名授权 dns 记录回应给 LocalDns</li>
<li>LocalDns 得到域名的授权 dns 记录后，继续向域名授权 dns 查询域名的 ip 地址</li>
<li>域名授权 dns 查询域名记录后（一般是CNAME），回应给 LocalDns</li>
<li>LocalDns 得到域名记录后，向智能调度 DNS 查询域名的 ip 地址</li>
<li>智能调度 DNS 根据一定的算法和策略，将最适合的 CDN 节点 ip 地址回应给 LocalDns</li>
<li>LocalDns 将得到的域名 ip 地址，回应给用户端</li>
<li>用户得到域名 ip 地址后，访问站点服务器</li>
<li>CDN 节点服务器应答请求，将内容返回给客户端</li>
</ol>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xZGFlNmUxNjgwZmY=">CDN加速原理<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>npm makes it easy for JavaScript developers to share and reuse code, and it makes it easy to update the code that you’re sharing.</p>
<p>基本：</p>
<ul>
<li><p>package.json 和 package-lock.json</p>
<ul>
<li>package.json 执行 npm init 命令生成，描述项目模块信息</li>
<li>package-lock.json 执行 npm install 命令生成，描述模块来源及依赖信息，可删除</li>
</ul>
</li>
<li><p>安装模块：读取 package.json 并下载模块到 <code>node_modules</code> 的目录，模块分为两类 dependencies 和devDependencies，分别对应生产环境需要的安装包和开发环境需要的安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line"># 在安装模块的时候，可以通过指定参数来修改 package.json 文件</span><br><span class="line">npm install &lt;package_name&gt; --save</span><br><span class="line">npm install &lt;package_name&gt; --save-dev</span><br></pre></td></tr></table></figure></li>
<li><p>更新模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update</span><br></pre></td></tr></table></figure></li>
<li><p>卸载模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line"># 卸载模块的同时，也从 package.json 文件中移除</span><br><span class="line">$ npm uninstall --save &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>解决问题：</p>
</li>
<li><p>Ubuntu 安装最新 LTS 版本：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9oZWxwL3dpa2kvSW5zdGFsbGF0aW9u">官方教程<i class="fa fa-external-link-alt"></i></span>，Windows 版本更好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs</span><br><span class="line">sudo tar -xJvf node-$VERSION-$DISTRO.tar.xz -C &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs</span><br><span class="line">vi ~&#x2F;.profile</span><br><span class="line"># Nodejs</span><br><span class="line">VERSION&#x3D;v10.15.0</span><br><span class="line">DISTRO&#x3D;linux-x64</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-$VERSION-$DISTRO&#x2F;bin:$PATH</span><br><span class="line">. ~&#x2F;.profile		# Refresh profile</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-$VERSION-$DISTRO&#x2F;bin&#x2F;node  &#x2F;usr&#x2F;bin&#x2F;node</span><br></pre></td></tr></table></figure></li>
<li><p>查看 npm 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config list -l</span><br><span class="line">npm config ls</span><br></pre></td></tr></table></figure></li>
<li><p>配置镜像：淘宝镜像不好用，特对对于 update</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npmjs.org --global</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 NPM 不做严格的 SSL 校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set strict-ssl false</span><br></pre></td></tr></table></figure></li>
<li><p>npm ERR! Unexpected end of JSON input while parsing near …</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure></li>
<li><p>npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents：不管</p>
</li>
<li><p>npm ERR! code EINTEGRITY</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -ir &quot;sha1-WYr+VHVbKGilMw0q&#x2F;51Ou1Mgm2U&quot; ~&#x2F;.npm		# wanted sha1</span><br><span class="line">npm cache clean --force</span><br><span class="line">grep -ir &quot;sha1-WYr+VHVbKGilMw0q&#x2F;51Ou1Mgm2U&quot; ~&#x2F;.npm</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>getaddrinfo EAI_AGAIN registry.npmjs.org：网络问题，重新运行 <code>npm install</code></p>
</li>
<li><p>升级为最新稳定版本的 node.js：超慢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm cache clean -f</span><br><span class="line">sudo npm install -g n		# n 是 Node版本管理控制器</span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2FuY2xvdWQuY24vc2hlbGx3YXkvbnBtLWRvYw==">NPM 中文文档<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h3 id="Great-Blogs"><a href="#Great-Blogs" class="headerlink" title="Great Blogs"></a>Great Blogs</h3><p><span class="exturl" data-url="aHR0cDovL3llYXJpdG8uY24vdGFncy9IZXhvLw==">yearito<i class="fa fa-external-link-alt"></i></span> ，<span class="exturl" data-url="aHR0cHM6Ly9zdXlpbi1ibG9nLmNsdWIvMjAyMC8zMjNFSDJZLw==">suyin<i class="fa fa-external-link-alt"></i></span> ，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnlsZWFvLmNvbS9jYXRlZ29yaWVzL0hleG8lRTYlOEElOTglRTglODUlQkUv">yleao<i class="fa fa-external-link-alt"></i></span> ，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRsemhhbmcuY29tL3Bvc3RzLzM2Lz9oaWdobGlnaHQ9aGV4bw==">dlzhang<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Version</th>
</tr>
</thead>
<tbody><tr>
<td>npm</td>
<td>7.0.8</td>
</tr>
<tr>
<td>hexo</td>
<td>5.2.0</td>
</tr>
<tr>
<td>hexo-theme-next</td>
<td>8.0.2</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>14并发</title>
    <url>/2021/04/26/14%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>读者可能已经很熟悉操作系统中的多任务（multitasking)：在同一刻运行多个程序的能力。并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程， 给人并行处理的感觉。</p>
<p>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程（ thread), 它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序（multithreaded)。</p>
<p>本质的区别在于每个进程拥有自己的一整套变量， 而线程则共享数据。这有些风险。然而，共享变量使线程之间的通信比进程之间的通信更有效、 更容易。 此外， 在有些操作系统中，与进程相比较， 线程更“ 轻量级”， 创建、 撤销一个线程比启动新进程的开销要小得多。</p>
<a id="more"></a>

<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>sleep 是 Thread 类的静态方法，用于暂停当前线程的活动。sleep 方法可以抛出一个InterruptedException 异常。</p>
<p>单线程完成一个非常耗时的工作时经常会阻塞其他任务，无法执行中断操作，失去对程序的控制权。</p>
<h5 id="使用线程给其他任务提供机会"><a href="#使用线程给其他任务提供机会" class="headerlink" title="使用线程给其他任务提供机会"></a>使用线程给其他任务提供机会</h5><p>在多线程中，由于每个线程都有机会得以运行（并行），当用户点击 Close 按钮时，事件调度线程将有机会关注到这个事件， 并处理“ 关闭” 这一动作。如果需要执行一个比较耗时的任务，应当并发地运行任务。</p>
<p>在一个单独的线程中执行一个任务的过程：</p>
<ol>
<li>将任务代码移到实现了 Runnable 接口的类的 run 方法中。Runnable 是一个函数式接口：Runnable r = () -&gt; { task code };</li>
<li>由 Runnable 创建一个 Thread 对象：Thread t = new Thread(r);</li>
<li>启动线程：t.start();</li>
</ol>
<p>也可以通过构建一个 Thread 类的子类定义一个线程，然后， 构造一个子类的对象， 并调用 start 方法。</p>
<p>不要调用 Thread 类或 Runnable 对象的 run 方法。 直接调用 run 方法， 只会执行同一个线程中的任务， 而不会启动新线程。应该调用 Thread.start 方法。这个方法将创建一个执行 ran 方法的新线程。</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返冋时，或者出现了在方法中没有捕获的异常时，线程将终止。</p>
<p>没有可以强制线程终止的方法。然而，interrupt 方法可以用来请求终止线程。</p>
<p>当对一个线程调用interrupt 方法时，线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。</p>
<p>要想弄清中断状态是否被置位，首先调用静态的 Thread.currentThread 方法获得当前线程， 然后调用 islnterrupted 方法。如果线程被阻塞， 就无法检测中断状态。当在一个被阻塞的线程（调用 sleep 或 wait) 上调用 interrupt 方法时，阻塞调用将会被Interrupted Exception 异常中断（存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用）。</p>
<p>没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。</p>
<p>如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并拋出 InterruptedException。</p>
<p>Interrupted 方法是一个静态方法， 它检测当前的线程是否被中断的同时会清除该线程的中断状态。islnterrupted 方法是一个实例方法，只能检验是否有线程被中断。</p>
<p>不要抑制InterruptedException 异常。两种合理的选择：</p>
<ul>
<li>在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。</li>
<li>用 throws InterruptedException 标记你的方法， 不采用 try语句块捕获异常。于是，调用者（或者， 最终的 run 方法）可以捕获这一异常。</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程可以有如下 6 种状态：</p>
<ul>
<li>New (新创建）</li>
<li>Runnable (可运行）</li>
<li>Blocked (被阻塞）</li>
<li>Waiting (等待）</li>
<li>Timed waiting (计时等待）</li>
<li>Terminated (被终止）</li>
</ul>
<p>要确定一个线程的当前状态， 可调用 getState 方法。</p>
<h5 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h5><p>当用 new 操作符创建一个新线程时， 该线程还没有开始运行。这意味着它的状态是 new。</p>
<h5 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h5><p>一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线程可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。</p>
<p>线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级。</p>
<p>在具有多个处理器的机器上，每一个处理器运行一个线程， 可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。</p>
<h5 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h5><p>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁， 而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用 Object.wait 方法或 Thread.join 方法， 或者是等待 java.util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。</li>
<li>有几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting ) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep 和 Object.wait、Thread.join、 Lock.tryLock 以及 Condition.await 的计时版。</li>
</ul>
<h5 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h5><p>线程因如下两个原因之一而被终止：</p>
<ul>
<li>因为 run 方法正常退出而自然死亡。</li>
<li>因为一个没有捕获的异常终止了run方法而意外死亡。</li>
</ul>
<p>可以调用线程的 stop 方法杀死一个线程。 该方法抛出 ThreadDeath 错误对象,由此杀死线程。但是，stop 方法已过时， 不要在自己的代码中调用这个方法。</p>
<p>线程状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新创建 -开始-&gt; 可运行 -运行方法exits-&gt; 被终止</span><br><span class="line">可运行 -请求锁-&gt; 被阻塞 -得到锁-&gt; 可运行</span><br><span class="line">可运行 -等待通知-&gt; 等待 -出现通知-&gt; 可运行</span><br><span class="line">可运行 -等待超时或通知-&gt; 计时等待 -出现超时或通知-&gt; 可运行</span><br></pre></td></tr></table></figure>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>在 Java 程序设计语言中，每一个线程有一个优先级。默认情况下， 一个线程继承它的父线程的优先级。可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5。</p>
<p>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。</p>
<p>不要将程序构建为功能的正确性依赖于优先级。如果有几个高优先级的线程没有进入非活动状态， 低优先级的线程可能永远也不能执行（饿死）。</p>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>可以通过调用 t.setDaemon(true); 将线程转换为守护线程（daemon thread）。守护线程的唯一用途是为其他线程提供服务。当只剩下守护线程时， 虚拟机就退出了。守护线程应该永远不去访问固有资源，因为它会在任何时候甚至在一个操作的中间发生中断。</p>
<h5 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h5><p>线程的 run方法不能抛出任何受查异常。在线程死亡之前， 异常会被传递到一个用于未捕获异常的处理器。该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类。这个接口只有—个方法：<br>void uncaughtException(Thread t, Throwable e)<br>可以用 setUncaughtExceptionHandler 方法为任何线程安装一个处理器。也可以用 Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有线程安装一个默认的处理器。如果不安装默认的处理器， 默认的处理器为空。 如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。ThreadGroup 类实现 Thread.UncaughtExceptionHandler 接口。它的 uncaughtException 方<br>法做如下操作：</p>
<ol>
<li>如果该线程组有父线程组， 那么父线程组的 uncaughtException 方法被调用。</li>
<li>否则， 如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器， 则调用该处理器。</li>
<li>否则，如果 Throwable 是 ThreadDeath 的一个实例， 什么都不做。</li>
<li>否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。</li>
</ol>
<p>线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组， 但是， 也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>两个或两个以上的线程需要共享对同一数据的存取。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为竞争条件（race condition）。</p>
<h5 id="竞争条件的一个例子"><a href="#竞争条件的一个例子" class="headerlink" title="竞争条件的一个例子"></a>竞争条件的一个例子</h5><p>为了避免多线程引起的对共享数据的讹误，须学习如何同步存取。</p>
<h5 id="竞争条件详解"><a href="#竞争条件详解" class="headerlink" title="竞争条件详解"></a>竞争条件详解</h5><p>问题在于不是原子操作。操作命令是由几条指令组成的， 执行它们的线程可以在任何一条指令点上被中断。如果能够确保线程在失去控制之前方法运行完成， 那么对象的状态永远不会出现讹误。</p>
<p>运行行命令<br>javap -c -v Bank<br>对 Bank.class 文件进行反编译。</p>
<h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><p>有两种机制防止代码块受并发访问的干扰。Java语言提供一个 synchronized 关键字达到这一目的，并且 Java SE 5.0 引入了 ReentrantLock 类。synchronized 关键字自动提供一个锁以及相关的“ 条件”。</p>
<p>用 ReentrantLock 保护代码块的基本结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myLock.lock(); <span class="comment">// a ReentrantLock object</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	critical section</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	myLock.unlock（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象， 其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象。</p>
<p>把解锁操作括在 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则， 其他线程将永远阻塞。</p>
<p>如果使用锁， 就不能使用带资源的 try 语句。首先， 解锁方法名不是 close。不过，即使将它重命名， 带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁， 你可能想使用多个线程共享的那个变量（而不是新变量）。</p>
<p>锁是可重入的， 因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（ hold count) 来跟踪对 lock 方法的嵌套调用。线程在每一次调用 lock 都要调用 unlock 来释放锁。由于这一特性， 被一个锁保护的代码可以调用另一个使用相同的锁的方法。</p>
<p>要留心临界区中的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，finally 子句将释放锁，但会使对象可能处于一种受损状态。</p>
<h5 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h5><p>使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。（由于历史的原因， 条件对象经常被称为条件变量（ conditional variable ）。）</p>
<p>一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。如果线程发现条件不满足，它调用条件对象的 await 方法，阻塞当前线程，并放弃锁。</p>
<p>一旦一个线程调用 await方法， 它进人该条件的等待集。它处于阻塞状态，直到另一个线程调用同一条件上的 signalAll 方法时为止。这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的。一旦锁成为可用的，它们中的某个将从 await 调用返回， 获得该锁并从被阻塞的地方继续执行。此时， 线程应该再次测试该条件。（signalAll 方法仅仅是通知正在等待的线程：此时有可能已经满足条件， 值得再次去检测该条件。）（对 await 的调用应该在如下形式的循环体中 while ( ! (ok to proceed) ) condition.await();）</p>
<p>如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致死锁（deadlock) 现象。所有线程都被阻塞，程序就会挂起。</p>
<p>经验上讲， 在对象的状态有利于等待线程的方向改变时调用signalAll。</p>
<p>signal 方法随机解除等待集中某个线程的阻塞状态。</p>
<h5 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h5><p>从 1.0 版开始，Java中的每一个对象都有一个内部锁。如果一个方法用 synchronized关键字声明，那么对象的锁将保护整个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	method body</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.intrinsicLock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		method body</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123; <span class="keyword">this</span>.intrinsicLock.unlock(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部对象锁只有一个相关条件。wait 方法添加一个线程到等待集中，notifyAll /notify方法解除等待线程的阻塞状态。wait、notifyAll 以及 notify 方法是 Object 类的 final 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用 wait 或 notityAll 等价于</span><br><span class="line">intrinsicCondition.await();</span><br><span class="line">intrinsicCondition.signalAll();</span><br></pre></td></tr></table></figure>
<p>将静态方法声明为 synchronized 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。</p>
<p>Lock 和 Condition 对象还是同步方法？一些建议：</p>
<ul>
<li>最好都不使用。在许多情况下你可以使用 java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。</li>
<li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。</li>
<li>如果特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition。</li>
</ul>
<h5 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h5><p>还可以通过进入一个同步阻塞获得锁。当线程进入如下形式的阻塞：<br>synchronized (obj) { critical section }<br>它获得 Obj 的锁。obj对象可以被创建为仅仅用来使用每个 Java 对象持有的锁。</p>
<p>使用一个对象的锁来实现额外的原子操作，称为客户端锁定（ client-side locking) 。但必须承诺该对象对自己的所有可修改方法都使用内部锁。</p>
<h5 id="监视器概念"><a href="#监视器概念" class="headerlink" title="监视器概念"></a>监视器概念</h5><p>监视器（monitor)在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性。监视器具有如下特性：</p>
<ul>
<li>监视器是只包含私有域的类。</li>
<li>每个监视器类的对象有一个相关的锁。</li>
<li>使用该锁对所有的方法进行加锁。</li>
<li>该锁可以有任意多个相关条件。每一个显示的条件变量管理一个独立的线程集。</li>
</ul>
<p>Java 设计者以不是很精确的方式采用了监视器概念，如果一个方法用 synchronized 关键字声明，那么，它表现的就像是一个监视器方法。然而， 在下述的 3 个方面 Java 对象不同于监视器， 从而使得线程的安全性下降：</p>
<ul>
<li>域不要求必须是 private。</li>
<li>方法不要求必须是 synchronized。</li>
<li>内部锁对客户是可用的。</li>
</ul>
<h5 id="Volatile-域"><a href="#Volatile-域" class="headerlink" title="Volatile 域"></a>Volatile 域</h5><p>使用现代的处理器与编译器， 不同步读写实例域出错的可能性很大：</p>
<ul>
<li>多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。</li>
<li>编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变。</li>
</ul>
<p>如果使用锁来保护可以被多个线程访问的代码，编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令。</p>
<p>volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。Volatile 变量不能提供原子性。</p>
<h5 id="final-变置"><a href="#final-变置" class="headerlink" title="final 变置"></a>final 变置</h5><p>还有一种情况可以安全地访问一个共享域， 即这个域声明为 final 时。</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性。Atomiclnteger 类提供了方法 incrementAndGet 和 decrementAndGet, 它们分别以原子方式将一个整数自增或自减。如果希望完成更复杂的更新，就必须使用 compareAndSet 方法。应当在一个循环中计算新值和使用 compareAndSet:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	oldValue = largest.get();</span><br><span class="line">	newValue = Math.max(oldValue, observed);</span><br><span class="line">&#125; <span class="keyword">while</span> (!largest.compareAndSet(oldValue, newValue));</span><br></pre></td></tr></table></figure>
<p>如果另一个线程也在更新 largest，就可能阻止这个线程更新。这样一来，compareAndSet会返回 false, 而不会设置新值。在这种情况下，循环会更次尝试，读取更新后的值，并尝试修改。最终， 它会成功地用新值替换原来的值。compareAndSet 方法会映射到一个处理器操作， 比使用锁速度更快。</p>
<p>在 Java SE 8 中，可以提供一个 lambda 表达式更新变量：<br>largest.updateAndGet(x -&gt; Math.max(x, observed)) ;<br>largest.accumulateAndCet(observed , Math::max);<br>accumulateAndGet 方法利用一个二元操作符来合并原子值和所提供的参数。还有 getAndUpdate 和 getAndAccumulate 方法可以返回原值。</p>
<p>如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。Java SE 8 提供了 LongAdder 和 LongAccumulator 类来解决这个问题。LongAdder 包括多个变量（加数 )，其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下， 只有当所有工作都完成之后才需要总和的值， 对于这种情况，这种方法会很高效。调用 increment 让计数器自增，或者调用 add 来增加一个量， 或者调用 sum 来获取总和。</p>
<p>LongAccumulator 将这种思想推广到任意的累加操作。在构造器中，可以提供这个操作以及它的零元素。要加人新的值， 可以调用 accumulate。调用 get 来获得当前值。在内部，这个累加器包含变量 a1, a2, …, an。每个变量初始化为零元素。调用 accumulate 并提供值 v 时，其中一个变量会以原子方式更新为ai = ai op v，这里 op是中缀形式的累加操作。get 的结果是 a1 op a2 op … op an。操作必须满足结合律和交换律， 最终结果必须独立于所结合的中间值的顺序。DoubleAdder 和 DoubleAccumulator 也采用同样的方式。</p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>所有线程都被阻塞。这样的状态称为死锁（deadlock )。</p>
<p>当程序挂起时， 键入 CTRL+, 将得到一个所有线程的列表。每一个线程有一个栈踪迹， 告诉你线程被阻塞的位置。运行 jconsole 并参考线程面板。</p>
<p>Java 编程语言中没有任何东西可以避免或打破这种死锁现象。必须仔细设计程序， 以确保不会出现死锁。</p>
<h5 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h5><p>要避免共享变量， 使用 ThreadLocal 辅助类为各个线程提供各自的实例。要为每个线程构造一个实例，可以使用以下代码：<br>public static final ThreadLocal&lt;ClassName&gt; anObject = ThreadLocal.withInitial(() -&gt; new ClassName(…));;<br>要访问具体的方法，可以调用：<br>anObject.get().method(…);<br>在一个给定线程中首次调用 get 时， 会调用 initialValue 方法。在此之后， get 方法会返回属于当前线程的那个实例。</p>
<p>Java SE 7 中ThreadLocalRandom.current() 调用会返回特定于当前线程的 Random 类实例。</p>
<h5 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h5><p>线程在调用 lock 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则返回false, 而且线程可以立即离开去做其他事情。调用 tryLock 时，可使用超时参数：<br>if (myLock.tryLock(100, TimeUnit.MILLISECONDS)) . . .<br>TimeUnit 是一 枚举类型，可以取的值包括 SECONDS、MILLISECONDS, MICROSECONDS 和 NANOSECONDS。如果在等待期间被中断，将抛出InterruptedException 异常。也可以调用 locklnterruptibly 方法。它就相当于一个超时设为无限的 tryLock 方法。</p>
<p>在等待一个条件时， 也可以提供一个超时：<br>myCondition.await(100, TineUniBILLISECONDS))<br>如果等待的线程被中断， await 方法将抛出一个 InterruptedException 异常。在你希望出现这种情况时线程继续等待，可以使用 awaitUninterruptibly 方法代替 await。</p>
<h5 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读 / 写锁"></a>读 / 写锁</h5><p>如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，ReentrantReadWriteLock 类十分有用。在这种情况下，读者线程共享访问，写者线程互斥访问。</p>
<p>使用读 / 写锁的步骤：</p>
<ol>
<li>构 造 一 个 ReentrantReadWriteLock 对象：<br>private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock():</li>
<li>抽取读锁和写锁：<br>private Lock readLock = rwl.readLock();<br>private Lock writeLock = rwl.writeLock();</li>
<li>对所有的获取方法加读锁：<br>public double getTotalBalance() {<br>  readLock.lock()；<br>  try { . . . }<br>  finally { readLock.unlock(); }<br>}</li>
<li>对所有的修改方法加写锁：<br>public void transfer(. . .) {<br>  writeLock.lock();<br>  try { . . . }<br>  finally { writeLock.unlock(); }<br>}</li>
</ol>
<h5 id="为什么弃用-stop-和-suspend-方法"><a href="#为什么弃用-stop-和-suspend-方法" class="headerlink" title="为什么弃用 stop 和 suspend 方法"></a>为什么弃用 stop 和 suspend 方法</h5><p>初始的 Java 版本定义了一个 stop 方法用来终止一个线程， 以及一个 suspend 方法用来阻塞一个线程直至另一个线程调用 resume。</p>
<p>stop 方法终止所有未结束的方法， 包括 run方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。当线程要终止另一个线程时， 无法知道什么时候调用 stop 方法是安全的， 什么时候导致对象被破坏。因此，该方法被弃用了。</p>
<p>如果用 suspend 挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。如果调用suspend 方法的线程试图获得同一个锁， 那么程序死锁： 被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>对于实际编程来说，应该尽可能远离底层结构。使用由并发处理的专业人士实现的较高层次的结构要方便得多、 要安全得多。</p>
<p>对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插人元素， 消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。</p>
<p>当试图向队列添加元素而队列已满， 或是想从队列移出元素而队列为空的时候， 阻塞队列（blocking queue ) 导致线程阻塞。队列会自动地平衡负载。</p>
<p>阻塞队列方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>正常动作</th>
<th>特殊情况下的动作</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>添加一个元素</td>
<td>如果队列满，则抛出 IllegalStateException 异常</td>
</tr>
<tr>
<td>element</td>
<td>返回队列的头元素</td>
<td>如果队列空，抛出 NoSuchElementException 异常</td>
</tr>
<tr>
<td>offer</td>
<td>添加一个元素并返回 true</td>
<td>如果队列满，返回 false</td>
</tr>
<tr>
<td>peek</td>
<td>返回队列的头元素</td>
<td>如果队列空， 则返回 null</td>
</tr>
<tr>
<td>poll</td>
<td>移出并返回队列的头元素</td>
<td>如果队列空， 则返回 null</td>
</tr>
<tr>
<td>put</td>
<td>添加一个元素</td>
<td>如果队列满， 则阻塞</td>
</tr>
<tr>
<td>remove</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则抛出 NoSuchElementException 异常</td>
</tr>
<tr>
<td>take</td>
<td>移出并返回头元素</td>
<td>如果队列空， 则阻塞</td>
</tr>
</tbody></table>
<p>poll 和 peek 方法返回空来指示失败。 因此，向这些队列中插入 null 值是非法的。</p>
<p>还有带有超时的 offer 方法和 poll 方法的变体：<br>boolean success = q.offer(x, 100, TimeUnit.MILLISECONDS);<br>Object head = q.poll(100, TimeUnit.MILLISECONDS)</p>
<p>java.util.concurrent 包提供了阻塞队列的几个变种。<br>LinkedBlockingQueue默认情况下的容量是没有上边界的，也可以选择指定最大容量。它是一个双端的版本。<br>ArrayBlockingQueue 在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数， 则那么等待了最长时间的线程会优先得到处理。<br>PriorityBlockingQueue 是一个带优先级的队列。元素按照它们的优先级顺序被移出。该队列是没有容量上限。<br>DelayQueue 包含实现 Delayed 接口的对象。getDelay方法返回对象的残留延迟。负值表示延迟已经结束。元素只有在延迟用完的情况下才能从 DelayQueue 移除。DelayQueue 使用compareTo方法对元素进行排序。<br>JavaSE 7增加了一个 TransferQueue 接口，允许生产者线程等待， 直到消费者准备就绪可以接收一个元素。LinkedTransferQueue 类实现了这个接口。</p>
<h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><p>如果多线程要并发地修改一个数据结构， 那么很容易会破坏这个数据结构。可以通过提供锁来保护共享数据结构， 但是选择线程安全的实现作为替代可能更容易些。</p>
<h5 id="高效的映射、集和队列"><a href="#高效的映射、集和队列" class="headerlink" title="高效的映射、集和队列"></a>高效的映射、集和队列</h5><p>java.util.concurrent 包提供了映射、 有序集和队列的高效实现：ConcurrentHashMap、<br>ConcurrentSkipListMap 、ConcurrentSkipListSet 和 ConcurrentLinkedQueue。这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。</p>
<p>与大多数集合不同，size 方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。有些应用使用庞大的并发散列映射，这些映射太过庞大， 以至于无法用 size 方法得到它的大小， 因为这个方法只能返回 int。JavaSE 8 引入了一个 mappingCount 方法可以把大小作为 long 返回。</p>
<p>集合返回弱一致性（ weakly consistent) 的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会拋出 ConcurrentModificationException 异常。</p>
<p>并发的散列映射表， 可高效地支持大量的读者和一定数量的写者。默认情况下，假定可以有多达 16 个写者线程同时执行。可以有更多的写者线程，但是， 如果同一时间多于 16个，其他线程将暂时被阻塞。</p>
<p>在 JavaSE 8 中，并发散列映射将桶组织为树， 而不是列表， 键类型实现了 Comparable, 从而可以保证性能为 O(log(n))。</p>
<h5 id="映射条目的原子更新"><a href="#映射条目的原子更新" class="headerlink" title="映射条目的原子更新"></a>映射条目的原子更新</h5><p>有些程序员很奇怪为什么原本线程安全的数据结构会允许非线程安全的操作。多线程操作会破坏普通数据结构而不会破坏线程安全的数据结构。不过，由于操作序列不是原子的，所以结果不可预知。</p>
<p>使用 replace 操作， 它会以原子方式用一个新值替换原值，前提是之前没有其他线程把原值替换为其他值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	oldValue = map.get(word);</span><br><span class="line">	newValue = oldValue = <span class="keyword">null</span> ? <span class="number">1</span> : oldValue + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (!map.replace(word, oldValue, newValue));</span><br></pre></td></tr></table></figure>
<p>可以使用一个 ConcurrentHashMap&lt;String，AtomicLong&gt;， 在 Java SE 8中，还可以使用 ConcurrentHashMap&lt;String，LongAdder&gt;， putIfAbsent 返回映射的的值（可能是原来的值， 或者是新设置的值)：<br>map.putlfAbsent(word, new LongAdder()).increment():</p>
<p>Java SE 8 提供了一些可以更方便地完成原子更新的方法。调用 compute 方法时可以提供一个键和一个计算新值的函数。这个函数接收键和相关联的值（如果没有值，则为 null), 它会计算新值：<br>map.compute(word , (k, v) -&gt; v = null ? 1: v + 1);<br>ConcurrentHashMap 中不允许有 null 值。有很多方法都使用 null 值来指示映射中某个给定的键不存在。</p>
<p>computeIfPresent 和 computeIfAbsent 方法，它们分别只在已经有原值的情况下计算新值，或者只有没有原值的情况下计算新值。</p>
<p>merge 方法有一个参数表示键不存在时使用的初始值。否则， 就会调用你提供的函数来结合原值与初始值。（与 compute 不同，这个函数不处理键）：<br>map.merge(word, 1L, (existingValue, newValue) -&gt; existingValue + newValue);<br>map.merge(word, 1L, Long::sum);</p>
<p>如果传入 compute 或 merge 的函数返回 null, 将从映射中删除现有的条目。使用 compute 或 merge 时， 要记住你提供的函数不能做太多工作。这个函数运行时，可能会阻塞对映射的其他更新。</p>
<h5 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h5><p>Java SE 8 为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。无须冻结当前映射的快照。除非你恰好知道批操作运行时映射不会被修改， 否则就要把结果看作是映射状态的一个近似。</p>
<p>有 3 种不同的操作：</p>
<ul>
<li>搜索（search) 为每个键或值提供一个函数，直到函数生成一个非 null 的结果。然后搜索终止，返回这个函数的结果。</li>
<li>归约（reduce) 组合所有键或值， 这里要使用所提供的一个累加函数。</li>
<li>forEach 为所有键或值提供一个函数。</li>
</ul>
<p>每个操作都有 4 个版本：</p>
<ul>
<li>operationKeys: 处理键。</li>
<li>operatioriValues: 处理值。</li>
<li>operation: 处理键和值。</li>
<li>operatioriEntries: 处理 Map.Entry 对象。</li>
</ul>
<p>对于上述各个操作， 需要指定一个参数化阈值（/wa/Zefc/w /AresAoW)。如果映射包含的元素多于这个阈值， 就会并行完成批操作。如果希望批操作在一个线程中运行，可以使用阈值 Long.MAX_VALUE。如果希望用尽可能多的线程运行批操作，可以使用阈值 1。</p>
<p>search方法。有以下版本：<br>U searchKeys(long threshold, BiFunction&lt;? super K , ? extends U&gt; f)<br>U searchValues(long threshold, BiFunction&lt;? super V, ? extends U&gt; f)<br>U search(long threshold, BiFunction&lt;? super K, ? super V,? extends U&gt; f)<br>U searchEntries(long threshold, BiFunction&lt;Map.Entry&lt;K, V&gt;, ? extends U&gt; f)</p>
<p>forEach方法有两种形式。第一个只为各个映射条目提供一个消费者函数：<br>map.forEach(threshold, (k, v) -&gt; System.out.println(k + “ -&gt; “ + v));<br>第二种形式还有一个转换器函数， 这个函数要先提供， 其结果会传递到消费者：<br>map.forEach(threshold,<br>  (k, v) -&gt; k + “ -&gt; “ + v，// Transformer<br>  System.out::println); // Consumer<br>转换器可以用作为一个过滤器。只要转换器返回 null , 这个值就会被跳过。</p>
<p>reduce 操作用一个累加函数组合其输入：<br>Long sum = map.reduceValues(threshold, Long::sum);<br>也可以提供一个转换器函数：<br>Integer maxlength = map.reduceKeys(threshold,<br>  String::length, // Transformer<br>  Integer::max); // Accumulator<br>转换器可以作为一个过滤器，通过返回 null 来排除不想要的输入。<br>如果映射为空， 或者所有条目都被过滤掉， reduce 操作会返回 null。如果只有一个元素， 则返回其转换结果， 不会应用累加器。<br>对于 int、 long 和 double 输出还有相应的特殊化操作， 分别有后缀 ToInt、 ToLong 和ToDouble。需要把输入转换为一个基本类型值，并指定一个默认值和一个累加器函数。映射为空时返回默认值：<br>long sum = map.reduceValuesToLong(threshold,<br>  Long::longValue, // Transformer to primitive type<br>  0, // Default value for empty map<br>  Long::sum); // Primitive type accumulator<br>这里不是返回转换得到的元素， 而是将与默认值累加。因此， 默认值必须是累加器的零元素。</p>
<h5 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h5><p>静态 newKeySet 方法会生成一个 Set&lt;K&gt;, 这实际上是 ConcurrentHashMap&lt;K, Boolean&gt;的一个包装器。（所有映射值都为 Boolean.TRUE, 不过因为只是要把它用作一个集，所以并不关心具体的值。）：<br>Set&lt;String&gt; words = ConcurrentHashMap.&lt;String&gt;newKeySet();<br>如果原来有一个映射，keySet 方法可以生成这个映射的键集。这个集是可变的。如果删除这个集的元素，这个键（以及相应的值）会从映射中删除。不过，不能向键集增加元素，因为没有相应的值可以增加。Java SE 8 为 ConcurrentHashMap 增加了第二个 keySet 方法，包含一个默认值，可以在为集增加元素时使用：<br>Set&lt;String&gt; words = map.keySet(1L);<br>words.add(“Java”）；<br>如果 “Java”在 words 中不存在， 现在它会有一个值 1。</p>
<h5 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h5><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。当构建一个迭代器的时候， 它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，旧的迭代器拥有一致的（可能过时的）视图，访问它无须任何同步开销。</p>
<h5 id="并行数组算法"><a href="#并行数组算法" class="headerlink" title="并行数组算法"></a>并行数组算法</h5><p>在 Java SE 8中， Arrays 类提供了大量并行化操作。静态 Arrays.parallelSort 方法可以对一个基本类型值或对象的数组排序。对对象排序时，可以提供一个 Comparator：<br>Arrays.parallelSort(words, Comparator.comparing(String::length));<br>对于所有方法都可以提供一个范围的边界：<br>values.parallelSort(values.length / 2, values.length); // Sort the upper half</p>
<p>parallelSetAll 方法会用由一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值：<br>Arrays.parallelSetAll(values, i -&gt; i % 10);<br>这个操作对于所有基本类型数组和对象数组都有相应的版本。</p>
<p>parallelPrefix 方法，它会用对应一个给定结合操作的前缀的累加结果替换各个数组元素。考虑数组 [1，2, 3, 4, . . .] 和 x 操作。执行 Arrays.parallelPrefix(values, (x, y) -&gt; x * y) 之后，数组将包含：<br>[1, 1x 2, 1x 2 x 3, 1 x 2 x 3 x 4, . . .]</p>
<h5 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h5><p>从 Java 的初始版本开始，Vector 和 Hashtable 类就提供了线程安全的动态数组和散列表的实现。</p>
<p>现在集合库中提供了不同的机制。任何集合类都可以通过使用同步包装器（synchronization wrapper) 变成线程安全的：<br>List&lt;E&gt; synchArrayList = Col lections.synchronizedList(new ArrayList&lt;E&gt;());<br>Map&lt;K , V&gt; synchHashMap = Collections.synchronizedMap(new HashMap&lt;K , V&gt;())；<br>结果集合的方法使用锁加以保护，提供了线程安全访问。应该确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用——简单地构造一个集合并立即传递给包装器。</p>
<p>如果在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用“ 客户端” 锁定。如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出 ConcurrentModificationException 异常。同步仍然是需要的， 因此并发的修改可以被可靠地检测出来。</p>
<p>最好使用 java.util.concurrent 包中定义的集合， 不使用同步包装器中的。有一个例外是经常被修改的数组列表。在那种情况下，同步的 ArrayList 可以胜过 CopyOnWriteArrayList 。</p>
<h5 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a>Callable 与 Future</h5><p>Callable 是一个没有参数，有返回值的异步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future 保存异步计算的结果。可以启动一个计算，将 Future 对象交给某个线程，Future 对象的所有者在结果计算好之后就可以获得它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> . .</span></span><br><span class="line"><span class="function">	V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> . .</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> maylnterrupt)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 get 方法的调用被阻塞， 直到计算完成。如果在计算完成之前， 第二个方法的调用超时，拋出一个 TimeoutException 异常。如果运行该计算的线程被中断，两个方法都将拋出 IntermptedException。如果计算已经完成， 那么 get 方法立即返回。</p>
<p>如果计算还在进行，isDone 方法返回 false; 如果完成了， 则返回 true。</p>
<p>可以用 cancel 方法取消该计算。如果计算还没有开始，它被取消且不再开始。如果计算处于运行之中，那么如果 maylnterrupt 参数为 true, 它就被中断。</p>
<p>FutureTask 包装器是一种非常便利的机制， 可将 Callable转换成 Future 和 Runnable, 它同时实现二者的接口：<br>Callable&lt;Integer&gt; myComputation = . . .;<br>FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(myConiputation);<br>Thread t = new Thread(task); // it’s a Runnable<br>t.start()；<br>Integer result = task.get()；// it’s a Future</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>构建一个新的线程是有一定代价的， 因为涉及与操作系统的交互。如果程序中创建了大量的生命期很短的线程，应该使用线程池（ thread pool)。一个线程池中包含许多准备运行的空闲线程。将 Runnable 对象交给线程池， 就会有一个线程调用 run 方法。 当 run 方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务。</p>
<p>另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃， 应该使用一个线程数“ 固定的” 线程池以限制并发线程的总数。</p>
<p>执行器（ Executor) 类有许多静态工厂方法用来构建线程池：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">newCachedThreadPool</td>
<td align="left">必要时创建新线程；空闲线程会被保留 60 秒</td>
</tr>
<tr>
<td align="left">newFixedThreadPool</td>
<td align="left">该池包含固定数量的线程；空闲线程会一直被保留</td>
</tr>
<tr>
<td align="left">newSingleThreadExecutor</td>
<td align="left">只有一个线程的 “ 池”， 该线程顺序执行每一个提交的任务（类似于Swing 事件分配线程）</td>
</tr>
<tr>
<td align="left">newScheduledThreadPool</td>
<td align="left">用于预定执行而构建的固定线程池， 替代 java.util.Timer</td>
</tr>
<tr>
<td align="left">newSingleThreadScheduledExecutor</td>
<td align="left">用于预定执行而构建的单线程 “ 池“</td>
</tr>
</tbody></table>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor这 3 个方法返回实现了<br>ExecutorService 接口的 ThreadPoolExecutor 类的对象。</p>
<p>可用下面的方法之一将一个 Runnable 对象或 Callable 对象提交给 ExecutorService：</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)。get 方法在完成的时候只是简单地返回 null。</li>
<li>Future&lt;T&gt; submit(Runnable task, T result)。Future 的 get 方法在完成的时候返回指定的 result 对象。</li>
<li>Future&lt;T&gt; submit(Callable&lt;T&gt; task)。返回的 Future 对象将在计算结果准备好的时候得到它。</li>
</ul>
<p>该池会在方便的时候尽早执行提交的任务。调用 submit 时，会得到一个 Future 对象， 可用来查询该任务的状态。</p>
<p>当用完一个线程池的时候， 调用 shutdown。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是调用 shutdownNow。该池取消尚未开始的所有任务并试图中断正在运行的线程。</p>
<h5 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h5><p>使用执行器有更有实际意义的原因， 控制一组相关任务。例如， 可以在执行器中使用 shutdownNow 方法取消所有的任务。</p>
<p>invokeAny 方法提交所有对象到一个 Callable 对象的集合中，并返回某个已经完成了的任务的结果。无法知道返回的究竟是哪个任务的结果。对于搜索问题， 如果你愿意接受任何一种解决方案的话，你就可以使用这个方法。</p>
<p>invokeAll 方法提交所有对象到一个 Callable 对象的集合中，并返回一个 Future 对象的列表，代表所有任务的解决方案。这个方法的缺点是如果第一个任务恰巧花去了很多时间，则可能不得不进行等待。</p>
<p>可以用 ExecutorCompletionService 来进行排列。用常规的方法获得一个执行器。然后， 构建一个 ExecutorCompletionService， 提交任务给完成服务（ completion service。) 该服务管理 Future 对象的阻塞队列，其中包含已经提交的任务的执行结果（当这些结果成为可用时）：<br>ExecutorCompletionService&lt;T&gt; service = new ExecutorCompletionService&lt;&gt;(executor):<br>for (Callable&lt;T&gt; task : tasks) service.submit(task);<br>for (int i = 0; i &lt; tasks.size()；i ++) processFurther(service.take().get())；</p>
<h5 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork-Join 框架"></a>Fork-Join 框架</h5><p>一些应用可能对每个处理器内核分别使用一个线程，来完成计算密集型任务。Java SE 7中新引入了 fork-join 框架，专门用来支持这一类应用。</p>
<p>要采用框架可用的一种方式完成递归计算， 需要提供一个扩展 RecursiveTask&lt;&gt; 的类（如果计算会生成一个类型为 T 的结果）或者提供一个扩展 RecursiveAction 的类（如果不生成任何结果)。再覆盖 compute 方法来生成并调用子任务， 然后合并其结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">			solve problem directly</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (from + to) / <span class="number">2</span>;</span><br><span class="line">			Counter first = <span class="keyword">new</span> Counter(va1ues, from, mid, filter);</span><br><span class="line">			Counter second = <span class="keyword">new</span> Counter(va1ues, mid, to, filter);</span><br><span class="line">			invokeAll(first, second);</span><br><span class="line">			<span class="keyword">return</span> first.join() + second.join()；</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeAll 方法接收到很多任务并阻塞， 直到所有这些任务都已经完成。join 方法将生成结果。get 方法可以得到当前结果， 不过一般不太使用， 因为它可能抛出已检查异常， 而在 compute 方法中不允许抛出这些异常。</p>
<p>在后台， fork-join 框架使用了一种有效的智能方法来平衡可用线程的工作负载，这种方法称为工作密取（work stealing)。每个工作线程都有一个双端队列 ( deque ) 来完成任务。一个工作线程将子任务压人其双端队列的队头。（只有一个线程可以访问队头，所以不需要加锁。）一个工作线程空闲时，它会从另一个双端队列的队尾“ 密取” 一个任务。由于大的子任务都在队尾， 这种密取很少出现。</p>
<h5 id="可完成-Future"><a href="#可完成-Future" class="headerlink" title="可完成 Future"></a>可完成 Future</h5><p>处理非阻塞调用的传统方法是使用事件处理器， 程序员为任务完成之后要出现的动作注册一个处理器。当然， 如果下一个动作也是异步的， 在它之后的下一个动作会在一个不同的事件处理器中。尽管程序员会认为“ 先做步骤 1 , 然后是步骤 2, 再完成步骤 3”，但实际上程序逻辑会分散到不同的处理器中。如果必须增加错误处理，情况会更糟糕。假设步骤 2是“ 用户登录”。可能需要重复这个步骤， 因为用户输入凭据时可能会出错。要尝试在一组事件处理器中实现这样一个控制流，或者想要理解所实现的这样一组事件处理器，会很有难度。</p>
<p>Java SE 8 的 CompletableFuture 类提供了一种候选方法。与事件处理器不同，“ 可完成future” 可以“ 组合”（composed )。利用可完成 future，可以指定你希望做什么， 以及希望以什么顺序执行这些工作。</p>
<p>为CompletableFuture&lt;T&gt; 对象增加一个动作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>thenApply</td>
<td>T -&gt; U</td>
<td>对结果应用一个函数</td>
</tr>
<tr>
<td>thenCompose</td>
<td>T -&gt; CompletableFuture&lt;U&gt;</td>
<td>对结果调用函数并执行返回的 future</td>
</tr>
<tr>
<td>handle</td>
<td>(T, Throwable) -&gt; U</td>
<td>处理结果或错误</td>
</tr>
<tr>
<td>thenAccept</td>
<td>T -&gt; void</td>
<td>类似于 thenApply, 不过结果为 void</td>
</tr>
<tr>
<td>whenComplete</td>
<td>(T, Throwable) -&gt; void</td>
<td>类似于 handle, 不过结果为 void</td>
</tr>
<tr>
<td>thenRun</td>
<td>Runnable</td>
<td>执行 Runnable, 结果为 void</td>
</tr>
</tbody></table>
<p>对于这里所示的每个方法，还有两个 Async 形式，其中一种形式使用一个共享 ForkJoinPool，另一种<br>形式有一个 Executor 参数。这里把 Function&lt;? super T，U&gt; 写为 T -&gt; U。</p>
<p>以下调用：<br>CompletableFuture&lt;U&gt; future.thenApply(f);<br>CompletableFuture&lt;U&gt; future.thenApplyAsync(f) ;<br>会返回一个 future , 可用时会对 future 的结果应用 f。 第二个调用会在另一个线程中运行 。</p>
<p>这 里 我 们 有 两 个 函 数 T -&gt; CompletableFuture&lt;U&gt; 和 U -&gt; CompletableFuture&lt;V&gt;。 如果第二个函数在第一个函数完成时调用， 它们就可以组合为一个函数 T -&gt; CompletableFuture&lt;V&gt;。这正是 thenCompose 所做的。</p>
<p>CompletableFuture 中拋出一个异常时， 会捕获这个异常并在调用 get 方法时包装在一个受查异常 ExecutionException 中。 不过， 可能 get 永远也不会被调用。要处理异常， 可以使用 handle 方法。</p>
<p>其余的方法结果都为 void， 通常用在处理管线的最后。</p>
<p>组合多个组合对象：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>thenCombine</td>
<td>CompletableFuture&lt;U&gt;, (T, U) -&gt; V</td>
<td>执行两个动作并用给定函数组合结果</td>
</tr>
<tr>
<td>thenAcceptBoth</td>
<td>CompletableFuture&lt;U&gt;, (T, U) -&gt; void</td>
<td>与 thenCombine 类似， 不过结果为void</td>
</tr>
<tr>
<td>runAfterBoth</td>
<td>CompletableFuture&lt;?&gt;, Runnable</td>
<td>两个都完成后执行 Runnable</td>
</tr>
<tr>
<td>applyToEither</td>
<td>CompletableFuture&lt;T&gt;, T -&gt; V</td>
<td>得到其中一个的结果时，传入给定的函数</td>
</tr>
<tr>
<td>acceptEither</td>
<td>CompletableFuture&lt;T&gt;, T -&gt; void</td>
<td>与 applyToEither 类似，不过结果为void</td>
</tr>
<tr>
<td>runAfterEither</td>
<td>CompletableFuture&lt;?&gt;, Runnable</td>
<td>其中一个完成后执行 runnable</td>
</tr>
<tr>
<td>static allOf</td>
<td>CompletableFuture&lt;?&gt;…</td>
<td>所有给定的 future 都完成后完成，结果为 void</td>
</tr>
<tr>
<td>static anyOf</td>
<td>CompletableFuture&lt;?&gt;…</td>
<td>任意给定的 future 完成后则完成，结果为 void</td>
</tr>
</tbody></table>
<p>前 3 个方法并行运行一个 CompletableFuture&lt;T&gt; 和一个 CompletableFuture&lt;U&gt; 动作， 并组合结果。接下来 3 个方法并行运行两个 CompletableFuture&lt;T&gt; 动作。一旦其中一个动作完成，就传递它的结果，并忽略另一个结果。静 态 allOf 和 anyOf 方 法 取 一 组 可 完 成 future ( 数 目 可 变) 并 生 成 一 个CompletableFuture&lt;Void&gt; , 它会在所有这些 future 都完成时或者其中任意一个future完成时结束。不会传递任何结果。</p>
<p>这些方法接受 CompletionStage 类型的参教。这个接口有几乎 40 个抽象方法， 只由CompletableFuture 实现。提供这个接口是为了让第三方框架可以实现这个接口。</p>
<h3 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h3><p>java.util.concurrent 包包含了几个能帮助人们管理相互合作的线程集的类。这些机制具有为线程之间的共用集结点模式（common rendezvous patterns) 提供的“ 预置功能”( canned functionality ) 。</p>
<p>同步器：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>它能做什么</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier</td>
<td>允许线程集等待直至其中预定数目的线程到达一个公共障栅（ barrier) ，然后可以选择执行一个处理障栅的动作</td>
<td>当大量的线程需要在它们的结果可用之前完成时</td>
</tr>
<tr>
<td>Phaser</td>
<td>类似于循环障栅， 不过有一个可变的计数</td>
<td>Java SE 7 中引人</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>允许线程集等待直到计数器减为 0</td>
<td>当一个或多个线程需要等待直到指定数目的事件发生</td>
</tr>
<tr>
<td>Exchanger</td>
<td>允许两个线程在要交换的对象准备好时交换对象</td>
<td>当两个线程工作在同一数据结构的两个实例上的时候， 一个向实例添加数据而另一个从实例清除数据</td>
</tr>
<tr>
<td>Semaphore</td>
<td>允许线程集等待直到被允许继续运行为止</td>
<td>限制访问资源的线程总数。 如果许可数是 1，常常阻塞线程直到另一个线程给出许可为止</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>允许一个线程把对象交给另一个线程</td>
<td>在没有显式同步的情况下， 当两个线程准备好将一个对象从一个线程传递到另一个时</td>
</tr>
</tbody></table>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>一个信号量管理许多的许可证（permit)。为了通过信号量，线程通过调用acquire 请求许可。其实没有实际的许可对象， 信号量仅维护一个计数。许可的数目是固定的，由此限制了通过的线程数量。其他线程可以通过调用 release 释放许可。而且，许可不是必须由获取它的线程释放。事实上，任何线程都可以释放任意数目的许可，这可能会增加许可数目以至于超出初始数目。</p>
<h5 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h5><p>一个倒计时门栓（ CountDownLatch) 让一个线程集等待直到计数变为 0。倒计时门栓是一次性的。一旦计数为 0, 就不能再重用了。</p>
<p>一个有用的特例是计数值为 1 的门栓。实现一个只能通过一次的门。线程在门外等候直到另一个线程将计数器值置为0。</p>
<h5 id="障栅"><a href="#障栅" class="headerlink" title="障栅"></a>障栅</h5><p>CyclicBarrier 类实现了一个集结点（rendezvous) 称为障栅（ barrier)。考虑大量线程运行在一次计算的不同部分的情形。当一个线程完成了它的那部分任务后， 我们让它运行到障栅处。一旦所有的线程都到达了这个障栅，障栅就撤销， 线程就可以继续运行。</p>
<p>构造一个障栅， 并给出参与的线程数：<br>CyclicBarrier barrier = new CydicBarrier(nthreads);<br>每一个线程做一些工作，完成后在障栅上调用 await :<br>public void run() {<br>  doWork();<br>  bamer.await()；<br>}</p>
<p>await 方法有一个可选的超时参数：<br>barrier.await(100, TineUnit.MILLISECONDS);<br>如果任何一个在障栅上等待的线程离开了障栅， 那么障栅就被破坏了。在这种情况下，所有其他线程的<br>await 方法抛出 BrokenBarrierException 异常。那些已经在等待的线程立即终止 await 的调用。</p>
<p>可以提供一个可选的障栅动作（ barrier action), 当所有线程到达障栅的时候就会执行这一动作：<br>Runnable barrierAction = …<br>CyclicBarrier barrier = new CyclicBarrier(nthreads, barrierAction);<br>该动作可以收集那些单个线程的运行结果。</p>
<p>障栅被称为是循环的（ cyclic), 因为可以在所有等待线程被释放后被重用。Phaser 类增加了更大的灵活性，允许改变不同阶段中参与线程的个数。</p>
<h5 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h5><p>当两个线程在同一个数据缓冲区的两个实例上工作的时候， 就可以使用交换器( Exchanger) 典型的情况是， 一个线程向缓冲区填人数据， 另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。</p>
<h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p>同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 SynchronousQueue的 put 方法时，它会阻塞直到另一个线程调用 take 方法为止，反之亦然。</p>
<p>即使 SynchronousQueue 类实现了 BlockingQueue 接口， 概念上讲，它依然不是一个队列。它没有包含任何元素，它的 size方法总是返回 0。</p>
<h3 id="线程与-Swing"><a href="#线程与-Swing" class="headerlink" title="线程与 Swing"></a>线程与 Swing</h3><p>在程序中使用线程的理由之一是提高程序的响应性能。当程序需要做某些耗时的工作时，应该启动另一个工作器线程而不是阻塞用户接口。</p>
<p>Swing 不是线程安全的。如果你试图在多个线程中操纵用户界面的元素，那么用户界面可能崩溃。</p>
<p>Swing 的设计者决定不再付出更多的努力实现 Swing 线程安全， 有两个原因：</p>
<ul>
<li><p>同步需要时间， 已经没有人想要降低 Swing 的速度。</p>
</li>
<li><p>Swing 小组调查了其他小组在线程安全的用户界面工具包方面的经验。使用线程安全包的程序员被同步命令搞昏了头， 常常编写出容易造成死锁的程序。</p>
</li>
</ul>
<h5 id="运行耗时的任务"><a href="#运行耗时的任务" class="headerlink" title="运行耗时的任务"></a>运行耗时的任务</h5><p>将线程与 Swing—起使用时， 必须遵循两个简单的原则：</p>
<ol>
<li>如果一个动作需要花费很长时间，在一个独立的工作器线程中做这件事不要在事件分配线程中做。如果花很多时间在事件分配线程上，应用程序像“ 死了” 一样， 因为它不响应任何事件。特别是， 事件分配线程应该永远不要进行 input/output 调用，这有可能会阻塞， 并且应该永远不要调用 sleep。（如果需要等待指定的时间，使用定时器事件。）</li>
<li>除了事件分配线程，不要在任何线程中接触 Swing 组件。这通常称为单一线程规则 （ single-thread rule )。</li>
</ol>
<p>在任何线程中，可以使用一种有效的方法向事件分配线程的事件队列添加任意的动作——将 Swing 代码放置到实现 Runnable 接口的类的 run 方法中。然后，创建该类的一个对象， 将其传递给静态的 invokeLater 或 invokeAndWait 方法：<br>EventQueue.invokeLater(()-&gt; {<br>  label.setText(percentage + “% complete”);<br>})；<br>当事件放人事件队列时，invokeLater 方法立即返回，而 run 方法被异步执行。invokeAndWait 方法等待直到 run 方法确实被执行过为止。</p>
<h5 id="使用-Swing-工作线程"><a href="#使用-Swing-工作线程" class="headerlink" title="使用 Swing 工作线程"></a>使用 Swing 工作线程</h5><p>SwingWorker 类使后台任务的实现不那么繁琐。覆盖 doInBackground 方法来完成耗时的工作， 不时地调用 publish 来报告工作进度。这一方法在工作器线程中执行。publish 方法使得process 方法在事件分配线程中执行来处理进度数据。当工作完成时， done方法在事件分配线程中被调用以便完成 UI 的更新。</p>
<p>每当要在工作器线程中做一些工作时， 构建一个新的工作器（每一个工作器对象只能被使用一次)。然后调用 execute 方法。典型的方式是在事件分配线程中调用 execute， 但没有这样的需求。</p>
<p>假定工作器产生某种类型的结果，SwingWorker&lt;T，V&gt; 实现 Future&lt;T&gt;。这一结果可以通过 Future 接口的 get 方法获得。由于 get 方法阻塞直到结果成为可用，因此不要在调用 execute 之后马上调用它。只在已经知道工作完成时调用它，典型地，可以从 done方法调用 get。</p>
<p>中间的进度数据以及最终的结果可以是任何类型。SwingWorker 类有 3 种类型作为类型参数。 SwingWorker&lt;T，V&gt; 产生类型为 T 的结果以及类型为 V 的进度数据。</p>
<p>要取消正在进行的工作，使用 Future 接口的 cancel 方法。当该工作被取消的时候， get方法抛出 CancellationException 异常。</p>
<p>为了提高效率， 几个对 publish 的调用结果， 可用对 process 的一次调用成批处理。process 方法接收一个包含所有中间结果的列表&lt;V&gt;。</p>
<h5 id="单一线程规则"><a href="#单一线程规则" class="headerlink" title="单一线程规则"></a>单一线程规则</h5><p>对于单一线程规则存在一些例外情况：</p>
<ul>
<li>可在任一个线程里添加或移除事件监听器。 该监听器的方法会在事件分配线程中被触发。</li>
<li>有很少的 Swing 方法是线程安全的。在这些线程安全的方法中最有用的是：<br>JTextComponent.setText、JTextArea.insert、JTextArea.append、JTextArea.replaceRange、JCouponent.repaint、JComponent.revalidat。</li>
</ul>
]]></content>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 移动开发基础案例教程</title>
    <url>/2020/12/14/Android/</url>
    <content><![CDATA[<h3 id="Android-基础入门"><a href="#Android-基础入门" class="headerlink" title="Android 基础入门"></a>Android 基础入门</h3><h5 id="Android-简介"><a href="#Android-简介" class="headerlink" title="Android 简介"></a>Android 简介</h5><p>Android 是一款基于 Linux 平台的开源操作系统，主要用于移动设备中，由 Google 公司和开放手机联盟领导及开发。Android 一词最早出现于法国作家利尔亚当在 1886 年发表的科幻小说《未来夏娃》中，将外表像人的机器起名为 Android。从 Android 1.5 版本开始， Android 用甜点作为系统版本的代号。</p>
<a id="more"></a>

<p>Android 系统采用分层架构，由高到低分为 4 层，依次是应用程序层、应用程序框架层 、核心类库层和 Linux 内核层：</p>
<ul>
<li>应用程序层是一个应用程序的集合，所有安装在手机上的应用程序都属于这一层。</li>
<li>应用程序框架层主要提供了构建应用程序时用到的各种 API。</li>
<li>核心类库中包含了系统库及 Android 运行时库，系统库主要是通过 C/C++ 库来为 Android 系统提供主要的特性支持；Android 运行时库主要提供了一些核心库，能够允许开发者使用 Java 语言来编写 Android 应用程序，Android 运行时库中还包括了 Dalvik 虚拟机。</li>
<li>Linux 内核层为 Android 设备的各种硬件提供了底层的驱动。</li>
</ul>
<p>Dalvik 是 Google 公司自己设计用于 Android 平台的虚拟机，它可以简单地完成进程隔离和线程管理，并且可以提高内存的使用效率。每一个 Android 应用程序在底层都会对应一个独立的 Dalvik 虚拟机实例，其代码在虚拟机的解析下得以执行。Java 虚拟机和 Dalvik 虚拟机区别：Java 虚拟机运行的是 .class 字节码文件 ，而 Dalvik 虚拟机运行的则是其专有的 .dex 文件；Java 虚拟机是基于栈的架构，而 Dalvik 是基于寄存器的架构。</p>
<p>ART 模式英文全称为 Android Runtime，是谷歌 Android 4.4 系统增加的一种应用运行模式。ART 模式与 Dalvik 模式最大的不同在于，在启用 ART 模式后，系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行编译了，执行效率也大大提升。</p>
<h5 id="Android-开发环境搭建"><a href="#Android-开发环境搭建" class="headerlink" title="Android 开发环境搭建"></a>Android 开发环境搭建</h5><p>Android Studio 是 Google 提供的一个 Android 开发环境，基于 lntelliJ IDEA。</p>
<p>DDMS：在使用模拟器或者手机进行程序测试时，通常会查看设备的内存使用情况，或者查看正在运行的进程等，这时就需要使用 Android Studio 提供的 DDMS（Dalvik Debug Monitor Service）（已分解为不同部分）。</p>
<p>ADB ( Android Debug Bridge ) 调试桥：ADB 调试桥位于 SDK 的 platform-tools 目录中，它与 DDMS 工具的作用相同，只不过是通过命令行的方式管理模拟器和真机的调试。</p>
<h5 id="开发第一个-Android-程序"><a href="#开发第一个-Android-程序" class="headerlink" title="开发第一个 Android 程序"></a>开发第一个 Android 程序</h5><p>Android 程序在创建时，Android Studio 就为其构建了基本结构，设计者可以在此结构上开发应用程序：</p>
<ul>
<li>manifests: 用于存放 <code>AndroidManifest.xml</code> 文件。在清单文件中配置的信息会添加到 Android 系统中，当程序运行时，系统会找到清单文件中的配置信息，然后根据配置信息打开相应组件。</li>
<li>java：用于存放所有的 Java 代码， 在该文件夹中可以创建多个包， 每个包中可以存放不同的文件或 Activity。</li>
<li>res: 用于存放 Android 程序所用到的资源。drawable 目录用于存放图片及 XML 文件，layout 目录用于存放布局文件，mipmap 目录通常用于存放应用程序图标，values 目录用于放置定义的字符串。</li>
<li>Gradle Scripts: 用于存放项目创建的相关文件。</li>
</ul>
<p>当项目创建成功后，Android Studio 会自动生成布局文件 <code>.xml</code> 和 Activity 文件 <code>.java</code>，布局文件主要用于展示 Android 项目的界面， Activity 文件主要用于完成界面的交互功能。</p>
<p>Activity 继承自 AppCompatActivity，当 Activity 执行时会调用 <code>onCreate()</code> 方法，在该方法中通过 <code>setContentView(R.layout.activity_main)</code> 将布局文件转换成 View 对象，显示在界面上。</p>
<p>清单文件 AndroidManifest.xml，是整个项目的配置文件，程序中定义的四大组 Activity 、BroadcastReceiver 、Service 、ContentProvider 都需要在该文件中进行注册。<code>&lt;activity android:name=&quot;.MainActivity&quot; &gt;</code> 标签用于注册—个 Activity。</p>
<p>在 Android Studio 开发工具中更强调 Project 中项目的关联性，关联性比较大的项目就放在一起，关联性不大的项 目就单独放在一个 Project 中；一个 Project 可以包含多个 Module, 并且在 Project 创建时会默认创建一个名为 App 的 Module。</p>
<p>Android 程序开发完成后 ，如果要发布到互联网上供别人使用，就需要将自己的程序打包成正式的 Android 安装包 ( Android Package 简称 APK )。</p>
<h3 id="Android-UI-开发"><a href="#Android-UI-开发" class="headerlink" title="Android UI 开发"></a>Android UI 开发</h3><h5 id="布局的创建"><a href="#布局的创建" class="headerlink" title="布局的创建"></a>布局的创建</h5><p>Layout File Name 只能包含小写字母 a ~ z，数字 0~9 或下划线 ”_＂。</p>
<h5 id="布局的类型"><a href="#布局的类型" class="headerlink" title="布局的类型"></a>布局的类型</h5><ul>
<li><p>线性布局 (LinearLayout)</p>
<p>orientation 属性用于控制控件的排列方向，值 vertical 表示线性布局垂直显示，值 horizontal 表示线性布局水平显示。</p>
</li>
<li><p>相对布局 (RelativeLayout)</p>
<p>通过相对定位的方式指定控件位置，即以其他控件或父容器为参照物，摆放控件位置。在设计相对布局时要遵循控件之间的依赖关系，后放入控件的位置依赖于先放入的控件。</p>
</li>
<li><p>帧布局 (Framelayout)</p>
<p>为每个加入其中的控件创建一个空白区域（称为—帧，每个控件占据—帧）。所有控件都默认显示在屏幕左上角，并按照先后放入的顺序重叠摆放，先放入的控件显示在最底层，后放入的控件显示在最顶层。前景图片是通过 FrameLayout 标签中的 foreground 属性设置的，并使用 foregroundGravity 属性设置图片居左，前景图片始终保持在最上层 。</p>
</li>
<li><p>表格布局 (TableLayout)</p>
<p>以表格形式排列控件，表格布局每一行都由 TableRow 对象组成，每个单元格都是控件。在 TableRow 标签中设置 layout_width 和 layout_height 属性是没有作用的， 其宽度 layout_width 和高度 layout_height 会自动根据单元格控件决定。 如果其他控件在 TableRow 标签外，会自成一行。</p>
</li>
<li><p>绝对布局 (Absolutelayout)</p>
<p>通过指定 X, y坐标来控制每—个控件位置的。此类已弃用。</p>
</li>
</ul>
<p>@+id 新增一个资源 id，@id 引用现有资源。</p>
<p>控件 layout_width 属性，值 <code>wrap_content</code> 包裹内容让当前控件根据控件内容大小自动伸缩，值 <code>match_parent</code> 填充父窗体由父容器大小决定控件大小。</p>
<p>控件 <code>layout_weight</code> 属性称为权重，通过比例调整布局中所有控件的大小。原理是 Android 先会把布局内所有控件 layout_weight 属性值相加得到总值，然后用该控件 layout_weight 属性值除以总值，得到每个控件的占比，根据占比分配控件所占大小。当标签中使用 layout _weight 时，控件宽度不再由 layout_width 来决定，指定为 0dp 是一种规范。</p>
<p><code>dp</code>: 一种基于屏幕密度的抽象单位。不同设备有不同的显示效果，它是根据设备分辨率的不同来确定控件的尺寸。</p>
<p><code>sp</code>: 代表可伸缩像素，采用与 dp 相同的设计理念。设置文字大小时使用，原因是当修改系统字体大小时，字体大小以dp为单位时，大小不变；当修改系统字体大小时，字体大小以sp为单位时，大小跟随变化。</p>
<h5 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h5><ul>
<li><p>TextView</p>
<table>
<thead>
<tr>
<th>控件属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:text</td>
<td>设置显示文本</td>
</tr>
<tr>
<td>android:textColor</td>
<td>设置文本的颜色</td>
</tr>
<tr>
<td>android:textSize</td>
<td>设置文字大小</td>
</tr>
</tbody></table>
<p>  layout_width、 laylout_height 和 widhth、height 属性的区别：带 “layout” 前缀的属性通常是相对父控件而言的， 而 width、height 属性是相对于控件本身而言的。</p>
</li>
<li><p>EditText</p>
<table>
<thead>
<tr>
<th>控件属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>android:hint</td>
<td>设置 EditText 没有输入内容时显示的提示文本</td>
</tr>
<tr>
<td>android:maxlines</td>
<td>设置最大行数</td>
</tr>
<tr>
<td>android:password</td>
<td>设置文本以密码形式 “.” 显示</td>
</tr>
<tr>
<td>android:phoneNumber</td>
<td>设置文本以电话号码方式输入</td>
</tr>
<tr>
<td>android:editable</td>
<td>设置是否可编辑</td>
</tr>
<tr>
<td>EditText 高度设置为 wrap_content，如果输入内容过多， EditText 会被拉伸，使用 maxlines 属性，如果输入的内容超过了，文本就会出现上下滚动的效果。</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>Button 点击事件</p>
<ul>
<li>在布局中指定 <code>onClick=&quot;click&quot;</code> 属性，然后再 Acitivity 添加 click() 方法。布局代码中 onClick 属性的值( click ) 必须与 Activity 代码中定义的方法名保持一致， 否则 Android系统找不到绑定的点击事件。</li>
<li>使用匿名内部类。 通过 <code>findViewById()</code> 方法初始化控件，使用 <code>setOnClickListener(new View.OnclickListener()&#123; public void onClick(View v) &#123;...&#125;&#125;）</code>方法对控件进行绑定同时实现 onClick(）方法。</li>
<li>在当前 Activity 中实现 OnClickListener 接口并重写 onClick(）方法。然后使用 <code>setOnClickListener(this)</code> 方法对控件进行绑定。</li>
<li>创建内部类。 </li>
</ul>
</li>
<li><p>RadioButton</p>
<p>RadioButton 为单选按钮，它需要与 RadioGroup 配合使用，提供两个或多个互斥的选项集。RadioButton checked 属性值如果设置为 true, 按钮会默认选中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">RadioButton</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">RadioButton</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>ImageView</p>
<p>ImageView 是视图控件，它继承自 View， 其功能是在屏幕中显示图像。引用图片属性的区别在于 background 属性是背景，会根据 ImageView 控件大小进行伸缩，而 src 属性是前景，以原图大小显示。</p>
</li>
</ul>
<h5 id="常见对话框"><a href="#常见对话框" class="headerlink" title="常见对话框"></a>常见对话框</h5><p>对话框—般以小窗口的形式展示在 Activity 之上，当对话框显示时，处在下层的 Activity 失去焦点，对话框便可以接收用户的交互信息。</p>
<ul>
<li><p>普通对话框</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlertDialog dialog;</span><br><span class="line"><span class="comment">// 在 AlertDialog.Builder() 中参数是 context ( 上 下 文 ） 类型，指向当前 Acitivity</span></span><br><span class="line">dialog = <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">    .setTitle(<span class="string">&quot;Dialog&quot;</span>)</span><br><span class="line">    .setMessage(<span class="string">&quot;Quit?&quot;</span>)</span><br><span class="line">    .setIcon(R.mipmap.ic_launcher)</span><br><span class="line">    .setPositiveButton(<span class="string">&quot;Yes&quot;</span>, <span class="keyword">null</span>)		<span class="comment">// 第二个参数为是否设置监听， 没有则设为 &quot;null&quot;</span></span><br><span class="line">    .setNegativeButton(<span class="string">&quot;NO&quot;</span>, <span class="keyword">null</span>)</span><br><span class="line">    .create();</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure></li>
<li><p>单选对话框：setSingleChoiceItems()</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">    .setTitle(<span class="string">&quot;Select&quot;</span>)</span><br><span class="line">    .setIcon(R.mipmap.ic_launcher)</span><br><span class="line"><span class="comment">// 第 1 个参数建立数组，用于显示选项内容</span></span><br><span class="line"><span class="comment">// 第 2 个参数设置是否默认选中， “O&quot; 表示默认选中第一个选项， 如果默认未选中，参数填写－1</span></span><br><span class="line"><span class="comment">// 第 3 个参数是设立监听</span></span><br><span class="line">    .setSingleChoiceItems(<span class="keyword">new</span> String[] &#123; <span class="string">&quot;Male&quot;</span>, <span class="string">&quot;Female&quot;</span>&#125;, <span class="number">0</span>,</span><br><span class="line">        <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .setPositiveButton(<span class="string">&quot;Sure&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    .show();</span><br></pre></td></tr></table></figure></li>
<li><p>多选对话框：setMultiChoiceItems()</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">    .setTitle(<span class="string">&quot;Hobby&quot;</span>)</span><br><span class="line">    .setIcon(R.mipmap.ic_launcher)</span><br><span class="line"><span class="comment">// 第 1 个参数建立数组，用于显示选项内容</span></span><br><span class="line"><span class="comment">// 第 2 个参数是 boolean 数组，用来判断哪个选项需要勾选，如果没有选项选中则用 “null&quot;。定义的长度要对应第 1 个参数设置的选项个数,如 new boolean[]&#123;true, true, true, true)</span></span><br><span class="line"><span class="comment">// 第 3 个参数是建立监听</span></span><br><span class="line">    .setMultiChoiceItems(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Travle&quot;</span>, <span class="string">&quot;Food&quot;</span>, <span class="string">&quot;Car&quot;</span>, <span class="string">&quot;Pet&quot;</span>&#125;), <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">    .setPositiveButton(<span class="string">&quot;Sure&quot;</span>, <span class="keyword">null</span>)</span><br><span class="line">    .show();</span><br></pre></td></tr></table></figure></li>
<li><p>进度条对话框</p>
<p>  Deprecated, to <code>&lt;ProgressBar&gt;</code></p>
</li>
<li><p>消息对话框：Toast</p>
<p>  消息对话框 ( Toast ) 是 Android 系统提供的轻量级信息提醒机制，用于向用户提示即时消息，Toast 对话显示在应用程序界面的最上层，显示—段时间后自动消失，不会打断当前操作，也不获得焦点。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第 1 个参数为当前类的 Context( 上下文 ）对象</span></span><br><span class="line"><span class="comment">//第 2 个参数为文本显示内容</span></span><br><span class="line"><span class="comment">//第 3 个参数为 Toast 显示的时间，有Toast.LENGTH_SHORT 和 ToastLENGTH_LONG</span></span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;Hello, Toast&quot;</span>, Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure></li>
<li><p>自定义对话框</p>
<ul>
<li>创建自定义对话框布局</li>
<li>创建自定义对话框：创建—个类继承自 Dialog 类，引入自定义对话框布局</li>
<li>使用自定义对话框</li>
</ul>
</li>
</ul>
<h5 id="样式和主题"><a href="#样式和主题" class="headerlink" title="样式和主题"></a>样式和主题</h5><p>样式 ( style ) 是包含一种或多种控件的属性集合。Android 中的样式类似于网页中 CSS 样式，可以让设计与内容分离。</p>
<ul>
<li><p>创建样式：在 <code>res\values\style</code> 目录创建 <code>.xml</code> 文件，<code>&lt;resource&gt;</code> 是根标签；<code>&lt;style&gt;</code> 标签定义样式，它包含多个 <code>&lt;item&gt;</code> 来声明样式名称和属性，parent 属性表示继承某个样式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;textStyle_one&quot;</span>&gt;</span> </span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_width&quot;</span>&gt;</span>match_parent<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:layout_height&quot;</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textColor&quot;</span>&gt;</span>#999999<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>35sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;textStyle_two&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;@style/textStyle_one&quot;</span>&gt;</span> </span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textSize&quot;</span>&gt;</span>25sp<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用样式：以 <code>style=&quot;@style/xxx&quot;</code> 引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">style</span>=<span class="string">&quot;@style/textStyle_one&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>主题 (theme) 是应用到整个 Activity 和 Application 的样式，当主题和样式中的属性发生冲突时，样式的优先级要高于主题。</p>
</li>
<li><p>创建主题：主题与样式在代码结构上是一样的，在定义主题时，需要用 parent 属性继承 <code>ThemeAppCompat.Light.DarkActionBar</code> 保证它的兼容性，否则运行时会出现异常</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;grayTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;ThemeAppCompat.Light.DarkActionBar&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>= <span class="string">&quot;android:background&quot;</span>&gt;</span>#999999<span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用主题：</p>
<ul>
<li><p>在 AndroidManifest.xml 文件中引用自定义主题：</p>
<ul>
<li><p>在 <code>&lt;activity&gt;</code> 标签中添加 <code>android:theme=&quot;@style/xxxx&quot;</code> 属性，此处是改变当前界面的主题样式 </p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/grayTheme&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改变 <code>&lt;application&gt;</code> 标签 <code>android:theme</code> 属性，此处是整个应用程序主题的样式</p>
</li>
</ul>
</li>
<li><p>在 Activity 代码中引用自定义主题：在 onCreate() 方法内 setContentView() 方法之后添加 setTheme() 方法，</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setTheme(R.style.grayTheme);</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h5 id="国际化（i18n）"><a href="#国际化（i18n）" class="headerlink" title="国际化（i18n）"></a>国际化（i18n）</h5><p>国际化的应用具备支持多种语言功能，能被不同国家或地区用户访问，提供符合访问者阅读习惯的页面和数据。</p>
<p>实现国际化：</p>
<ul>
<li><p>在程序的 <code>res/values/</code> 目录下创建用于国际化的文件 <code>strings.xml</code>，单击右键，选择 New -&gt; Values resource file 选项，在 Available qualifiers 区域中选择 Locale, 单击中间的向右图标，在 Language 语言区域中选择语言， 在 Specific Region Only 中选择区域，此时 Directory name 名称会根据选择的语言以及区域自动变化，其命名规则为 <code>values­-语言代码－r国家或地区代码</code>。由于每个程序都自带一个 strings.xml 文件，Android Studio 会自动创建一个文件夹存放这些同名文件，并且会根据语言和地区区分这些文件。</p>
</li>
<li><p>来在创建好的 strings.xml 文件中编写支持的语言内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;l.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>安卓＿il8n<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;hello_world&quot;</span>&gt;</span>你好，世界！&lt;／string&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>android:text=&quot;@string/xxxx&quot;</code> 引用 strings.xml 中定义的文本信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">android:text</span>=<span class="string">&quot;@string/hello_world&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>改变模拟器语言为对应的语言，即可实现国际化。其原理是，当用 <code>＠string/xxxx</code> 方式引用一个文本资源时，Android 系统会首先判断手机设置的语言和地区，然后通过这些信息寻找 values 目录下对应的 strings.xml 文件，引用其中的内容。</p>
</li>
</ul>
<h5 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h5><ul>
<li>单元测试：是指在应用程序开发过程中对最小的功能模块进行测试，可以在完成某个功能之后对该功能进行单独测试， 而不需要把应用程序安装到手机或启动模拟器再对各项功能进行测试，这样会提高开发效率和质量。在项目创建时 Android Studio 就巳经默认创建了一个androidTest 包和 ApplicationTest 类，所有测试的功能模块写入此类即可。所有的测试方法必须以 test 开头。</li>
<li>LogCat：是 Android 中的命令行工具，用于获取程序从启动到关闭的日志信息。Android 采用 <code>android.util.Log</code> 类的静态方法实现输出程序信息。Log 类所输出的日志内容级别由低到高分别是 Verbose、Debug 、Info、 Warning、Error、Assert，分别对应 Log 类中的 Log.v()、Log.d()、Log.i()、Log.w()、Log.e() 静态方法，Assert 没有对应的静态方法。</li>
<li>Debug：是跟踪程序流程的一种模式，可以通过在代码处设置断点， 再利用 Debug 窗口查看。所谓断点是在代码行加入停止点，当程序执行到该行时会暂停。</li>
</ul>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h5 id="Activity-的创建"><a href="#Activity-的创建" class="headerlink" title="Activity 的创建"></a>Activity 的创建</h5><p>一个应用程序通常包含多个 Activity, 每个 Activity 负责管理一个用户界面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity 需要在 AndroidManifest.xml 文件（清单文件）中注册，添加一行 <code>&lt;activity android:name=&quot; .MainActivity&quot;/&gt;</code> 代码。</p>
<h5 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h5><p>Activity 的生命周期分为 5 种状态：</p>
<ul>
<li>启动状态：Activity 的启动状态很短暂<ul>
<li>onCreate() 方法</li>
<li>onStart() 方法</li>
<li>onRestart() 方法</li>
</ul>
</li>
<li>运行状态：Activity 在此状态时处于屏幕最前端，它是可见、有焦点的，可以与用户进行交互<ul>
<li>onResume() 方法</li>
</ul>
</li>
<li>暂停状态：无法获取焦点，用户对它操作没有响应，此时就处于暂停状态<ul>
<li>onPause() 方法</li>
</ul>
</li>
<li>停止状态：当 Activity 完全不可见时<ul>
<li>onStop() 方法</li>
</ul>
</li>
<li>销毁状态：被清理出内存<ul>
<li>onDestroy() 方法</li>
</ul>
</li>
</ul>
<p>横竖屏切换时的生命周期会有不同。</p>
<h5 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h5><p>Android 中，采用任务栈的形式来管理 Activity。这个栈又被称为返回栈，栈中 Activity 的顺序就是按照它们被打开的顺序依次存放。用户操作的永远是栈顶的 Activity。</p>
<p>Activity 启动模式：在 AndroidManifest.xml 中通过 <code>&lt;activity&gt;</code> 标签 android:launchMode 属性设置启动模式 </p>
<ul>
<li>standard 模式：每启动一个 Activity 就会在栈顶创建一个新的实例</li>
<li>singleTop 模式：判断要启动的 Activity 实例是否位于栈顶，如果位于栈顶则直接复用，否则创建新的实例</li>
<li>singleTask 模式：则每次启动 Activity 时，系统首先会检查栈中是否存在当前 Activity 实例，如果存在 则直接使用，并把当前 Activity 之上的所有实例全部出栈，否则重新创建一个实例</li>
<li>singlelnstance 模式： 每一个 Activity 独占一个任务栈。一种是要启动的 Activity 不存在，则系统会<br>先创建一个新的任务栈，然后再创建 Activity 实例； 一种是要启动的 Activity 已存在，则直接复用（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRVgzMi9wLzQ2MjM3NjQuaHRtbA==">ref<i class="fa fa-external-link-alt"></i></span>）</li>
</ul>
<h5 id="Activity-之间的跳转"><a href="#Activity-之间的跳转" class="headerlink" title="Activity 之间的跳转"></a>Activity 之间的跳转</h5><p>Activity 之间的跳转通过 Intent 实现：</p>
<ul>
<li><p>显式意图：目标 Activity 需在 AndroidManifest.xml 注册了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中第1个参数为当前的 Activity 对象， 第2个参数为启动的目标 Activity</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ActivityName.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li>
<li><p>隐式意图：系统通过分析指定的属性信息，寻找目标 Activity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(); </span><br><span class="line"><span class="comment">// 设置 action 动作，该动作要和清单文件中设置的一样</span></span><br><span class="line">intent.setAction(<span class="string">&quot;example.START_ACTIVITY&quot;</span>); </span><br><span class="line">startActivity(intent); </span><br></pre></td></tr></table></figure>
<p>在目标 Activity 的清单文件中配置 <code>&lt;intent-filter&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;example.MainActivity&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;example.START_ACTIVITY&quot;</span>/&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="Activity-中的数据传递"><a href="#Activity-中的数据传递" class="headerlink" title="Activity 中的数据传递"></a>Activity 中的数据传递</h5></li>
<li><p>数据传递：Intent 提供了一系列重载的 putExtra(String name, String value)方法，通过该方法可以将要传递的数据暂存到 Intent 中，然后从目标 Activity 中取出。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ActivityName.class); </span><br><span class="line">intent.putExtra(<span class="string">&quot;extra_key&quot;</span>, <span class="string">&quot;extra_data&quot;</span>); </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = getIntent(); </span><br><span class="line">String extra_data = intent.getStringExtra(<span class="string">&quot;extra_key&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>数据回传：startActivityForResult(Intent intent, int requestCode)方法在目标 Activity 销毁时返回一个结果给调用 Activity。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, ActivityName.class); </span><br><span class="line"><span class="comment">// 第1个参数是 Intent 对象；第2个参数是请求码，用于判断数据的来源，输入一个唯一值即可</span></span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(); </span><br><span class="line">intent.putExtra(<span class="string">&quot;extra_key&quot;</span>, <span class="string">&quot;extra_data&quot;</span>); </span><br><span class="line"><span class="comment">// setResult(int resultCode, Intent intent)，resultCode 一般是 0 或 1</span></span><br><span class="line">setResult(l, intent) ;</span><br></pre></td></tr></table></figure>

<p>  在目标 Activity 被销毁之后会回调调用 Activity 的 onActivityResult()方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent intent)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, intent); </span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (resultCode == <span class="number">1</span>) &#123; </span><br><span class="line">            String string = intent.getStringExtra(<span class="string">&quot;extra_key&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在一个 Activity 中可能多个调用 startActivityForResult()方法，每一个 Activity 返回的数据都会回调onActivityResult()方法，因此，要通过 requestCode 的值来判断数据来源。</p>
</li>
</ul>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h5 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h5><ul>
<li>文件存储：存储大数据，如文本、图片、音频等。</li>
<li>SharedPreferences：存储应用程序的各种配置信息，如用户名、密码等。</li>
<li>SOLite 数据库：作为复杂数据的存储引擎，可以存储用户信息等。</li>
<li>ContentProvider：用于应用程序之间的数据交换。</li>
<li>网络存储：通过网络提供的存储空间来存储／获取数据信息。</li>
</ul>
<h5 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h5><ul>
<li><p>内部存储：将应用程序数据以文件方式存储到设备的内部（默认位于 <code>data/data/&lt;packagename&gt;/files／</code> 下），文件为其所创建的应用程序私有，其他应用程序访问需要权限。应用程序卸载时，其内部存储文件也随之被删除。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fos = openFileOutput(String name, <span class="keyword">int</span> mode); </span><br><span class="line">FileinputStream fis = openFileInput(String name);</span><br></pre></td></tr></table></figure>
<p>  “mode” 是读写文件的方式：默认情况下任何应用创建的文件都是私有的</p>
<ul>
<li><p>MODE_PRIVATE: 该文件只能被当前程序读写</p>
</li>
<li><p>MODE_APPEND: 该文件的内容可以追加</p>
</li>
<li><p>MODE_WORLD_READABLE: 该文件的内容可以被其他程序读</p>
</li>
<li><p>MODE_WORLD_WRITEABLE: 该文件的内容可以被其他程序写</p>
<p>存储数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fileName = <span class="string">&quot;data.txt&quot;</span>;	<span class="comment">// 文件名称</span></span><br><span class="line">String content = <span class="string">&quot;helloworld&quot;</span>;	<span class="comment">// 保存数据</span></span><br><span class="line">FileOutputStream fos; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    fos = openFileOutput(fileName, MODE_PRIVATE); </span><br><span class="line">    fos.write(content.getBytes());	<span class="comment">// 将了数据写入文件中</span></span><br><span class="line">    fas.close(); <span class="comment">// 关闭输出流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="string">&quot;&quot;</span>; </span><br><span class="line">FileinputStream fis; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    fis = openFileinput(<span class="string">&quot;data.txt&quot;</span>);	<span class="comment">// 获得文件输入流对象</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];	<span class="comment">// 创建缓冲区，并获取文件长度</span></span><br><span class="line">    fis.read(buffer);	<span class="comment">// 将文件内容读取到 buffer 缓冲区</span></span><br><span class="line">    content = <span class="keyword">new</span> String(buffer );	<span class="comment">// 转换成字符串</span></span><br><span class="line">    fis.close();	<span class="comment">// 关闭输入流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外部存储：将文件存储到外部设备上，如 SD 卡（该文件通常位于 <code>mnt/sdcard</code> 下）。外部存储的文件被其他应用程序共享。</p>
<p>  向 SD 卡存储数据：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String state = Environment.getExternalStorageState();	<span class="comment">// 获取外部设备</span></span><br><span class="line"><span class="keyword">if</span> (state.equals(Environment.MEDIA_MOUNTED)) &#123;	<span class="comment">// 判断外部设备是否可用</span></span><br><span class="line">    File SDPath = Environment.getExternalStorageDirectory();	<span class="comment">// 获取 SD 卡目录，deprecated</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(SDPath, <span class="string">&quot;data.txt&quot;</span>); </span><br><span class="line">    String data = <span class="string">&quot;HelloWorld&quot;</span>; </span><br><span class="line">    FileOutputStream fos; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(file); </span><br><span class="line">        fos.write(data.getBytes()); </span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从 SD卡 读取数据:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String state = Environment.getExternalStorageState(); </span><br><span class="line"><span class="keyword">if</span> (state.equals(Environment.MEDIA_MOUNTED)) &#123; </span><br><span class="line">    File SDPath = Environment.getExternalStorageDirectory(); </span><br><span class="line">    File file = <span class="keyword">new</span> File(SDPath, <span class="string">&quot;data.txt&quot;</span>); </span><br><span class="line">    FileinputStream fis; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        fis = <span class="keyword">new</span> FileinputStream(file); </span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis)); </span><br><span class="line">        String data = br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  读取 SD 卡需要在清单文件的 <code>&lt;manifest&gt;</code> 节点中添加读写权限：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="XML-解析"><a href="#XML-解析" class="headerlink" title="XML 解析"></a>XML 解析</h5></li>
</ul>
<p>在 Android 中最常用的解析方式是 PULL 解析。</p>
<p>XmlPullParser 解析器的常用属性：</p>
<ul>
<li>XmlPullParser.START_DOCUMENT: XML 文档的开始</li>
<li>XmlPullParser.END_DOCUMENT: XML 文档的结束</li>
<li>XmlPullParser.START_TAG: 开始节点，带有 <code>＜ ＞</code> 的都是开始节点</li>
<li>XmlPullParser.END_TAG：结束节点，带有 <code>&lt;/ &gt;</code> 的都是结束节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">parser.setinput(is, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> type = parser.getEventType();</span><br><span class="line"><span class="keyword">while</span> (type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> XmlPullParser.START_TAG:</span><br><span class="line">            String temp = parser.nextText();	<span class="comment">// 得到该 tag 节点中的内容</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> XmlPullPaser.END_TAG:</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    type = parser.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="JSON-解析"><a href="#JSON-解析" class="headerlink" title="JSON 解析"></a>JSON 解析</h5><p>JSON 即 Java Script Object Notation，JSON 有两种数据结构：</p>
<ul>
<li><p>对象结构：以 “{“ 开始，以 “}” 结束。中间部分由 0 个或多个以 “,” 分隔的 key:value 对构成</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	key1:value1,</span><br><span class="line">	key2:value2,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组结构：以 “[“ 开始，以 “]” 结束。中间部分由 0 个或多个以 “,” 分隔的值组成</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>JSON 解析：</p>
</li>
<li><p>使用内置的 org.json 包解析 JSON 数据</p>
<ul>
<li><p>使用 JSONObject 解析 JSON 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONObject jsonObj = new JSONObject(json);	# json 是字符串</span><br><span class="line">String name = jsonObj.optString(<span class="string">&quot;name&quot;</span>); </span><br><span class="line"><span class="keyword">int</span> age = jsonObj.optInt(<span class="string">&quot;age&quot;</span>); </span><br><span class="line"><span class="keyword">boolean</span> married = jsonObj.optBoolean(<span class="string">&quot;married&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>使用 JSONArray 解析 JSON 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONArray jsonArray = <span class="keyword">new</span> JSONArray(json); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = O; i &lt; jsonArray.length(); i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> age = jsonArray.optInt (i) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用开源的 Gson 库解析 JSON 数据：需将 gson.jar 添加到项目中</p>
<ul>
<li><p>使用 Gson 解析 JSON 对象：需创建 JSON 数据对应的实体类，实体类中的成员名称与 JSON 数据的 key 值一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson(); </span><br><span class="line">Person person = gson.fromJson(json, Person.class);	<span class="comment">// Person 为对应实体类</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 Gson 解析 JSON 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()]; </span><br><span class="line">is.read(buffer); </span><br><span class="line">String json = <span class="keyword">new</span> String(buffer, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson(); </span><br><span class="line">Type listType = <span class="keyword">new</span> TypeToken&lt;List&lt;Interger&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">List&lt;Integer&gt; ages = gson.fromJson(json, listType);</span><br></pre></td></tr></table></figure>
<h5 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h5></li>
</ul>
</li>
</ul>
<p>SharedPreferences 通过 key/value 的形式将数据保存在 XML 文件中，该文件位于 <code>data/data/</code><br><code>&lt;packagename&gt;/shared_prefs</code> 文件夹中。value 值只能是 Float、Int、Long、Boolean、String、StringSet 类型数据。</p>
<ul>
<li><p>存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 data 表示文件名， MODE_PRIVATE 表示文件操作模式</span></span><br><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">&quot;data&quot;</span>, MODE_PRIVATE); </span><br><span class="line">SharedPreferences.Editor editor = sp.edit ();	<span class="comment">// 获取编辑器</span></span><br><span class="line">editor.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;value&quot;</span>);	<span class="comment">// 存入 String 类型数据</span></span><br><span class="line">editor.putlnt(<span class="string">&quot;age&quot;</span>, <span class="number">8</span>);	<span class="comment">// 存入 Int 类型数据</span></span><br><span class="line">editor.remove(<span class="string">&quot;name&quot;</span>);	<span class="comment">// 删除一条数据</span></span><br><span class="line">editor.clear();	<span class="comment">// 删除所有数据</span></span><br><span class="line">editor.commit();	<span class="comment">// 提交修改</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">&quot;data&quot;</span>, MODE_PRIVATE); </span><br><span class="line">String data = sp.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot; &quot;</span>);	<span class="comment">// 第二个参数为缺省值，如果不存在该 key, 将返回缺省值</span></span><br></pre></td></tr></table></figure>
<h3 id="SQLite-数据库"><a href="#SQLite-数据库" class="headerlink" title="SQLite 数据库"></a>SQLite 数据库</h3></li>
</ul>
<h5 id="SQLite-数据库简介"><a href="#SQLite-数据库简介" class="headerlink" title="SQLite 数据库简介"></a>SQLite 数据库简介</h5><p>SQLite 是 D.Richard Hipp 建立的公有领域项目，它的设计目标是嵌入式的。SQLite 是遵守 ACID 的关系型数据库管理系统。</p>
<p>SQLite 没有服务器进程，它通过文件保存数据，该文件是跨平台的。支持 null（零）、integer（整数）、real（浮点数字）、text（字符串文本）和 blob（二进制对象）5 种数据类型，其他数据类型在运算或保存时会转换成对应的 5 种数据类型。</p>
<h5 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h5><p>Android 系统推荐使用 SOLiteOpenHelper 的子类创建数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyHelper</span><span class="params">(Context context)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 分别为上下文对象、数据库名称、游标工厂（通常是 null）、数据库版本</span></span><br><span class="line">		<span class="keyword">super</span>(context, <span class="string">&quot;example.db&quot;</span>, <span class="keyword">null</span>, <span class="number">2</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 数据库第一次被创建时调用该方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123; </span><br><span class="line">		<span class="comment">// 初始化数据库的表结构， 执行一条建表的 SQL 语句</span></span><br><span class="line">		db.execSQL(<span class="string">&quot;CREATE TABLE information(_id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(20), price INTEGER)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 当数据库的版本号增加时调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h5><ul>
<li><p>SQLite 的基本操作</p>
<ul>
<li><p>增加一条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String name, String price)</span> </span>&#123; </span><br><span class="line">	SQLiteDatabase db = helper.getWritableDatabase();</span><br><span class="line">	ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">	values.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">	values.put(<span class="string">&quot;price&quot;</span>, price); </span><br><span class="line">    <span class="comment">// 第一个参数表名，第二个参数为缺省值 null，第三个参数为 ContentValues 对象</span></span><br><span class="line">	<span class="keyword">long</span> id = db.insert(<span class="string">&quot;information&quot;</span>, <span class="keyword">null</span>, values);</span><br><span class="line">	db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改一条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String name, String price)</span> </span>&#123; </span><br><span class="line">	SQLiteDatabase db = helper.getWritableDatabase(); </span><br><span class="line">	ContentValues values = <span class="keyword">new</span> ContentValues(); </span><br><span class="line">	values.put(<span class="string">&quot;price&quot;</span>, price); </span><br><span class="line">    <span class="comment">// 第一个参数表名，第二个参数 ContentValues 对象，第三个参数 where 语句，第四个参数字符串会替换掉 where 条件中的 &quot;?&quot;</span></span><br><span class="line">	<span class="keyword">int</span> number = db.update(<span class="string">&quot;information&quot;</span>, values, <span class="string">&quot;name =?&quot;</span>, <span class="keyword">new</span> String[]&#123; name &#125;); </span><br><span class="line">	db.close () ; </span><br><span class="line">	<span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除一条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123; </span><br><span class="line">	SQLiteDatabase db = helper.getWritableDatabase(); </span><br><span class="line">	<span class="keyword">int</span> number = db.delete(<span class="string">&quot;information&quot;</span>, <span class="string">&quot;_id=?&quot;</span>, <span class="keyword">new</span> String[]&#123; id+<span class="string">&quot;&quot;</span> &#125;); </span><br><span class="line">	db.close(); </span><br><span class="line">	<span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查询一条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123; </span><br><span class="line">	SQLiteDatabase db = helper.getReadableDatabase();</span><br><span class="line">    <span class="comment">// 第一个参数表名，第二个参数查询的列名，第三个参数查询条件子句，第四个参数查询子句对应的条件值，第五个参数分组方式，第六个参数 having 条件，第七个参数排序方式</span></span><br><span class="line">	Cursor cursor = db.query(<span class="string">&quot;information&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;_id=?&quot;</span>, <span class="keyword">new</span> String[]&#123; id+<span class="string">&quot;&quot;</span> &#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">	<span class="keyword">boolean</span> result = cursor.moveToNext(); </span><br><span class="line">	cursor.close();</span><br><span class="line">	db.close(); </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 SQL 语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加一条数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;insert into information(name, price) values (?, ?)&quot;</span>, <span class="keyword">new</span> Object[]&#123; name, price &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改一条数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;update information set name= ? where price = ?&quot;</span>, <span class="keyword">new</span> Object[]&#123; name , price &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一条数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;delete from information where _id = 1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询的 SQL 语句</span></span><br><span class="line">Cursor cursor = db.rawQuery(<span class="string">&quot;select * from person where name= ?&quot;</span>, <span class="keyword">new</span> String[]&#123; name &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>SQLite 中的事务：事务由一条或多条 SQL 语句组成，如果其中有一条语句无法执行，那么所有的语句都不会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyHelper helper = <span class="keyword">new</span> MyHelper(getContext());</span><br><span class="line">SQLiteDatabase db = helper.getWritableDatabase(); </span><br><span class="line"><span class="comment">// 开始数据库的事务</span></span><br><span class="line">db.beginTransaction(); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">	db.execSQL(<span class="string">&quot;update person set account = account-1000 where name = ?&quot;</span>, <span class="keyword">new</span> Object[]&#123; <span class="string">&quot;zhangsan&quot;</span> &#125;); </span><br><span class="line">	db.execSQL(<span class="string">&quot;update person set account = account+lOOO where name = ?&quot;</span>, <span class="keyword">new</span> Object[]&#123; <span class="string">&quot;wangwu&quot;</span> &#125;) ; </span><br><span class="line">	<span class="comment">// 标记数据库事务执行成功</span></span><br><span class="line">	db.setTransactionSuccessful(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">	Log.i( <span class="string">&quot;事务处理失败&quot;</span>, e.toString());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否有事务执行成功标记，有则提交数据，无则回滚数据</span></span><br><span class="line">	db.endTransaction(); </span><br><span class="line">	db.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数据展示控件"><a href="#数据展示控件" class="headerlink" title="数据展示控件"></a>数据展示控件</h5></li>
</ul>
<p>ListView 是一个列表视图，由很多 Item（条目）组成，每个 Item 的布局都相同，这个 Item 布局会单独使用一个 XML 进行定义。</p>
<p>常用数据适配器：使用 ListView 控件需要进行数据适配，在进行数据适配时会用到数据适配器，数据适配器将复杂的数据转换成用户可以接受的方式呈现</p>
<ul>
<li><p>BaseAdapter：是一个抽象类</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>public int getCount()</td>
<td>得到 Item 条目的总数</td>
</tr>
<tr>
<td>public Object getltem(int position)</td>
<td>根据 position（ 位置 ）得到某个 Item 的对象</td>
</tr>
<tr>
<td>public long getItemId(int position)</td>
<td>根据 position（ 位置 ）得到某个 Item 的 id</td>
</tr>
<tr>
<td>public View getView(int position, View convertView, ViewGroup parent)</td>
<td>得到相应 position 对应的 Item 视图，position 是当 Item 的位置，conbertView 用于复用旧视图，parent 用于加载 XML 布局</td>
</tr>
</tbody></table>
</li>
<li><p>SimpleAdapter：SimpleAdapter 继承自 BaseAdapter，使用 SimpleAdapter 只需要在构造方法里传入相应的参数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAdapter</span><span class="params">(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, <span class="keyword">int</span> resource , String[] from, <span class="keyword">int</span>[] to)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Context context: Context 上下文对象</li>
<li><code>List&lt;? extends Map&lt;String, ?&gt;&gt;</code> data：data 中的每一项对应着 ListView 中的每一项的数据</li>
<li>int resource: Item 布局的资源 id</li>
<li>String[] from: Map 集合里面的 key 值</li>
<li>int[] to： Item 布局相应的控件 id</li>
</ul>
</li>
<li><p>ArrayAdapter：与 SimpleAdapte 类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resource)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resource, <span class="keyword">int</span> textViewResourceId)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resource, T[] objects)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resource, <span class="keyword">int</span> textViewResourceId, T[] objects)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resource, List&lt;T&gt; objects)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resource, <span class="keyword">int</span> textViewResourceId, List&lt;T&gt; objects)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Context context: Context 上下文对象</li>
<li>int resource：Item 布局的资源 id</li>
<li>int textViewResourceId: Item 布局中相应 TextView 的 id</li>
<li>T[] objects: 需要适配的数据数组，数组类型数据</li>
<li><code>List&lt;T&gt; objects</code>: 需要适配的数据数组，List 类型数据</li>
</ul>
</li>
</ul>
<p>ListView 的优化：</p>
<ul>
<li><p>复用 convertView：在使用 ListView 展示数据时需要创建对应的 Item 条目展示每条数据。如果展示的数据有成千上万条，那么就需要创建成千上万个 Item, 这样会大大增加内存的消耗。解决办法是底部滑入的 Item 复用顶部划出的 Item</p>
</li>
<li><p>使用 ViewHolder 类：在加载 Item 布局时，会使用 findViewById(）方法找到 Item 布局中的各个控件，在每一次加载新的 Item 数据时都会进行控件寻找，这会产生耗时操作。解决办法是将要加载的子 View 放在 ViewHolder 类中，当第一次创建 convertView 时将这些控件找出，在第二次重用 convertView 时就可直接通过 convertView 中的 getTag(）方法获得这些控件</p>
</li>
<li><pre><code class="java">public View getView(int position, View convertView, ViewGroup parent) &#123;
    ViewHolder holder; 
    if (convertView == null) &#123; 
        convertView = LayoutInflater.from(getApplicationContext()).inflate(R.layout.list_item, parent，false);
        holder = new ViewHolder(); 
        holder.mTextView = (TextView) convertView.findViewById(R.id.itern_tv); 
        holder.imageView = (ImageView) convertView.findViewById(R.id.itern_image); 
        convertView.setTag(holder);
    &#125; else &#123; 
        holder = (ViewHolder) convertView.getTag();
    &#125;
    holder.mTextView.setText(names[position]);
    holder.imageView.setBackgroundResource(icons[position]);
    return convertView; 
&#125;

class ViewHolder &#123; 
    TextView mTextView; 
    ImageView imageView;
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### BroadcastReceiver（广播接收者）</span><br><span class="line"></span><br><span class="line">通过广播接收者可以监听系统中的广播消息，并实现在不同组件之间的通信。</span><br><span class="line"></span><br><span class="line">##### 广播接收者入门</span><br><span class="line"></span><br><span class="line">广播接收者的静态注册：在清单文件进行注册并指定要接收的广播事件。静态注册的特点是无论应用程序是否处于运行状态，广播接收者都会对程序进行监听</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">&lt;application&gt; </span><br><span class="line">    &lt;!-- Exported 复选框用于选择是否接收当前程序之外的广播，Enabled 复选框用于选择广播接收者是否可以由系统实例化 --&gt;</span><br><span class="line">	&lt;receiver</span><br><span class="line">		android:name&#x3D;&quot;.MyReceiver&quot; </span><br><span class="line">		android:enabled&#x3D;&quot;true&quot; </span><br><span class="line">		android:exported&#x3D;&quot;true&quot;&gt;</span><br><span class="line">		&lt;intent-filter&gt; </span><br><span class="line">			&lt;action android:name&#x3D;&quot;android.provider.Telephony.SMS_RECEIVED&quot;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;intent-filter&gt;</span><br><span class="line">    &lt;&#x2F;receiver&gt;</span><br><span class="line">&lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure>
广播接收者的动态注册：动态注册的广播接收者的生命周期依赖于注册广播的组件，当组件销毁时，广播接收者也随之被移除
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedinstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedinstanceState); </span><br><span class="line">	MyReceiver receiver = <span class="keyword">new</span> MyReceiver(); </span><br><span class="line">	String action = <span class="string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span>; </span><br><span class="line">	IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(action);</span><br><span class="line">	registerReceiver(receiver, intentfilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onDestroy(); </span><br><span class="line">	<span class="comment">// 当 Activity 销毁时取消注册 Broadca stReceiver</span></span><br><span class="line">	unregisterReceiver(receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个类继承自 BroadcastReceiver 类，重写 onReceive()方法，在方法中处理广播事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyReceiver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h5><p>自定义广播发送消息会储存到公共消息区中，公共消息区中如果存在对应的广播接收者，就会及时地接收这条信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">// 自定义广播的事件类型</span></span><br><span class="line">intent.setAction(<span class="string">&quot;Help_Stitch&quot;</span>);</span><br><span class="line"><span class="comment">// 发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;Help_Stitch&quot;</span>/&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="广播的类型"><a href="#广播的类型" class="headerlink" title="广播的类型"></a>广播的类型</h5><p>无序广播：发送广播时，所有监听这个广播的广播接收者都会接收到此广播消息，但接收和执行的顺序不确定。无法被拦截。</p>
<p>有序广播：按照接收者声明的优先级别被依次接收。通过 abortBroadcast()方法拦截有序广播。在 <code>&lt;intent-filter&gt;</code> 标签中使用 priority 属性设置优先级别，属性值越大优先级越高。如果两个广播接收者的优先级相同，则先注册的广播接收者优先级高。两个程序监听了同一个广播事件，同时都设置了优先级属性，则先安装的程序优先接收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">&quot;Intercept_Stitch&quot;</span>);</span><br><span class="line"><span class="comment">// 发送有序广播，第 2 个参数指定接收者的权限</span></span><br><span class="line">sendOrderedBroadcast(intent , <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>指定广播接收者：保证一个广播接收者必须接收到此广播， 无论此广播接收者的优先级高低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// receiver 即指定广播接收者</span></span><br><span class="line">sendOrderedBroadcast(intent, <span class="keyword">null</span>, receiver, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Service（服务）"><a href="#Service（服务）" class="headerlink" title="Service（服务）"></a>Service（服务）</h3><p>Service（服务）是一个即使切换到另一个程序依旧运行在后台的用户组件，没有用户界面。</p>
<h5 id="服务的创建"><a href="#服务的创建" class="headerlink" title="服务的创建"></a>服务的创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enabled 属性表示系统是否能够实例化该组件，exported 属性表示该服务是否能够被其他应用程序组件调用或交互 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">service</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:name</span>=<span class="string">&quot;.MyService&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a>服务的生命周期</h5><ul>
<li><p>通过 startService()方法启动服务时，执行的生命周期方法为 onCreate()、onStartCommand()，然后服务处于运行状态，直到自身调用 stopSelf()方法或者其他组件调用 stopService()方法时服务停止，执行 onDestory()方法销毁服务</p>
</li>
<li><p>通过 bindService()方法启动服务时，执行的生命周期方法为 onCreate()、onBind()，然后服务处于运行状态，直到客户端调用 unBindService()方法执行 onUnbind()方法断开服务绑定，执行 onDestory()方法销毁服务</p>
</li>
</ul>
<h5 id="服务的启动方式"><a href="#服务的启动方式" class="headerlink" title="服务的启动方式"></a>服务的启动方式</h5><p>startService 方式启动：服务会长期在后台运行，并且服务的状态与开启者的状态没有关系，即使启动服务的组件已经被销毁，服务也会依旧运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启服务</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class); </span><br><span class="line">startService(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭服务</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class); </span><br><span class="line">stopService(intent);</span><br></pre></td></tr></table></figure>
<p>bindService 方式启动：服务与组件绑定，允许组件与服务交互，多个组件可以绑定一个服务，当组件销毁后服务也会随之解绑销毁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConn</span> <span class="keyword">implements</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当服务连接时调用的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 当服务失去连接时调用的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定服务</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">MyConn myconn = <span class="keyword">new</span> MyConn();</span><br><span class="line"><span class="comment">// 第一个参数用于指定要启动的 Service</span></span><br><span class="line"><span class="comment">// 第二个参数为 ServiceConnection 对象，用于监听调用者与 Service 之间的连接状态</span></span><br><span class="line"><span class="comment">// 第三个参数指定为 0, 不自动创建 Service；指定为 BIND_AUTO_CREATE, 自动创建 Service</span></span><br><span class="line">bindService(intent, myconn, BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑服务</span></span><br><span class="line">unbindService(myconn);</span><br></pre></td></tr></table></figure>
<h5 id="服务的通信"><a href="#服务的通信" class="headerlink" title="服务的通信"></a>服务的通信</h5><p>本地服务通信是指应用程序内部的通信，远程服务通信是指两个应用程序之间的通信。须保证服务是以绑定方式开启。</p>
<p>本地服务通信：Service 类的 onBind()方法返回一个 IBinder 对象，IBinder 对象会作为参数传递给 ServiceConnection 类中的 onServiceConnected(ComponentName name,IBinder service)方法，这样访问者就可以通过 IBinder 对象与 Service 进行通信。</p>
<p>远程服务通信：远程服务通信通过 AIDL(Android Interface Definition Language) 实现。</p>
<h3 id="ContentProvider（内容提供者）"><a href="#ContentProvider（内容提供者）" class="headerlink" title="ContentProvider（内容提供者）"></a>ContentProvider（内容提供者）</h3><h5 id="内容提供者简介"><a href="#内容提供者简介" class="headerlink" title="内容提供者简介"></a>内容提供者简介</h5><p>B 程序通过 Context 中的 getContentResolver()方法获取 ContentResolver 类访问 A 程序通过 ContentProvider 共享的数据。</p>
<p>ContentResolver 以 Uri 的形式对外提供数据增、删、改、查操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content:&#x2F;&#x2F;com.example.mycontentprovider&#x2F;person</span><br></pre></td></tr></table></figure>
<ul>
<li>scheme：”content://“，是一个标准的前缀</li>
<li>authority：”com.example.mycontentprovider”，是在创建内容提供者时指定的 authorities 属性值，主要用来区分不同的应用程序，一般采用程序包名</li>
<li>path：”/person”，代表资源或者数据</li>
</ul>
<h5 id="内容提供者的创建"><a href="#内容提供者的创建" class="headerlink" title="内容提供者的创建"></a>内容提供者的创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyContentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在内容提供者创建时调用</span></span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回指定 Uri 代表的数据的 MIME 类型</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String [] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] select)</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">provider</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:name</span>=<span class="string">&quot;.MyContentProvider&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:authorities</span>=<span class="string">&quot;com.example.mycontentprovider&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">provider</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="内容提供者的使用"><a href="#内容提供者的使用" class="headerlink" title="内容提供者的使用"></a>内容提供者的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串转化成 Uri 对象</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.example.mycontentprovider/person&quot;</span>); </span><br><span class="line"><span class="comment">// 获取到 ContentResolver 对象</span></span><br><span class="line">ContentResolver resolver = context.getContentResolver(); </span><br><span class="line"><span class="comment">// 通过 ContentResolver 对象查询数据</span></span><br><span class="line">Cursor cursor = resolver.query(uri , <span class="keyword">new</span> String[]&#123;<span class="string">&quot;address&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;body&quot;</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line"><span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">	String address = cursor.getString(<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">long</span> date = cursor.getLong(<span class="number">1</span>); </span><br><span class="line">	<span class="keyword">int</span> type = cursor.getint(<span class="number">2</span>); </span><br><span class="line">	String body = cursor.getString(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">cursor.close();</span><br></pre></td></tr></table></figure>
<p>工具类 UriMatcher 用于匹配 Uri：</p>
<ul>
<li>public UriMatcher(int code)：创建 UriMatcher 对象时调用，参数通常使用 UriMatcher.NO_MATCH, 表示路径不满足条件返回－1</li>
<li>public void addURI(String authority, String path, int code)：添加一组匹配规则，authority 即 Uri 的 authoritites 部分，path 即 Uri 的 path 部分， code 即 Uri 匹配成功后返回的匹配码</li>
<li>public int match(Uri uri)：匹配 Uri，与 addURI(）方法相对应，匹配成功则返回 addURI()方法中传入的参数 code 的值</li>
</ul>
<h5 id="内容观察者的使用"><a href="#内容观察者的使用" class="headerlink" title="内容观察者的使用"></a>内容观察者的使用</h5><p>B 程序操作 A 程序中的数据时，A 程序的 ContentProvider 调用 ContentResolver 的 notifyChange()方法向 “消息中心” 发送数据变化的消息，C 程序收到消息，就会触发 ContentObserver 的 onChange()方法。</p>
<p>在 ContentProvider 中调用 ContentResolver 的 notifyChange()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数表示更改内容的 Uri 对象 ， 第二个参数表示指定某个观察者接收消息</span></span><br><span class="line">getContext().getContentResolver().notifyChange(PersonDao.messageuri, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>注册内容观察者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver(); </span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.example.mycontentprovider/person&quot;</span>) ; </span><br><span class="line">resolver.registerContentObserver(uri, <span class="keyword">true</span>, <span class="keyword">new</span> MyObserver(<span class="keyword">new</span> Handler()));</span><br></pre></td></tr></table></figure>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h5 id="HTTP-协议简介"><a href="#HTTP-协议简介" class="headerlink" title="HTTP 协议简介"></a>HTTP 协议简介</h5><p>HTTP(Hyper Text Transfer Protocol)即超文本传输协议，是一种请求／响应式的协议。</p>
<h5 id="访问网络"><a href="#访问网络" class="headerlink" title="访问网络"></a>访问网络</h5><p>GET 方式提交数据：向服务器提交的参数跟在请求 URL 后面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将用户名和密码拼在指定资源路径后面， 并对用户名和密码进行编码</span></span><br><span class="line">String path = <span class="string">&quot;http://192.168.1.100:8080/web/LoginServlet?username=&quot;</span> + URLEncoder.encode(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;&amp;password=&quot;</span> + URLEncoder.encode(<span class="string">&quot;123&quot;</span>); </span><br><span class="line">URL url = <span class="keyword">new</span> URL(path);	<span class="comment">// 创建 URL 对象</span></span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection(); </span><br><span class="line">conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);	<span class="comment">// 设置请求方式</span></span><br><span class="line">conn.setConnectTimeout(<span class="number">5000</span>);	<span class="comment">// 设置超时时间</span></span><br><span class="line"><span class="keyword">int</span> responseCode = conn.getResponseCode();	<span class="comment">// 获取状态码</span></span><br><span class="line"><span class="keyword">if</span> (responseCode == <span class="number">200</span>) &#123;	<span class="comment">// 访问成功</span></span><br><span class="line">	InputStream is = conn.getInputStream ();	<span class="comment">//获取服务器返回的输入流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST 方式提交数据：向服务器提交的参数在请求实体中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String path = <span class="string">&quot;http://192.168.1.l00:8080/web/LoginServlet&quot;</span>; </span><br><span class="line">URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">conn.setConnectTimeout(<span class="number">5000</span>);	<span class="comment">// 设置超时时间</span></span><br><span class="line">conn.setRequestMethod(<span class="string">&quot;POST&quot;</span>);	<span class="comment">// 设置请求方式</span></span><br><span class="line"><span class="comment">// 准备数据并给参数进行编码</span></span><br><span class="line">String data = <span class="string">&quot;username=&quot;</span> + URLEncoder.encode(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;&amp;password=&quot;</span> + URLEncoder.encode (<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="comment">// 设置请求头数据提交方式，这里是以 form 表单的方式提交</span></span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;applicationlx-www-form-urlencoded&quot;</span>);</span><br><span class="line"><span class="comment">// 设置请求头，设置提交数据的长度</span></span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Content-Length&quot;</span>, data.length() + <span class="string">&quot;&quot;</span>); </span><br><span class="line"><span class="comment">// post 方式，实际上是浏览器把数据写给了服务器</span></span><br><span class="line">conn.setDoOutput(<span class="keyword">true</span>); 	<span class="comment">// 设置允许向外写数据</span></span><br><span class="line">OutputStream os = conn.getOutputStream();	<span class="comment">// 利用输出流往服务器写数据</span></span><br><span class="line">os.write(data.getBytes());	<span class="comment">// 将数据写给服务器</span></span><br><span class="line"><span class="keyword">int</span> code = conn.getResponseCode();	<span class="comment">// 获取状态码</span></span><br><span class="line"><span class="keyword">if</span> ( code == <span class="number">200</span>) &#123;	<span class="comment">// 请求成功</span></span><br><span class="line">	InputStream is = conn.getInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Handler 消息机制：首先在 UI 主线程创建一个 Handler 对象，然后在子线程中调用 Hanlder 的 sendMessage()方法，这个消息会存放在 UI 线程的 MessageQueue 中，通过 Looper 对象取出 MessageQueue 中的消息，最后分发给 Hanlder 的 handleMessage()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程中创建 Handler 对象时，系统已经默认存在一个 Looper 对象</span></span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">        <span class="comment">// what 字段携带一些整型数据</span></span><br><span class="line">		msg.what = CHANGE_UI;</span><br><span class="line">        <span class="comment">// obj 字段携带一个 Object 对象</span></span><br><span class="line">		msg.obj = bitmap;</span><br><span class="line">		handler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>
<h5 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h5><p>AsyncHttpClient</p>
<p>SmartImageView</p>
<h3 id="高级编程"><a href="#高级编程" class="headerlink" title="高级编程"></a>高级编程</h3><h5 id="图形图像处理"><a href="#图形图像处理" class="headerlink" title="图形图像处理"></a>图形图像处理</h5><p>Bitmap 类：图像处理</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>createBitmap(int width, int height, Config config)</td>
<td>创建位图，width 代表要创建的图片的宽度，height 代表高度，Config 是 Bitmap 的内部类，用于指定 Bitmap 的配置信息</td>
</tr>
<tr>
<td>createBitmap(int colors[], int offset, int stride, int width, int height, Config config)</td>
<td>使用颜色数组创建以个指定宽高的位图，颜色数组的个数为 width x height</td>
</tr>
<tr>
<td>createBitmap(Bitmap src)</td>
<td>使用源位图创建一个新的 Bitmap</td>
</tr>
<tr>
<td>createBitmap(Bitmap source, int x, int y, int width, int height)</td>
<td>从源位图的指定坐标开始 “挖取” 指定宽高的一块图像来创建新的 Bitmap 对象</td>
</tr>
<tr>
<td>createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter)</td>
<td>从源位图的指定坐标开始 “挖取” 指定宽高的一块图像来创建新的 Bitmap 对象， 并按照 Matrix 规则进行变换</td>
</tr>
<tr>
<td>isRecycled()</td>
<td>判断 Bitmap 对象是否被回收</td>
</tr>
<tr>
<td>recycle()</td>
<td>回收 Bitmap 对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bitmap.Config config = Config.ARGB_4444; </span><br><span class="line">Bitmap bitmap = Bitmap.createBitmap (width, height, config);</span><br></pre></td></tr></table></figure>
<p>BitmapFactory 类：用于从数据源来解析、创建 Bitmap 对象</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>decodeFile(String pathName)</td>
<td>从指定文件中解析、创建 Bitmap 对象</td>
</tr>
<tr>
<td>decodeStream(InputStream is)</td>
<td>从指定输入流中解析、创建 Bitmap 对象</td>
</tr>
<tr>
<td>decodeResource(Resources res, int id)</td>
<td>根据给定的资源 id，从指定资源中解析、创建 Bitmap 对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);</span><br></pre></td></tr></table></figure>
<p>Paint 类：描述图形的颜色和风格</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>Paint()</td>
<td>创建一个 Paint 对象，并使用默认属性</td>
</tr>
<tr>
<td>Paint(int flags)</td>
<td>创建一个 Paint 对象，并使用指定属性</td>
</tr>
<tr>
<td>setARGB(int a, int r, int g, int b)</td>
<td>设置颜色，各参数值均为 0-255 之间的整数，几个参数分别用于表示透明度、红色、绿色和蓝色的值</td>
</tr>
<tr>
<td>setColor(int color)</td>
<td>设置颜色</td>
</tr>
<tr>
<td>setAlpha(int a)</td>
<td>设置透明度</td>
</tr>
<tr>
<td>setAntiAlias(boolean aa)</td>
<td>指定是否使用抗锯齿功能，如果使用会使绘图速度变慢</td>
</tr>
<tr>
<td>setDither(boolean dither)</td>
<td>指定是否使用图像抖动处理，如果使用会使图像颜色更加平滑、饱满、清晰</td>
</tr>
<tr>
<td>setShadowLayer(float radius, float dx, float dy, int color)</td>
<td>设置阴影，参数 radius 为阴影的角度；dx 和 dy 为阴影在 x 轴和 y 轴上的距离，color 为阴影的颜色</td>
</tr>
<tr>
<td>setTextAlign(Align align)</td>
<td>设置绘制文本时的文字对齐方式， 参数值为 Align.CENTER、Align.LEFT 或 Align.RIGHT</td>
</tr>
<tr>
<td>setTextSize(float textSize)</td>
<td>设置绘制文本时的文字大小</td>
</tr>
<tr>
<td>setFakeBoldText(boolean fakeBoldT ext)</td>
<td>设置绘制文字时是否为粗体文字</td>
</tr>
<tr>
<td>setXfermode(Xfermode xfermode)</td>
<td>设置图形重叠时的处理方式，如合并、取交集或并集，经常用来制作橡皮的擦除效果</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint(); </span><br><span class="line">paint.setColor(Color.RED);</span><br></pre></td></tr></table></figure>
<p>Canvas 类：绘制图形</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>drawRect(Rect r, Paint paint)</td>
<td>使用画笔画出指定矩形</td>
</tr>
<tr>
<td>drawOval(RectF oval, Paint paint)</td>
<td>使用画笔画出指定椭圆</td>
</tr>
<tr>
<td>drawCircle(float ex, float cy, float radius, Paint paint)</td>
<td>使用画笔在指定位置画出指定半径的圆</td>
</tr>
<tr>
<td>drawline(float startX, float startY, float stopX, float stopY, Paint paint)</td>
<td>使用画笔在指定位置画线</td>
</tr>
<tr>
<td>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</td>
<td>使用画笔绘制指定圆角矩形，其中 rx 表示 x 轴圆角半径，ry 表示 y 轴圆角半径</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Canvas 类在创建时需要继承自 View 类，并且在该类中重写 onDraw() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onDraw(canvas); </span><br><span class="line">	Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">	paint.setColor(Color.RED); </span><br><span class="line">	Rect r = <span class="keyword">new</span> Rect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">	canvas.drawRect(r, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Matrix 类：给图片添加特效</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>Matrix()</td>
<td>创建一个唯一的 Matrix 对象</td>
</tr>
<tr>
<td>setRotate(float degrees)</td>
<td>将 Matrix 对象围绕 (0, 0) 旋转 degrees 度</td>
</tr>
<tr>
<td>setRotate(float degrees, float px, float py)</td>
<td>将 Matrix 对象图绕指定位置 (px, py) 旋转 degrees 度</td>
</tr>
<tr>
<td>setScale(float sx, float sy)</td>
<td>对 Matrix 对象进行缩放， 参数 sx 代表 x 轴上的缩放比例 ，sy 代表 y 轴上的缩放比例</td>
</tr>
<tr>
<td>setScale(float sx, float sy, float px, float py)</td>
<td>让 Matrix 对象以 (px, py) 为轴心，在 x 轴上缩放 sx, 在 y轴上缩放 sy</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">matrix.setRotate(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<h5 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h5><p>补间动画：通过对 View 中的内容进行一系列的图形变换来实现动画效果。以 XML 形式定义的动画放置在 <code>res/anim</code></p>
<ul>
<li><p>透明度渐变动画 (AlphaAnimation)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span> </span><br><span class="line">	&lt;alpha</span><br><span class="line">	android:interpolator=&quot;@android:anim/linear_interpolator&quot; </span><br><span class="line">	android:repeatMode=&quot;reverse&quot;</span><br><span class="line">	android:repeatCount=&quot;infinite&quot; </span><br><span class="line">	android:duration=&quot;lOOO&quot; </span><br><span class="line">	android:fromAlpha=&quot;l.0&quot; </span><br><span class="line">	android:toAlpha=&quot;0.0&quot;/&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>interpolator: 控制动画的变化速度，值为 <code>＠android:anim/linear_interpolator</code> 匀速改变、<code>＠android:anim/accelerate_interpolator</code> 开始慢，后来加速</li>
<li>repeatMode: 指定动画重复的方式，值为 reverse 反向、restart 重新开始</li>
<li>repeatCount: 指定动画重复次数，可以为正整数，为 infinite 无限循环</li>
<li>duration: 指定动画播放时长，单位 ms</li>
<li>fromAlpha: 指定动画开始时的透明度，0.0 为完全透明， 1.0 为不透明</li>
<li>toAlpha: 指定动画结束时的透明度</li>
</ul>
</li>
<li><p>旋转动画 (RotateAnimation)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;l.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">	&lt;rotate</span><br><span class="line">		android:fromDegrees=&quot;O&quot; </span><br><span class="line">		android:toDegrees= &quot;360&quot; </span><br><span class="line">		android:pivotX=&quot;50%&quot;</span><br><span class="line">		android:pivotY=&quot;50%&quot;</span><br><span class="line">		android:repeatMode=&quot;reverse&quot; </span><br><span class="line">		android:repeatCount=&quot;infinite&quot; </span><br><span class="line">		android:duration=&quot;l000&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>fromDegrees: 指定动画开始时的角度</li>
<li>toDegrees: 指定动画结束时的角度</li>
<li>pivotX: 指定轴心的 x 坐标</li>
<li>pivotY: 指定轴心的 y 坐标</li>
</ul>
</li>
<li><p>缩放动画 (ScaleAnimation)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;l.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">	&lt;scale</span><br><span class="line">		android:repeatMode=&quot;reverse&quot; </span><br><span class="line">		android:repeatCount=&quot;infinite&quot;</span><br><span class="line">		android:duration=&quot;3000&quot; </span><br><span class="line">		android:fromXScale=&quot;1.0&quot; </span><br><span class="line">		android:fromYScale=&quot;1.0&quot; </span><br><span class="line">		android:toXScale=&quot;0.5&quot; </span><br><span class="line">		android:toYScale=&quot;0.5&quot; </span><br><span class="line">		android:pivotX=&quot;50%&quot;</span><br><span class="line">		android:pivotY=&quot;50%&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>fromXScale: 指定动画开始时 x 轴上的缩放系数，值为 1.0 表示不变化</li>
<li>fromYScale: 指定动画开始时 y 轴上的缩放系数</li>
<li>toXScale： 指定动画结束时 x 轴上的缩放系数</li>
<li>toYScale: 指定动画结束时 y 轴上的缩放系数</li>
</ul>
</li>
<li><p>平移动画 (TranslateAnimation)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;l.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">translate</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:fromXDelta</span>=<span class="string">&quot;0.0&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:fromYDelta</span>=<span class="string">&quot;0.0&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:toXDelta</span>=<span class="string">&quot;lOO&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:toYDelta</span>=<span class="string">&quot;0.0&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:repeatCount</span>=<span class="string">&quot;infinite&quot;</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:repeatMode</span>=<span class="string">&quot;reverse&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:duration</span>=<span class="string">&quot;4000&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>fromXDelta: 指定动画开始时 View 的 x 轴坐标，这里的坐标是相对于 View 的所在位置的坐标，0.0 表示在 View 最开始的地方</li>
<li>fromYDelta: 指定动画开始时 View 的 y 轴坐标</li>
<li>toXDelta: 指定动画结束时 View 的 x 轴坐标</li>
<li>toYDelta: 指定动画结束时 View 的 y 轴坐标</li>
</ul>
</li>
<li><p>在代码中定义 4 种补间动画时，需要用到 AlphaAnimation、ScaleAnimation、TranslateAnimation 和 RotateAnimation 类</p>
</li>
</ul>
<p>逐帧动画：一张一张地播放事先准备好的静态图像。在 <code>res/drawable</code> 目录下创建逐帧动画的 XML 文件并在 <code>&lt;animation-list&gt;</code> 节点的 <code>&lt;item&gt;</code> 子节点中指定图片出现的顺序以及每帧的持续时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/img0l&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/img02&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/img03&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/img04&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/img05&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/img06&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在代码中定义逐帧动画需要用到 AnimationDrawable 中的 addFrame() 方法来添加图片</p>
<h5 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h5>]]></content>
      <tags>
        <tag>Unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/27/01HTML-I/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>HTML 语言是互联网开发的基础。</p>
<h2 id="HTML-语言简介"><a href="#HTML-语言简介" class="headerlink" title="HTML 语言简介"></a>HTML 语言简介</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTML 是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载 HTML 代码，然后渲染出网页。</p>
<p>HTML 的全名是“超文本标记语言”（HyperText Markup Language），上个世纪90年代由欧洲核子研究中心的物理学家蒂姆·伯纳斯-李（Tim Berners-Lee）发明。它的最大特点就是支持超链接，点击链接就可以跳转到其他网页，从而构成了整个互联网。</p>
<p>1999年，HTML 4.01 版发布，成为广泛接受的 HTML 标准。2014年，HTML 5 发布，这是目前正在使用的版本。</p>
<p>浏览器的网页开发，涉及三种技术：HTML、CSS 和 JavaScript。HTML 语言定义网页的结构和内容，CSS 样式表定义网页的样式，JavaScript 语言定义网页与用户的互动行为。HTML 语言是网页开发的基础，CSS 和 JavaScript 都是基于 HTML 才能生效，即使没有这两者，HTML 本身也能使用，可以完成基本的内容展示。</p>
<p>下面就是一个简单网页的 HTML 源码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码，可以保存成文件<code>hello.html</code>。浏览器打开这个本地文件，就能看到文字“Hello World”。</p>
<p>浏览器右键菜单的“查看源码”（View page source），可以展示当前网页的 HTML 源码。</p>
<h3 id="网页的基本概念"><a href="#网页的基本概念" class="headerlink" title="网页的基本概念"></a>网页的基本概念</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>网页的 HTML 代码由许许多多不同的标签（tag）构成。学习 HTML 语言，就是学习各种标签的用法。</p>
<p>下面就是标签的一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>就是一对标签。</p>
<p>标签用来告诉浏览器，如何处理这段代码。标签的内容就是浏览器所要渲染的、展示在网页上的内容。</p>
<p>标签放在一对尖括号里面（比如<code>&lt;title&gt;</code>），大多数标签都是成对出现的，分成开始标签和结束标签，结束标签在标签名之前加斜杠（比如<code>&lt;/title&gt;</code>）。但是，也有一些标签不是成对使用，而是只有开始标签，没有结束标签，比如上一节示例的<code>&lt;meta&gt;</code>标签。成对出现叫双边标签；单个出现的叫单边标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;meta&gt;</code>标签就没有结束标签<code>&lt;/meta&gt;</code>。</p>
<p>这种单独使用的标签，通常是因为标签本身就足够完成功能了，不需要标签之间的内容。实际应用中，它们主要用来提示浏览器，做一些特别处理。</p>
<p>标签可以嵌套。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;div&gt;</code>标签内部包含了一个<code>&lt;p&gt;</code>标签。</p>
<p>嵌套时，必须保证正确的闭合顺序，不能跨层嵌套，否则会出现意想不到的渲染结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码就是错误的嵌套，闭合顺序不正确。</p>
<p>HTML 标签名是大小写不敏感，比如<code>&lt;title&gt;</code>和<code>&lt;TITLE&gt;</code>是同一个标签。不过，一般习惯都是使用小写。</p>
<p>另外，HTML 语言忽略缩进和换行。下面几种写法的渲染结果是一样的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">  网页标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页</span><br><span class="line">标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进一步说，整个网页的 HTML 代码完全可以写成一行，浏览器照样解析，结果完全一样。所以，正式发布网页之前，开发者有时会把源码压缩成一行，以减少传输的字节数。</p>
<p>各种网页的样式效果，比如内容的缩进和换行，主要靠 CSS 来实现。</p>
<h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><p>浏览器渲染网页时，会把 HTML 源码解析成一个标签树，每个标签都是树的一个节点（node）。这种节点就称为网页元素（element）。所以，“标签”和“元素”基本上是同义词，只是使用的场合不一样：标签是从源码角度来看，元素是从编程角度来看，比如<code>&lt;p&gt;</code>标签对应网页的<code>p</code>元素。</p>
<p>嵌套的标签就构成了网页元素的层级关系。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>div</code>元素内部包含了一个<code>p</code>元素。上层元素又称为“父元素”，下层元素又称为“子元素”，即<code>div</code>是<code>p</code>的父元素，<code>p</code>是<code>div</code>的子元素。</p>
<h4 id="块级元素，行内元素"><a href="#块级元素，行内元素" class="headerlink" title="块级元素，行内元素"></a>块级元素，行内元素</h4><p>所有元素可以分成两大类：块级元素（block）和行内元素（inline）。</p>
<p>块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据 100% 的宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素是块级元素，因此浏览器会将内容分成两行显示。</p>
<p>行内元素默认与其他元素在同一行，不产生换行。比如，<code>span</code>就是行内元素，通常用来为某些文字指定特别的样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>span</code>元素是行内元素，因此浏览器会将两行内容放在一行显示。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性（attribute）是标签的额外信息，使用空格与标签名和其他属性分隔。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;demo.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;img&gt;</code>标签有两个属性：<code>src</code>和<code>width</code>。</p>
<p>属性可以用等号指定属性值，比如上例的<code>demo.jpg</code>就是<code>src</code>的属性值。属性值一般放在双引号里面，这不是必需的，但推荐总是使用双引号。</p>
<p>注意，属性名是大小写不敏感的，<code>onclick</code>和<code>onClick</code>是同一个属性。</p>
<p>HTML 提供大量属性，用来定制标签的行为。</p>
<h3 id="网页的基本标签"><a href="#网页的基本标签" class="headerlink" title="网页的基本标签"></a>网页的基本标签</h3><p>符合 HTML 语法标准的网页，应该满足下面的基本结构。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不管多么复杂的网页，都是从上面这个基本结构衍生出来的。</p>
<p>前面说过，HTML 代码的缩进和换行，对于浏览器不产生作用。所以，上面的代码完全可以写成一行，渲染结果不变。上面这样分行写，只是为了提高可读性。</p>
<p>下面就依次介绍，这个基本结构的主要标签。它们构成了网页的骨架。</p>
<h4 id="lt-doctype-gt"><a href="#lt-doctype-gt" class="headerlink" title="&lt;!doctype&gt;"></a><code>&lt;!doctype&gt;</code></h4><p>网页的第一个标签通常是<code>&lt;!doctype&gt;</code>，即文档声明头（DocType Declaration），简称DTD。表示文档类型，告诉浏览器如何解析网页。</p>
<p>一般来说，只要像下面这样，简单声明<code>doctype</code>为<code>html</code>即可。浏览器就会按照 HTML 5 的规则处理网页。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时，该标签采用完全大写的形式，以便区别于正常的 HTML 标签。因为<code>&lt;!doctype&gt;</code>本质上不是标签，更像一个处理指令。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果在 HTML 文档的开始部分没有使用 doctype ，浏览器在渲染文档时，切换到我们称为“<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9RdWlya3NfTW9kZV9hbmRfU3RhbmRhcmRzX01vZGU=">怪异模式(兼容模式)<i class="fa fa-external-link-alt"></i></span>”的渲染模式。</p>
<h4 id="lt-html-gt"><a href="#lt-html-gt" class="headerlink" title="&lt;html&gt;"></a><code>&lt;html&gt;</code></h4><p><code>&lt;html&gt;</code>标签是网页的顶层容器，即标签树结构的顶层节点，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个<code>&lt;html&gt;</code>标签。</p>
<p>该标签的<code>lang</code>属性，表示网页内容默认的语言。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，网页是中文内容。如果是英文内容，<code>zh-CN</code>要改成<code>en</code>。</p>
<h4 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt;head&gt;"></a><code>&lt;head&gt;</code></h4><p><code>&lt;head&gt;</code>标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染提供额外信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;head&gt;</code>是<code>&lt;html&gt;</code>的第一个子元素。如果网页不包含<code>&lt;head&gt;</code>，浏览器会自动创建一个。</p>
<p><code>&lt;head&gt;</code>的子元素一般有下面七个。</p>
<ul>
<li><code>&lt;meta&gt;</code>：设置网页的元数据。</li>
<li><code>&lt;link&gt;</code>：连接外部样式表。</li>
<li><code>&lt;title&gt;</code>：设置网页标题。</li>
<li><code>&lt;style&gt;</code>：放置内嵌的样式表。</li>
<li><code>&lt;script&gt;</code>：引入脚本。</li>
<li><code>&lt;noscript&gt;</code>：浏览器不支持脚本时，所要显示的内容。</li>
<li><code>&lt;base&gt;</code>：设置网页内部相对 URL 的计算基准。</li>
</ul>
<h4 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h4><p><code>&lt;meta&gt;</code>标签用于设置或说明网页的元数据，必须放在<code>&lt;head&gt;</code>里面。一个<code>&lt;meta&gt;</code>标签就是一项元数据，网页可以有多个<code>&lt;meta&gt;</code>。<code>&lt;meta&gt;</code>标签约定放在<code>&lt;head&gt;</code>内容的最前面。</p>
<p>不管什么样的网页，一般都可以放置以下两个<code>&lt;meta&gt;</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，第一个<code>&lt;meta&gt;</code>标签表示网页采用 UTF-8 格式编码，第二个<code>&lt;meta&gt;</code>标签表示网页在手机端可以自动缩放。</p>
<p><code>&lt;meta&gt;</code>标签有五个属性，下面依次介绍。</p>
<p><strong>（1）charset 属性</strong></p>
<p><code>&lt;meta&gt;</code>标签的<code>charset</code>属性，用来指定网页的编码方式。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码声明，网页为 UTF-8 编码。虽然开发者可以使用其他的编码方式，但正确的做法几乎总是应该采用 UTF-8。</p>
<p>注意，这里声明的编码方式，应该与网页实际的编码方式一致，即声明了<code>utf-8</code>，网页就应该使用 UTF-8 编码保存。如果这里声明了<code>utf-8</code>，实际却是使用另一种编码（比如 GB2312），并不会导致浏览器的自动转码，网页可能会显示为乱码。</p>
<p>有如下字符集：</p>
<ul>
<li>ASCII码：用1个字节来表示一个字符。共可以表示2<sup>8</sup>=256个字符。</li>
<li>ANSI编码：每个国家为了显示本国的语言，都对ASCII码进行了扩展。用2个字节来表示一个汉字。<ul>
<li>中国的ANSI编码是GB2312编码（简体），对6763汉字进行编码，含600多特殊字符。</li>
<li>台湾的ANSI编码是BIG5编码（繁体）</li>
</ul>
</li>
<li>GBK（简体）：对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。</li>
<li>Unicode编码(统一编码)：用4个字节来表示一个字符。</li>
<li>UTF-8(Unicode Transform Format)编码：根据字符的不同，选择其编码的长度。一个字符A用1个字节表示，一个汉字用2个字节表示。</li>
</ul>
<p><strong>（2）name 属性，content 属性</strong></p>
<p><code>&lt;meta&gt;</code>标签的<code>name</code>属性表示元数据的名字，<code>content</code>属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML 语言入门&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML,教程&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;张三&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码包含了三个元数据：<code>description</code>是网页内容的描述，<code>keywords</code>是网页内容的关键字，<code>author</code>是网页作者。</p>
<p>元数据有很多种，大部分涉及浏览器内部工作机制，或者特定的使用场景。下面是一些例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--viewport代表的是浏览器中网站可见内容的部分。视口外的内容在被滚动进来前都是不可见的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;application-name&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Application Name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;program&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your document&#x27;s subject&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）http-equiv 属性，content 属性</strong></p>
<p><code>&lt;meta&gt;</code>标签的<code>http-equiv</code>属性用来覆盖 HTTP 回应的头信息字段，<code>content</code>属性是对应的字段内容。这两个属性与 HTTP 协议相关。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以覆盖 HTTP 回应的<code>Content-Security-Policy</code>字段。</p>
<p>下面是另一些例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Type=text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30;URL=&#x27;http://website.com&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码 <code>http-equiv=&quot;refresh&quot;</code> 的 content 只包含一个正整数，则为重新载入页面的时间间隔(秒)；如果 content 包含一个正整数，并且后面跟着字符串 ‘;url=’ 和一个合法的 URL，则是重定向到指定链接的时间间隔(秒)。</p>
<h4 id="lt-title-gt"><a href="#lt-title-gt" class="headerlink" title="&lt;title&gt;"></a><code>&lt;title&gt;</code></h4><p><code>&lt;title&gt;</code>标签用于指定网页的标题，会显示在浏览器窗口的标题栏。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>搜索引擎根据这个标签，显示每个网页的标题。它对于网页在搜索引擎的排序，有很大的影响，应该精心安排，反映网页的主题。</p>
<p><code>&lt;title&gt;</code>标签的内部，不能再放置其他标签，只能放置无格式的纯文本。</p>
<h4 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h4><p><code>&lt;body&gt;</code>标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都放置在它的内部。它是<code>&lt;html&gt;</code>的第二个子元素，紧跟在<code>&lt;head&gt;</code>后面。每一个 HTML 页面都含有 <code>body</code> 元素，不论写不写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="空格和换行"><a href="#空格和换行" class="headerlink" title="空格和换行"></a>空格和换行</h3><p>HTML 语言有自己的空格处理规则。标签内容的头部和尾部的空格，一律忽略不计。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>  hello world   <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>hello</code>前面的空格和<code>world</code>后面的空格，浏览器一律忽略不计。</p>
<p>标签内容里面的多个连续空格（包含制表符<code>\t</code>），会被浏览器合并成一个。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello      world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>hello</code>与<code>world</code>之间有多个连续空格，浏览器会将它们合并成一个。网页渲染的结果是，<code>hello</code>与<code>world</code>之间只有一个空格。</p>
<p>浏览器还会将文本里面的换行符（<code>\n</code>）和回车符（<code>\r</code>），替换成空格。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">world</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>hello</code>与<code>world</code>之间有多个换行，浏览器会将它们替换成空格，然后再将多个空格合并成一个。网页渲染的结果是，<code>hello</code>与<code>world</code>之间有一个空格。</p>
<p>这意味着，HTML 源码里面的换行，不会产生换行效果。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>HTML 代码可以包含注释，浏览器会自动忽略注释。注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，下面就是一个注释的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个注释 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>注释可以是多行的，并且内部的 HTML 都不再生效了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  &lt;p&gt;hello world&lt;/p&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个注释的区块，内部的代码都是无效的，浏览器不会解析，更不会渲染它们。</p>
<p>注释有助于理解代码的含义，复杂的代码块前面最好加上注释。</p>
<h2 id="URL-简介"><a href="#URL-简介" class="headerlink" title="URL 简介"></a>URL 简介</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>URL 是“统一资源定位符”（Uniform Resource Locator）的首字母缩写，中文译为“网址”，表示各种资源的互联网地址。下面就是一个典型的 URL。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://www.example.com/path/index.html</span><br></pre></td></tr></table></figure>
<p>所谓资源，可以简单理解成各种可以通过互联网访问的文件，比如网页、图像、音频、视频、JavaScript 脚本等等。只有知道了它们的 URL，才能在互联网上获取它们。</p>
<p>只要资源可以通过互联网访问，它就必然有对应的 URL。一个 URL 对应一个资源，但是同一个资源可能对应多个 URL。</p>
<p>URL 是互联网的基础。互联网之所以“互联”，就是因为网页可以通过“链接”（link），包含其他 URL。用户只要点击，就可以从一个 URL 跳转到另一个 URL，前往不同的网站。</p>
<h3 id="网址的组成部分"><a href="#网址的组成部分" class="headerlink" title="网址的组成部分"></a>网址的组成部分</h3><p>URL 由多个部分组成。下面是一个比较复杂的 URL，实际的 URL 通常不会有这么多部分。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#anchor</span><br></pre></td></tr></table></figure>
<p>我们看看，这个 URL 的各个部分。</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议（scheme）是浏览器请求服务器资源的方法，上例是<code>https://</code>的部分，表示使用 HTTPS 协议。</p>
<p>互联网支持多种协议，必须指明网址使用哪一种协议，默认是 HTTP 协议（2021年默认 HTTPS协议）。也就是说，如果省略协议，直接在浏览器地址栏输入<code>www.example.com</code>，那么浏览器默认会访问<code>http://www.example.com</code>。HTTPS 是 HTTP 的加密版本，出于安全考虑，越来越多的网站使用这个协议。</p>
<p>HTTP 和 HTTPS 的协议名称后面，紧跟着一个冒号和两个斜杠（<code>://</code>）。其他协议不一定如此，邮件地址协议<code>mailto:</code>的协议名后面只有一个冒号，比如<code>mailto:foo@example.com</code>。</p>
<h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><p>主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是<code>www.example.com</code>。</p>
<p>有些主机没有域名，只有 IP 地址，比如<code>192.168.2.15</code>。这种情况常常出现在局域网。</p>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。</p>
<p>端口紧跟在域名后面，两者之间使用冒号分隔，比如<code>www.example.com:80</code>。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径（path）是资源在网站的位置。比如，<code>/path/index.html</code>这个路径，指向网站的<code>/path</code>子目录下面的网页文件<code>index.html</code>。</p>
<p>互联网的早期，路径是真实存在的物理位置。现在由于服务器可以模拟这些位置，所以路径只是虚拟位置。</p>
<p>路径可能只包含目录，不包含文件名，比如<code>/foo/</code>，甚至结尾的斜杠都可以省略。这时，服务器通常会默认跳转到该目录里面的<code>index.html</code>文件（即等同于请求<code>/foo/index.html</code>），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问<code>www.example.com</code>这个网址，很可能返回的是网页文件<code>www.example.com/index.html</code>。</p>
<h4 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h4><p>查询参数（parameter）是提供给服务器的额外信息。参数的位置是在路径后面，两者之间使用<code>?</code>分隔，上例是<code>?key1=value1&amp;key2=value2</code>。</p>
<p>查询参数可以有一组或多组。每组参数都是键值对（key-value pair）的形式，同时具有键名(key)和键值(value)，它们之间使用等号（<code>=</code>）连接。比如，<code>key1=value</code>就是一个键值对，<code>key1</code>是键名，<code>value1</code>是键值。</p>
<p>多组参数之间使用<code>&amp;</code>连接，比如<code>key1=value1&amp;key2=value2</code>。</p>
<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>锚点（anchor）是网页内部的定位点，使用<code>#</code>加上锚点名称，放在网址的最后，比如<code>#anchor</code>。浏览器加载页面以后，会自动滚动到锚点所在的位置。</p>
<p>锚点名称通过网页元素的<code>id</code>属性命名。</p>
<h3 id="URL-字符"><a href="#URL-字符" class="headerlink" title="URL 字符"></a>URL 字符</h3><p>URL 的各个组成部分，只能使用以下这些字符。</p>
<ul>
<li>26个英语字母（包括大写和小写）</li>
<li>10个阿拉伯数字</li>
<li>连词号（<code>-</code>）</li>
<li>句点（<code>.</code>）</li>
<li>下划线（<code>_</code>）</li>
</ul>
<p>此外，还有18个字符属于 URL 的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（<code>?</code>），也就是说，问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。</p>
<p>URL 字符转义的方法是，在这些字符的十六进制 ASCII 码前面加上百分号（<code>%</code>）。下面是这18个字符及其转义形式。</p>
<ul>
<li><code>!</code>：%21</li>
<li><code>#</code>：%23</li>
<li><code>$</code>：%24</li>
<li><code>&amp;</code>：%26</li>
<li><code>&#39;</code>：%27</li>
<li><code>(</code>：%28</li>
<li><code>)</code>：%29</li>
<li><code>*</code>：%2A</li>
<li><code>+</code>：%2B</li>
<li><code>,</code>：%2C</li>
<li><code>/</code>：%2F</li>
<li><code>:</code>：%3A</li>
<li><code>;</code>：%3B</li>
<li><code>=</code>：%3D</li>
<li><code>?</code>：%3F</li>
<li><code>@</code>：%40</li>
<li><code>[</code>：%5B</li>
<li><code>]</code>：%5D</li>
</ul>
<p>举例来说，有一个网页的 URL 是<code>foo?bar.html</code>，即文件里面包含一个问号，那么需要写成<code>foo%3Fbar.html</code>。</p>
<p>URL 的合法字符，其实也可以采用这种转义方法，但是不建议使用。比如，字母<code>a</code>的十六进制 ASCII 码是<code>61</code>，转义形式后就是<code>%61</code>。因此，<code>www.apple.com</code>又可以写成<code>www.%61pple.com</code>，浏览器一样识别。</p>
<p>值得注意的是，空格的转义形式是<code>%20</code>。对于那些包含空格的文件名，这个转义是必须的。</p>
<p>既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如<code>www.example.com/中国.html</code>，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（<code>%</code>）。</p>
<p>举例来说，汉字<code>中</code>的 UTF-8 十六进制编码是<code>e4b8ad</code>，每两个字符一组，URL 转义后就为<code>%e4%b8%ad</code>。也就是说，URL 里面凡是有汉字<code>中</code>的地方，都要写成<code>%e4%b8%ad</code>。因此，访问<code>www.example.com/中国.html</code>这个网址，需要写成下面的样子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">www.example.com/%e4%b8%ad%e5%9b%bd.html</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>中</code>的转义形式是<code>%e4%b8%ad</code>，<code>国</code>是<code>%e5%9b%bd</code>。</p>
<h3 id="绝对-URL-和相对-URL"><a href="#绝对-URL-和相对-URL" class="headerlink" title="绝对 URL 和相对 URL"></a>绝对 URL 和相对 URL</h3><p>URL 分成两种：绝对 URL 和相对 URL。</p>
<p>绝对 URL 指的是，只靠 URL 本身就能确定资源的位置。这意味着，URL 必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对 URL。</p>
<p>相对 URL 指的是，URL 不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的 URL 是<code>https://www.example.com/path/index.html</code>，该网页上面有一个资源，URL 指向<code>a.html</code>，这个就是相对 URL。因为只知道<code>a.html</code>，并不能定位资源。浏览器假定，<code>a.html</code>与当前网址在同一个子目录下面，从而得到绝对 URL <code>https://www.example.com/path/a.html</code>。</p>
<p>相对 URL 如果以斜杠（<code>/</code>）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对 URL <code>/foo/bar.html</code>表示网站根目录的子目录<code>foo</code>，<code>foo/bar.html</code>表示在当前目录的<code>foo</code>子目录。</p>
<p>URL 还可以使用两个特殊简写，表示特定位置。</p>
<ul>
<li><code>.</code>：表示当前目录，比如<code>./a.html</code>（当前目录下的<code>a.html</code>文件）</li>
<li><code>..</code>：表示上级目录，比如<code>../a.html</code>（上级目录下的<code>a.html</code>文件）</li>
</ul>
<p>这两种简写可以多个连用，比如<code>../../</code>表示上两级目录。</p>
<p>绝对 URL 也可以使用这两个简写，比如<code>www.example.com/./index.html</code>等同于<code>www.example.com/index.html</code>，这时<code>.</code>相当于根目录的当前目录，即根目录本身。</p>
<h3 id="lt-base-gt"><a href="#lt-base-gt" class="headerlink" title="&lt;base&gt;"></a><code>&lt;base&gt;</code></h3><p><code>&lt;base&gt;</code>标签指定网页内部的所有相对 URL 的计算基准。整张网页只能有一个<code>&lt;base&gt;</code>标签，而且只能放在<code>&lt;head&gt;</code>里面。它是单独使用的标签，没有闭合标签，下面是一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/files/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;base&gt;</code>标签的<code>href</code>属性给出计算的基准网址，<code>target</code>属性给出如何打开链接的说明。已知计算基准是<code>https://www.example.com/files/</code>，那么相对 URL <code>foo.html</code>，就可以转成绝对 URL <code>https://www.example.com/files/foo.html</code>。</p>
<p>注意，<code>&lt;base&gt;</code>标签必须至少具有<code>href</code>属性或<code>target</code>属性之一。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://foo.com/app/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一旦设置了<code>&lt;base&gt;</code>，就对整个网页都有效。如果要改变某个链接的行为，只能用绝对链接替代相对链接。尤其需要注意锚点，这时锚点也是针对<code>&lt;base&gt;</code>计算的，而不是针对当前网页的 URL。</p>
<h2 id="网页元素的属性"><a href="#网页元素的属性" class="headerlink" title="网页元素的属性"></a>网页元素的属性</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。元素属性的写法是 HTML 标签内部的“键值对”。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;html&gt;</code>标签内部的键值对<code>lang=&quot;en&quot;</code>，就称为<code>html</code>元素的属性。属性名为<code>lang</code>，属性值为<code>en</code>。</p>
<p>属性名与标签名一样，不区分大小写，<code>lang</code>和<code>LANG</code>是同一个属性。</p>
<p>属性名与属性值之间，通过等号<code>=</code>连接。属性值可以放在单引号或双引号之中，建议统一使用双引号。某些属性值可以不使用引号，但是建议不要这样写。</p>
<p>有些属性是布尔属性，即属性值是一个布尔值，只有“打开”和“关闭”两种情况。这时属性值可以省略，只要添加了属性名，就表示打开该属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>required</code>就是<code>&lt;input&gt;</code>标签的布尔属性。如果加上这个属性，就表示打开，没有就是关闭。</p>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>全局属性（global attributes）是所有元素都可以使用的属性。也就是说，你可以把下面的属性，加在任意一个网页元素上面，不过有些属性对某些元素可能不产生意义。</p>
<p>下面是一些常见的全局属性。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>id</code>属性是元素在网页内的唯一标识符。比如，网页可能包含多个<code>&lt;p&gt;</code>标签，<code>id</code>属性可以指定每个<code>&lt;p&gt;</code>标签的唯一标识符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，三个<code>&lt;p&gt;</code>标签具有不同的<code>id</code>属性，因此可以区分。</p>
<p><code>id</code>属性的值必须是全局唯一的，同一个页面不能有两个相同的<code>id</code>属性。另外，<code>id</code>属性的值不得包含空格。</p>
<p><code>id</code>属性的值还可以在最前面加上<code>#</code>，放到 URL 中作为锚点，定位到该元素在网页内部的位置。比如，用户访问网址<code>https://foo.com/index.html#bar</code>的时候，浏览器会自动将页面滚动到<code>bar</code>的位置，让用户第一眼就看到这部分内容。</p>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p><code>class</code>属性用来对网页元素进行分类。如果不同元素的<code>class</code>属性值相同，就表示它们是一类的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;para&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;para&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个<code>&lt;p&gt;</code>和第三个<code>&lt;p&gt;</code>是一类，因为它们的<code>class</code>属性相同。</p>
<p>元素可以同时具有多个 class，它们之间使用空格分隔。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1 p2 p3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>p</code>元素同时具有<code>p1</code>、<code>p2</code>、<code>p3</code>三个 class。</p>
<h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p><code>title</code>属性用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将<code>title</code>属性值作为浮动提示，显示出来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;版权说明&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>本站内容使用创意共享许可证，可以自由使用。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>title</code>属性解释了这一块内容的目的。鼠标悬停在上面时，浏览器会显示一个浮动提示。一旦鼠标移开，提示就会消失。</p>
<h4 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h4><p>网页通常使用鼠标操作，但是某些情况下，用户可能希望使用键盘，或者只有键盘可以用。因此，浏览器允许使用 Tab 键，遍历网页元素。也就是说，只要不停按下 Tab 键，网页的焦点就会从一个元素转移到另一个元素，选定焦点元素以后，就可以进行下一步操作，比如按下回车键访问某个链接，或者直接在某个输入框输入文字。</p>
<p>这里就有一个问题，按下 Tab 键的时候，浏览器怎么知道跳到哪一个元素。HTML 提供了<code>tabindex</code>属性，解决这个问题。它的名字的含义，就是 Tab 的顺序（index）。</p>
<p><code>tabindex</code>属性的值是一个整数，表示用户按下 Tab 键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。</p>
<ul>
<li>负整数：该元素可以获得焦点（比如使用 JavaScript 的<code>focus()</code>方法），但不参与 Tab 键对网页元素的遍历。这个值通常是<code>-1</code>。</li>
<li><code>0</code>：该元素参与 Tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。</li>
<li>正整数：网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。如果多个元素的<code>tabindex</code>属性相同，则按照在网页源码里面出现的顺序遍历。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">tabindex</span>=<span class="string">&quot;0&quot;</span>&gt;</span>这段文字可以获得焦点。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;p&gt;</code>标签的<code>tabindex</code>为<code>0</code>，意味着该元素可以获得焦点，并且也可以被 Tab 键遍历，顺序由其在源码里面的位置决定。</p>
<p>一般来说，<code>tabindex</code>属性最好都设成<code>0</code>，按照自然顺序进行遍历，这样比较符合用户的预期，除非网页有特殊布局。如果网页所有元素都没有设置<code>tabindex</code>，那么只有那些默认可以遍历的元素（比如链接、输入框等）才能参与 Tab 键的遍历，顺序由其在源码的位置决定。因此实际上，只有那些无法获得焦点的元素（比如<code>&lt;span&gt;</code>、<code>&lt;div&gt;</code>）需要参与遍历，才有必要设置<code>tabindex</code>属性。</p>
<h4 id="accesskey"><a href="#accesskey" class="headerlink" title="accesskey"></a>accesskey</h4><p><code>accesskey</code>属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">accesskey</span>=<span class="string">&quot;s&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;button&gt;</code>的快捷键是<code>s</code>，按下快捷键，该元素就得到了焦点。</p>
<p><code>accesskey</code>属性的字符键，必须配合功能键，一起按下才会生效。也就是说，快捷键是“功能键 + 字符键”的组合。不同的浏览器与不同的操作系统，功能键都不一样。比如，Chrome 浏览器在 Windows 系统和 Linux 系统的快捷键是<code>Alt + 字符键</code>，在 Mac 系统的快捷键是<code>Ctrl + Alt + 字符键</code>。</p>
<p>注意，<code>accesskey</code>如果跟操作系统或浏览器级别的快捷键有冲突，这时不会生效。</p>
<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p><code>style</code>属性用来指定当前元素的 CSS 样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定文字颜色为红色。</p>
<h4 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h4><p><code>hidden</code>是一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">hidden</span>&gt;</span>本句不会显示在页面上。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，这个<code>p</code>元素不会出现在网页上。</p>
<p>注意，CSS 的可见性设置，高于<code>hidden</code>属性。如果 CSS 设为该元素可见，<code>hidden</code>属性将无效。</p>
<h4 id="lang，dir"><a href="#lang，dir" class="headerlink" title="lang，dir"></a>lang，dir</h4><p><code>lang</code>属性指定网页元素使用的语言。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个<code>&lt;p&gt;</code>的<code>lang</code>属性，表示使用英语，第二个<code>&lt;p&gt;</code>的<code>lang</code>属性，表示使用中文。</p>
<p><code>lang</code>属性的值，必须符合 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL2JjcC9iY3A0Ny50eHQ=">BCP47<i class="fa fa-external-link-alt"></i></span> 的标准。下面是一些常见的语言代码。</p>
<ul>
<li>zh：中文</li>
<li>zh-Hans：简体中文</li>
<li>zh-Hant：繁体中文</li>
<li>en：英语</li>
<li>en-US：美国英语</li>
<li>en-GB：英国英语</li>
<li>es：西班牙语</li>
<li>fr：法语</li>
</ul>
<p><code>dir</code>属性表示文字的阅读方向，有三个可能的值。</p>
<ul>
<li><code>ltr</code>：从左到右阅读，比如英语。</li>
<li><code>rtl</code>：从右到左阅读，阿拉伯语、波斯语、希伯来语都属于这一类。</li>
<li><code>auto</code>：浏览器根据内容的解析结果，自行决定。</li>
</ul>
<h4 id="contenteditable"><a href="#contenteditable" class="headerlink" title="contenteditable"></a>contenteditable</h4><p>HTML 网页的内容默认是用户不能编辑，<code>contenteditable</code>属性允许用户修改内容。它有两个可能的值。</p>
<ul>
<li><code>true</code>或空字符串：内容可以编辑</li>
<li><code>false</code>：不可以编辑</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">鼠标点击，本句内容可修改。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，鼠标单击句子，就可以进入编辑状态，用户可以改变句子的内容。当然，除非提交到服务器，否则刷新页面还是显示原来的内容。</p>
<p>该属性是枚举属性，不是布尔属性，规范的写法是最好带上属性值。</p>
<h4 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a>spellcheck</h4><p>浏览器一般会自带拼写检查功能，编辑内容时，拼错的单词下面会显示红色的波浪线。<code>spellcheck</code>属性就表示，是否打开拼写检查。</p>
<p>它有两个可能的值。</p>
<ul>
<li><code>true</code>：打开拼写检查</li>
<li><code>false</code>：关闭拼写检查</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">spellcheck</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">英语单词 separate 容易写错成 seperate。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>seperate</code>下面会有提示，表示拼错了。</p>
<p>注意，由于该属性只在编辑时生效，所以这个例子必须加上<code>contenteditable</code>属性，表示本段内容可编辑。鼠标单击就可以进入编辑状态，这时才会看到拼写提示。不可编辑的状态下，拼写错误是不提示显示的。对于那些不可编辑的元素，该属性无效。</p>
<p>这个属性看上去像布尔属性，但是其实是枚举属性，所以最好不要省略它的值。如果没有指定这个属性，浏览器将自行决定是否打开拼写检查。</p>
<h4 id="data-属性"><a href="#data-属性" class="headerlink" title="data-属性"></a><code>data-</code>属性</h4><p><code>data-</code>属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在<code>data-</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">data-tip</span>=<span class="string">&quot;this is the tip!&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>data-tip</code>用于放置链接的提示文字。</p>
<p><code>data-</code>属性只能通过 CSS 或 JavaScript 利用。下面是 CSS 的例子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;div data-role=&quot;mobile&quot;&gt;</span></span><br><span class="line"><span class="comment">Mobile only content</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[data-role=<span class="string">&quot;mobile&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;div class=&quot;test&quot; data-content=&quot;This is the div content&quot;&gt;test&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事件处理属性"><a href="#事件处理属性" class="headerlink" title="事件处理属性"></a>事件处理属性</h4><p>除了上面这些属性，全局属性还包括事件处理属性（event handler），用来响应用户的动作。这里列出这些属性的名单。</p>
<blockquote>
<p>onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting</p>
</blockquote>
<h2 id="HTML-字符编码"><a href="#HTML-字符编码" class="headerlink" title="HTML 字符编码"></a>HTML 字符编码</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>网页包含了大量的文字，浏览器必须知道这些文字的编码方法，才能把文字还原出来。</p>
<p>一般情况下，服务器向浏览器发送 HTML 网页文件时，会通过 HTTP 头信息，声明网页的编码方式。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>
<p>上面代码中，HTTP 头信息的<code>Content-Type</code>字段先声明，服务器发送的数据类型是<code>text/html</code>（即 HTML 网页），然后声明网页的文字编码是<code>UTF-8</code>。</p>
<p>网页内部也会再用<code>&lt;meta&gt;</code>标签，再次声明网页的编码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="字符的数字表示法"><a href="#字符的数字表示法" class="headerlink" title="字符的数字表示法"></a>字符的数字表示法</h3><p>网页可以使用不同语言的编码方式，但是最常用的编码是 UTF-8。UTF-8 编码是 Unicode 字符集的一种表达方式。这个字符集的设计目标是包含世界上的所有字符，目前已经收入了十多万个字符。</p>
<p>每个字符有一个 Unicode 号码，称为码点（code point）。如果知道码点，就能查到这是什么字符。举例来说，英文字母<code>a</code>的码点是十进制的<code>97</code>（十六进制的<code>61</code>），汉字“中”的码点是十进制的<code>20013</code>（十六进制的<code>4e2d</code>）。</p>
<p>由于下面的原因，不是每一个 Unicode 字符都能直接在 HTML 语言里面显示。</p>
<p>（1）不是每个 Unicode 字符都可以打印出来，有些没有可打印形式，比如换行符的码点是十进制的<code>10</code>（十六进制的<code>A</code>），就没有对应的字面形式。</p>
<p>（2）小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>）用来定义 HTML 标签，其他需要用到这两个符号的场合，必须防止它们被解释成标签。</p>
<p>（3）由于 Unicode 字符太多，无法找到一种输入法，可以直接输入所有这些字符。换言之，没有一种键盘，有办法输入所有符号。</p>
<p>（4）网页不允许混合使用多种编码，如果使用 UTF-8 编码的同时，又想插入其他编码的字符，就会很困难。</p>
<p>HTML 为了解决上面这些问题，允许使用 Unicode 码点表示字符，浏览器会自动将码点转成对应的字符。</p>
<p>字符的码点表示法是<code>&amp;#N;</code>（十进制，<code>N</code>代表码点）或者<code>&amp;#xN;</code>（十六进制，<code>N</code>代表码点），比如，字符<code>a</code>可以写成<code>&amp;#97;</code>（十进制）或者<code>&amp;#x61;</code>（十六进制），字符<code>中</code>可以写成<code>&amp;#20013;</code>（十进制）或者<code>&amp;#x4e2d;</code>（十六进制），浏览器会自动转换它们。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;#104;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#111;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;#x68;</span><span class="symbol">&amp;#x65;</span><span class="symbol">&amp;#x6c;</span><span class="symbol">&amp;#x6c;</span><span class="symbol">&amp;#x6f;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符可以直接表示，也可以使用十进制码点或十六进制码点表示。</p>
<p>注意，HTML 标签本身不能使用码点表示，否则浏览器会认为这是所要显示的文本内容，而不是标签。比如，<code>&lt;p&gt;</code>一旦写成<code>&lt;&amp;#112;&gt;</code>或者<code>&amp;#60;&amp;#112;&amp;#62;</code>，浏览器就不再认为这是标签了，而会当作文本内容将其显示为<code>&lt;p&gt;</code>。</p>
<h3 id="字符的实体表示法"><a href="#字符的实体表示法" class="headerlink" title="字符的实体表示法"></a>字符的实体表示法</h3><p>数字表示法的不方便之处，在于必须知道每个字符的码点，很难记忆。为了能够快速输入，HTML 为一些特殊字符，规定了容易记忆的名字，允许通过名字来表示它们，这称为实体表示法（entity）。</p>
<p>实体的写法是<code>&amp;name;</code>，其中的<code>name</code>是字符的名字。下面是其中一些特殊字符，及其对应的实体。</p>
<ul>
<li><code>&lt;</code>：<code>&amp;lt;</code></li>
<li><code>&gt;</code>：<code>&amp;gt;</code></li>
<li><code>&quot;</code>：<code>&amp;quot;</code></li>
<li><code>&#39;</code>：<code>&amp;apos;</code></li>
<li><code>&amp;</code>：<code>&amp;amp;</code></li>
<li><code>©</code>：<code>&amp;copy;</code></li>
<li><code>®</code> ：<code>&amp;reg;</code></li>
<li><code>#</code>：<code>&amp;num;</code></li>
<li><code>§</code>：<code>&amp;sect;</code></li>
<li><code>¥</code>：<code>&amp;yen;</code></li>
<li><code>$</code>：<code>&amp;dollar;</code></li>
<li><code>£</code>：<code>&amp;pound;</code></li>
<li><code>¢</code>：<code>&amp;cent;</code></li>
<li><code>%</code>：<code>&amp;percnt;</code></li>
<li><code>*</code>：<code>$ast;</code></li>
<li><code>@</code>：<code>&amp;commat;</code></li>
<li><code>^</code>：<code>&amp;Hat;</code></li>
<li><code>±</code>：<code>&amp;plusmn;</code></li>
<li><code>×</code>：<code>&amp;times;</code></li>
<li><code>÷</code>：<code>&amp;divide;</code></li>
<li><code>²</code>：<code>&amp;sup2;</code></li>
<li><code>³</code>：<code>&amp;sup3;</code></li>
<li><code>°</code>：<code>&amp;deg;</code></li>
<li>空格：<code>&amp;nbsp;</code></li>
</ul>
<p>注意，上面最后一个特殊字符是空格，它也有对应的实体表示法。</p>
<p>字符的数字表示法和实体表示法，都可以表示正常情况无法输入的字符，逃脱了浏览器的限制，所以英语里面称为“escape”，中文翻译为“字符的转义”。</p>
<h2 id="网页的语义结构"><a href="#网页的语义结构" class="headerlink" title="网页的语义结构"></a>网页的语义结构</h2><p>HTML 标签的名称都带有语义（semantic），使用时应该尽量符合标签的语义，不要用错误语义的标签。语义良好的网页，天然具有良好的结构，对于开发者易读易写，容易维护，也能帮助计算机更好地处理网页内容。</p>
<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>HTML 标签的一个重要作用，就是声明网页元素的性质，使得用户只看标签，就能了解这个元素的意义，阅读 HTML 源码就能了解网页的大致结构。这被称为 HTML 的语义原则。</p>
<p>下面就是一个典型的语义结构的网页。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>页眉<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>文章内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>页尾<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只看上面的代码，就可以知道，页面分成页眉（<code>&lt;header&gt;</code>）、主体（<code>&lt;main&gt;</code>）、页尾（<code>&lt;footer&gt;</code>）三个部分。</p>
<p>编写 HTML 网页，第一步就是写出语义结构的网页骨架。</p>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><h4 id="lt-header-gt"><a href="#lt-header-gt" class="headerlink" title="&lt;header&gt;"></a><code>&lt;header&gt;</code></h4><p><code>&lt;header&gt;</code>标签可以用在多个场景，既可以表示整个网页的头部，也可以表示一篇文章或者一个区块的头部。</p>
<p>如果用在网页的头部，就称为“页眉”。网站导航和搜索栏通常会放在<code>&lt;header&gt;</code>里面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>公司名称<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/contact&quot;</span>&gt;</span>联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">target</span>=<span class="string">&quot;/search&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>&lt;header&gt;</code>用在文章的头部，则可以把文章标题、作者等信息放进去。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>张三，发表于2010年1月1日<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;header&gt;</code>可以用在多种场景，所以一个页面可能包含多个<code>&lt;header&gt;</code>，但是一个具体的场景里面只能包含一个，比如网页的页眉只能有一个。另外，<code>&lt;header&gt;</code>里面不能包含另一个<code>&lt;header&gt;</code>或<code>&lt;footer&gt;</code>。</p>
<p><code>header</code> 的语义化特性也可以让辅助工具快速定位到它的内容。</p>
<h4 id="lt-footer-gt"><a href="#lt-footer-gt" class="headerlink" title="&lt;footer&gt;"></a><code>&lt;footer&gt;</code></h4><p><code>&lt;footer&gt;</code>标签表示网页、文章或章节的尾部。如果用于整张网页的尾部，就称为“页尾”，通常包含版权信息或者其他相关信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 2018 xxx 公司<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，版权信息放在<code>&lt;footer&gt;</code>里面。</p>
<p><code>&lt;footer&gt;</code>也可以放在文章里面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>© 禁止转贴<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;footer&gt;</code>不能嵌套，即内部不能放置另一个<code>&lt;footer&gt;</code>，也不能放置<code>&lt;header&gt;</code>。</p>
<p><code>footer</code> 元素也具有语义化的特性，可以让辅助工具快速定位到它。</p>
<h4 id="lt-main-gt"><a href="#lt-main-gt" class="headerlink" title="&lt;main&gt;"></a><code>&lt;main&gt;</code></h4><p><code>&lt;main&gt;</code>标签表示页面的主体内容，一个页面只能有一个<code>&lt;main&gt;</code>。是为了围绕与页面中心主题相关的信息， 而不应包含如导航连接、网页横幅等需要在多个页面中重复出现的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>页眉<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>页尾<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码就是最典型的页面结构。</p>
<p>注意，<code>&lt;main&gt;</code>是顶层标签，不能放置在<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;nav&gt;</code>等标签之中。</p>
<p>另外，功能性区块（比如搜索栏）不适合放入<code>&lt;main&gt;</code>，除非当前页面就是搜索页面。</p>
<p>默认情况下，浏览器呈现 <code>main</code>、<code>header</code>、<code>footer</code>、<code>nav</code>、<code>article</code>、<code>section</code> 等这些元素的方式类似于普通的 <code>div</code>。 但是，在适当的地方使用它们会让标记文本具有更多的含义。 仅标签名称就可以表示它所包含的信息类型，这给内容增加了语义含义。 辅助技术可以获取这种信息，为用户提供更好的页面摘要或导航选项。</p>
<p><code>main</code> 标签有一个内嵌的特性，以便辅助技术快速定位到页面的主体。 如果你在页面顶部看到过“跳转到主要内容”链接，那么使用 <code>main</code> 标签会自动让辅助设备具有这个跳转的功能。</p>
<h4 id="lt-article-gt"><a href="#lt-article-gt" class="headerlink" title="&lt;article&gt;"></a><code>&lt;article&gt;</code></h4><p><code>&lt;article&gt;</code>标签表示页面里面一段完整的内容，即使页面的其他部分不存在，也具有独立使用的意义，通常用来表示一篇文章或者一个论坛帖子。它可以有自己的标题（<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>文章内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个网页可以包含一个或多个<code>&lt;article&gt;</code>，比如包含多篇文章。</p>
<h4 id="lt-aside-gt"><a href="#lt-aside-gt" class="headerlink" title="&lt;aside&gt;"></a><code>&lt;aside&gt;</code></h4><p><code>&lt;aside&gt;</code>标签用来放置与网页或文章主要内容间接相关的部分。网页级别的<code>&lt;aside&gt;</code>，可以用来放置侧边栏，但不一定就在页面的侧边；文章级别的<code>&lt;aside&gt;</code>，可以用来放置评论或注释。</p>
<p>下面是网页级别的<code>&lt;aside&gt;</code>的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span>主体内容<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是文章评注的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一段<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>本段是文章的重点。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="lt-section-gt"><a href="#lt-section-gt" class="headerlink" title="&lt;section&gt;"></a><code>&lt;section&gt;</code></h4><p><code>&lt;section&gt;</code>标签表示一个含有主题的独立部分，用于对与主题相关的内容进行分组，通常用在文档里面表示一个章节，比如<code>&lt;article&gt;</code>可以包含多个<code>&lt;section&gt;</code>。<code>&lt;section&gt;</code>总是多个一起使用，一个页面不能只有一个<code>&lt;section&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>第一章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>第二章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;article&gt;</code>包含了两个<code>&lt;section&gt;</code>，代表两章。</p>
<p><code>&lt;section&gt;</code>很适合幻灯片展示的页面，每个<code>&lt;section&gt;</code>代表一个幻灯片。</p>
<p>一般来说，<code>&lt;section&gt;</code>都应该有标题，即包含<code>&lt;h1&gt;</code>~`<h6><code>标签。多个</code><section><code>可以放置在同一个</code><article><code>里面，一个</code><section><code>里面也可能包含多个</code><article><code>，这取决于</code><section><code>和</code><article>`在当前页面的含义。</p>
<h4 id="lt-nav-gt"><a href="#lt-nav-gt" class="headerlink" title="&lt;nav&gt;"></a><code>&lt;nav&gt;</code></h4><p><code>&lt;nav&gt;</code>标签用于放置页面或文档的导航信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;item-a&quot;</span>&gt;</span>商品 A<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;item-b&quot;</span>&gt;</span>商品 B<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>商品 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般来说，<code>&lt;nav&gt;</code>往往放置在<code>&lt;header&gt;</code>里面，不适合放入<code>&lt;footer&gt;</code>。另外，一个页面可以有多个<code>&lt;nav&gt;</code>，比如一个用于站点导航，另一个用于文章导航。</p>
<h4 id="lt-h1-gt-lt-h6-gt"><a href="#lt-h1-gt-lt-h6-gt" class="headerlink" title="&lt;h1&gt; ~ &lt;h6&gt;"></a><code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code></h4><p>HTML 提供了6个标签，用来表示文章的标题。按照标题的等级，一共分成六级。</p>
<ul>
<li><code>&lt;h1&gt;</code>：一级标题</li>
<li><code>&lt;h2&gt;</code>：二级标题</li>
<li><code>&lt;h3&gt;</code>：三级标题</li>
<li><code>&lt;h4&gt;</code>：四级标题</li>
<li><code>&lt;h5&gt;</code>：五级标题</li>
<li><code>&lt;h6&gt;</code>：六级标题</li>
</ul>
<p><code>&lt;h1&gt;</code>是最高级别的标题，<code>&lt;h6&gt;</code>是最低级别的标题。下一级标题都是上一级标题的子标题，比如，一个<code>&lt;h1&gt;</code>后面可以有多个<code>&lt;h2&gt;</code>，每个<code>&lt;h2&gt;</code>后面又可以有多个<code>&lt;h3&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>JavaScript 语言介绍<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>概述<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>基本概念<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>网页<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>主要用法<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码，通过章节标题，清晰地表明了文章的主体结构。具体的内容，就可以写在章节标题的下面。</p>
<p>默认情况下，浏览器会粗体显示标题。<code>h1</code>的字号比<code>h2</code>大，<code>h2</code>比<code>h3</code>大，以此类推。</p>
<p>标题标签（包括 <code>h1</code> 到 <code>h6</code>）有很高的使用率，它们用于描述内容的主题。 在屏幕阅读器中，用户为了快速了解页面纲要，可以设置让阅读器只朗读页面标题。 这意味着我们不应仅仅为了设置不同字号而使用标题，而应让标签本身具有语义化和实质性的含义，同时不同标题之间也应关联（具有层级关系）。</p>
<p>语义化的意思是，标签名能准确地表达它所含内容的信息类型。</p>
<p>在使用中，相同级别（或者更高级别）的标题标签用于开启新的章节，低一级别的标题标签用于开启上一级标题标签的子小节。标题不应该越级，比如<code>h1</code>下面直接写<code>h3</code>。虽然这样不会报错，但会导致文章失去清晰的章节结构。</p>
<p>比如说，如果我们在一个 <code>h2</code> 标签后加上若干由 <code>h4</code> 标签引导的页面。 此时发生了层级的错位，这会让使用屏幕阅读器的用户感到困惑。 尽管在浏览器所显示的页面中，错误地使用这六个标题标签依然可以让它们在视觉效果上看起来很合理。 但此时，我们应该按照层级正确地使用标签，然后用 CSS 来调整样式。</p>
<p>最后一点，每个页面应只有一个 <code>h1</code> 标签，用来概括说明页面的主题。 另外，这六个标题标签可以让搜索引擎获取页面的大纲。</p>
<h4 id="lt-hgroup-gt"><a href="#lt-hgroup-gt" class="headerlink" title="&lt;hgroup&gt;"></a><code>&lt;hgroup&gt;</code></h4><p>如果主标题包含多级标题（比如带有副标题），那么可以使用<code>&lt;hgroup&gt;</code>标签，将多级标题放在其中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Heading 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Subheading 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Subheading 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>&lt;hgroup&gt;</code>只能包含<code>&lt;h1&gt;</code>~`<h6>`，不能包含其他标签。</p>
<h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p>历史上，网页的主要功能是文本展示。所以，HTML 提供了大量的文本处理标签。</p>
<h3 id="lt-div-gt"><a href="#lt-div-gt" class="headerlink" title="&lt;div&gt;"></a><code>&lt;div&gt;</code></h3><p><code>&lt;div&gt;</code>是一个通用标签，表示一个区块（division）。它没有语义，如果网页需要一个块级元素容器，又没有其他合适的标签，就可以使用这个标签。</p>
<p>它的最常见用途就是提供 CSS 的钩子，用来指定各种样式。所以在早期，下面层层包裹的<code>&lt;div&gt;</code>就很常见。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码读起来很费力，因为不带有语义。后来，HTML 5 就提出了语义标签，改进了上面的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;div&gt;</code>是无语义的块级元素。下面的例子使用<code>&lt;div&gt;</code>，将图像和文字组合在一起，构成一个警告区块。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;warning.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;警告&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>小心<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只要样式上需要多个块级元素组合在一起，就可以使用<code>&lt;div&gt;</code>。但是，这应该是最后的措施，带有语义的块级标签（比如<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;nav&gt;</code>等）始终应该优先使用，当且仅当没有其他语义元素合适时，才可以使用<code>&lt;div&gt;</code>。</p>
<h3 id="lt-p-gt"><a href="#lt-p-gt" class="headerlink" title="&lt;p&gt;"></a><code>&lt;p&gt;</code></h3><p><code>&lt;p&gt;</code>标签是一个块级元素，代表文章的一个段落（paragraph）。不仅是文本，任何想以段落显示的内容，比如图片和表单项，都可以放进<code>&lt;p&gt;</code>元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码就是一个简单的段落。</p>
<p>Web 开发者通常用 lorem ipsum text 来做占位符。 lorem ipsum text 是从古罗马西塞罗的一段著名经文中随机抽取的。Lorem ipsum text 自 16 世纪以来就在排版中被用作占位符，这一习惯也在 Web 开发中得以延续。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>ipsum<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-span-gt"><a href="#lt-span-gt" class="headerlink" title="&lt;span&gt;"></a><code>&lt;span&gt;</code></h3><p><code>&lt;span&gt;</code>是一个通用目的的行内标签（即不会产生换行），不带有任何语义。它通常用作 CSS 样式的钩子，如果需要对某些行内内容指定样式，就可以把它们放置在<code>&lt;span&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一句<span class="tag">&lt;<span class="name">span</span>&gt;</span>重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的句子。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，句子里面需要强调的部分，就可以放在<code>&lt;span&gt;</code>。</p>
<h3 id="lt-br-gt-，-lt-wbr-gt"><a href="#lt-br-gt-，-lt-wbr-gt" class="headerlink" title="&lt;br&gt;，&lt;wbr&gt;"></a><code>&lt;br&gt;</code>，<code>&lt;wbr&gt;</code></h3><p><code>&lt;br&gt;</code>让网页产生一个换行效果。该标签是单独使用的，没有闭合标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">hello<span class="tag">&lt;<span class="name">br</span>&gt;</span>world</span><br></pre></td></tr></table></figure>
<p>浏览器渲染上面代码时，会分成两行，<code>hello</code>和<code>world</code>各占一行。</p>
<p><code>&lt;br&gt;</code>对于诗歌和地址的换行非常有用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  床前明月光，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  疑是地上霜。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  举头望明月，<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  低头思故乡。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码如果不用<code>&lt;br&gt;</code>，会显示成一行。</p>
<p>注意，块级元素的间隔，不要使用<code>&lt;br&gt;</code>来产生，而要使用 CSS 指定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一段<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二段<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码希望段落之间有两个换行，这时不应该使用<code>&lt;br&gt;</code>，而应该使用 CSS。</p>
<p><code>&lt;wbr&gt;</code>标签跟<code>&lt;br&gt;</code>很相似，表示一个可选的断行。如果一行的宽度足够，则不断行；如果宽度不够，需要断行，就在<code>&lt;wbr&gt;</code>的位置的断行。它是为了防止浏览器在一个很长的单词中间，不正确地断行或者不断行，所以事先标明可以断行的位置，主要用于欧洲一些单词很长的语言或者 URL 的断行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Fernstraßen<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>bau<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>privat<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>finanzierungs<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>gesetz</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个很长的德语单词，为了防止不正确断行，事先用<code>&lt;wbr&gt;</code>告诉浏览器，可以选择在哪里断行。</p>
<h3 id="lt-hr-gt"><a href="#lt-hr-gt" class="headerlink" title="&lt;hr&gt;"></a><code>&lt;hr&gt;</code></h3><p><code>&lt;hr&gt;</code>用来在一篇文章中分隔两个不同的主题，浏览器会将其渲染为一根水平线。该标签是单独使用的，没有闭合标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个主题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>第二个主题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的渲染结果是，两段之间会出现一根水平线。</p>
<p>该标签是历史遗留下来的，建议尽量避免使用。主题之间的分隔可以使用<code>&lt;section&gt;</code>，如果想要水平线的效果，可以使用 CSS。</p>
<h3 id="lt-pre-gt"><a href="#lt-pre-gt" class="headerlink" title="&lt;pre&gt;"></a><code>&lt;pre&gt;</code></h3><p><code>&lt;pre&gt;</code>是一个块级元素，表示保留原来的格式（preformatted），即浏览器会保留该标签内部原始的换行和空格。浏览器默认以等宽字体显示标签内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>hello</span><br><span class="line"></span><br><span class="line">   world<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，换行和连续空格都会由于<code>&lt;pre&gt;</code>标签，而被保留下来，浏览器按照原样输出。</p>
<p>注意，HTML 标签在<code>&lt;pre&gt;</code>里面还是起作用的。<code>&lt;pre&gt;</code>只保留空格和换行，不会保留 HTML 标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;pre&gt;</code>标签的内容会加粗显示。</p>
<h3 id="lt-strong-gt-，-lt-b-gt"><a href="#lt-strong-gt-，-lt-b-gt" class="headerlink" title="&lt;strong&gt;，&lt;b&gt;"></a><code>&lt;strong&gt;</code>，<code>&lt;b&gt;</code></h3><p><code>&lt;strong&gt;</code>是一个行内元素，表示它包含的内容具有很强的重要性，需要引起注意。浏览器会以粗体显示内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>开会时间是<span class="tag">&lt;<span class="name">strong</span>&gt;</span>下午两点<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;b&gt;</code>与<code>&lt;strong&gt;</code>很相似，也表示它包含的内容需要引起注意，浏览器会加粗显示。它是 Boldface 的缩写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>开会时间是<span class="tag">&lt;<span class="name">b</span>&gt;</span>下午两点<span class="tag">&lt;/<span class="name">b</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它与<code>&lt;strong&gt;</code>的区别在于，由于历史原因，它没有语义，是一个纯样式的标签，违反了语义与样式分离的原则，因此不建议使用，应该优先使用<code>&lt;strong&gt;</code>标签。</p>
<h3 id="lt-em-gt-，-lt-i-gt"><a href="#lt-em-gt-，-lt-i-gt" class="headerlink" title="&lt;em&gt;，&lt;i&gt;"></a><code>&lt;em&gt;</code>，<code>&lt;i&gt;</code></h3><p><code>&lt;em&gt;</code>是一个行内标签，表示强调（emphasize）、需要用户着重阅读的内容，浏览器会以斜体显示它包含的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我们<span class="tag">&lt;<span class="name">em</span>&gt;</span>已经<span class="tag">&lt;/<span class="name">em</span>&gt;</span>讨论过这件事情了。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然浏览器通常会以斜体显示<code>&lt;em&gt;</code>，但无法保证一定如此，所以最好还是用 CSS 指定一下这个标签的样式。</p>
<p> <code>&lt;em&gt;</code> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。</p>
<p><code>&lt;i&gt;</code>标签与<code>&lt;em&gt;</code>相似，用于表现因某些原因需要区分普通文本的一系列文本，浏览器会以斜体显示。它是 Italic 的缩写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我心想，这件事是<span class="tag">&lt;<span class="name">i</span>&gt;</span>真的<span class="tag">&lt;/<span class="name">i</span>&gt;</span>吗？<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;i&gt;</code>标签的语义不强，更接近是一个纯样式的标签，建议优先使用<code>&lt;em&gt;</code>标签代替它。</p>
<h3 id="lt-sub-gt-，-lt-sup-gt-，-lt-var-gt"><a href="#lt-sub-gt-，-lt-sup-gt-，-lt-var-gt" class="headerlink" title="&lt;sub&gt;，&lt;sup&gt;，&lt;var&gt;"></a><code>&lt;sub&gt;</code>，<code>&lt;sup&gt;</code>，<code>&lt;var&gt;</code></h3><p><code>&lt;sub&gt;</code>标签将内容变为下标，<code>&lt;sup&gt;</code>标签将内容变为上标。它们都是行内元素，主要用于数学公式、分子式等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水分子是 H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;<span class="name">O</span></span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;var&gt;</code>标签表示代码或数学公式的变量。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>勾股定理是</span><br><span class="line">  <span class="tag">&lt;<span class="name">var</span>&gt;</span>a<span class="tag">&lt;/<span class="name">var</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> + <span class="tag">&lt;<span class="name">var</span>&gt;</span>b<span class="tag">&lt;/<span class="name">var</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> = <span class="tag">&lt;<span class="name">var</span>&gt;</span>c<span class="tag">&lt;/<span class="name">var</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-u-gt-，-lt-s-gt"><a href="#lt-u-gt-，-lt-s-gt" class="headerlink" title="&lt;u&gt;，&lt;s&gt;"></a><code>&lt;u&gt;</code>，<code>&lt;s&gt;</code></h3><p><code>&lt;u&gt;</code>标签是一个行内元素，下划线通常用来表示重要内容或需要记忆的内容。浏览器默认以下划线渲染内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">一个容易写错的成语是把<span class="tag">&lt;<span class="name">em</span>&gt;</span>安分守己<span class="tag">&lt;/<span class="name">em</span>&gt;</span>写成<span class="tag">&lt;<span class="name">u</span>&gt;</span>安份守己<span class="tag">&lt;/<span class="name">u</span>&gt;</span>。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;u&gt;</code>提示用户这是一个拼写错误，“安份守己”的下方会有一个下划线。</p>
<p>注意，<code>&lt;u&gt;</code>会产生下划线，由于链接也默认带有下划线，所以必须非常小心使用<code>&lt;u&gt;</code>标签，避免用户误以为可以点击。万一确有必要使用，最好使用 CSS 改变<code>&lt;u&gt;</code>的默认样式。</p>
<p><code>&lt;s&gt;</code>标签是一个行内元素，为内容加上删除线。 删除线是位于文字水平中央的一条线，它代表着一段文字不再有效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天特价商品：<span class="tag">&lt;<span class="name">s</span>&gt;</span>三文鱼<span class="tag">&lt;/<span class="name">s</span>&gt;</span>（售完）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“三文鱼”会有一根删除线。</p>
<h3 id="lt-blockquote-gt-，-lt-cite-gt-，-lt-q-gt"><a href="#lt-blockquote-gt-，-lt-cite-gt-，-lt-q-gt" class="headerlink" title="&lt;blockquote&gt;，&lt;cite&gt;，&lt;q&gt;"></a><code>&lt;blockquote&gt;</code>，<code>&lt;cite&gt;</code>，<code>&lt;q&gt;</code></h3><p><code>&lt;blockquote&gt;</code>是一个块级标签，表示引用他人的话。浏览器会在样式上，与正常文本区别显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">cite</span>=<span class="string">&quot;https://quote.example.com&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>天才就是 1% 的天赋和99%的汗水。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;blockquote&gt;</code>标签有一个<code>cite</code>属性，它的值是一个网址，表示引言来源，不会显示在网页上。</p>
<p><code>&lt;cite&gt;</code>标签表示引言出处或者作者，浏览器默认使用斜体显示这部分内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">cite</span>=<span class="string">&quot;https://quote.example.com&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>天才就是 1% 的天赋和99%的汗水。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span>-- 爱迪生<span class="tag">&lt;/<span class="name">cite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;cite&gt;</code>不一定跟<code>&lt;blockquote&gt;</code>一起使用。如果文章中提到资料来源，也可以单独使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>更多资料请看<span class="tag">&lt;<span class="name">cite</span>&gt;</span>维基百科<span class="tag">&lt;/<span class="name">cite</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;q&gt;</code>是一个行内标签，也表示引用。它与<code>&lt;blockquote&gt;</code>的区别，就是它不会产生换行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  莎士比亚的《哈姆雷特》有一句著名的台词：</span><br><span class="line">  <span class="tag">&lt;<span class="name">q</span> <span class="attr">cite</span>=<span class="string">&quot;https://quote.example.com&quot;</span>&gt;</span>活着还是死亡，这是一个问题。<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，引言部分跟前面的说明部分是在同一行里面。</p>
<p>另外，跟<code>&lt;blockquote&gt;</code>一样，<code>&lt;q&gt;</code>也有<code>cite</code>属性，表示引言的来源网址。</p>
<p>注意，浏览器默认会斜体显示<code>&lt;q&gt;</code>的内容，并且会自动添加半角的双引号。所以，引用中文内容时要小心。</p>
<h3 id="lt-code-gt"><a href="#lt-code-gt" class="headerlink" title="&lt;code&gt;"></a><code>&lt;code&gt;</code></h3><p><code>&lt;code&gt;</code>标签是一个行内元素，表示标签内容是计算机代码，浏览器默认会以等宽字体显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>alert()<span class="tag">&lt;/<span class="name">code</span>&gt;</span>的作用是让网页弹出一个提示框。</span><br></pre></td></tr></table></figure>
<p>如果要表示多行代码，<code>&lt;code&gt;</code>标签必须放在<code>&lt;pre&gt;</code>内部。<code>&lt;code&gt;</code>本身仅表示一行代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">  let a = 1;</span><br><span class="line">  console.log(a);</span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-kbd-gt-，-lt-samp-gt"><a href="#lt-kbd-gt-，-lt-samp-gt" class="headerlink" title="&lt;kbd&gt;，&lt;samp&gt;"></a><code>&lt;kbd&gt;</code>，<code>&lt;samp&gt;</code></h3><p><code>&lt;kbd&gt;</code>标签是一个行内元素，原意是用户从键盘输入的内容，现在扩展到各种输入，包括语音输入。浏览器默认以等宽字体显示标签内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Windows 可以按下 <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Shift<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> 重启。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;kbd&gt;</code>可以嵌套，方便指定样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Windows 可以按下</span><br><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span> <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Shift<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> <span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">重启。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;samp&gt;</code>标签是一个行内元素，表示计算机程序输出内容的一个例子。浏览器默认以等宽字体显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>如果使用没有定义的变量，浏览器会报错：</span><br><span class="line"><span class="tag">&lt;<span class="name">samp</span>&gt;</span>Uncaught ReferenceError: foo is not defined<span class="tag">&lt;/<span class="name">samp</span>&gt;</span>。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-mark-gt"><a href="#lt-mark-gt" class="headerlink" title="&lt;mark&gt;"></a><code>&lt;mark&gt;</code></h3><p><code>&lt;mark&gt;</code>是一个行内标签，表示突出显示的内容。Chrome 浏览器默认会以亮黄色背景，显示该标签的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我们讨论以后决定，<span class="tag">&lt;<span class="name">mark</span>&gt;</span>运行会在下周三举办<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;mark&gt;</code>很适合在引用的内容（<code>&lt;q&gt;</code>或<code>&lt;blockquote&gt;</code>）中，标记出需要关注的句子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">床前明月光，疑是地上霜。<span class="tag">&lt;<span class="name">mark</span>&gt;</span>举头望明月，低头思故乡。<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了标记感兴趣的文本，<code>&lt;mark&gt;</code>还可以用于在搜索结果中，标记出匹配的关键词。</p>
<p>注意，不要只为了高亮的效果，而使用这个标签，因为不能保证浏览器的处理方式。如果要保证高亮，还是要使用 CSS 样式。</p>
<h3 id="lt-small-gt"><a href="#lt-small-gt" class="headerlink" title="&lt;small&gt;"></a><code>&lt;small&gt;</code></h3><p><code>&lt;small&gt;</code>是一个行内标签，浏览器会将它包含的内容，以小一号的字号显示，不需要使用 CSS 样式。它通常用于文章附带的版权信息或法律信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文章正文<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">small</span>&gt;</span>以上内容使用创意共享许可证。<span class="tag">&lt;/<span class="name">small</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-time-gt-，-lt-data-gt"><a href="#lt-time-gt-，-lt-data-gt" class="headerlink" title="&lt;time&gt;，&lt;data&gt;"></a><code>&lt;time&gt;</code>，<code>&lt;data&gt;</code></h3><p><code>&lt;time&gt;</code>是一个行内标签，为跟时间相关的内容提供机器可读的格式。通过标准化时间格式，即使时间在文本中是以非正式的或口语化的形式编写，辅助设备依然可以获取准确的时间和日期。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>运动会预定<span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2015-06-10&quot;</span>&gt;</span>下周三<span class="tag">&lt;/<span class="name">time</span>&gt;</span>举行。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;time&gt;</code>表示下周三的具体日期。这方便搜索引擎抓取，或者下一步的其他处理。</p>
<p><code>&lt;time&gt;</code>的<code>datetime</code>属性，用来指定机器可读的日期，可以有多种格式。</p>
<ul>
<li>有效年份：<code>2011</code></li>
<li>有效月份：<code>2011-11</code></li>
<li>有效日期：<code>2011-11-18</code></li>
<li>无年份的日期：<code>11-18</code></li>
<li>年度的第几周：<code>2011-W47</code></li>
<li>有效时间：<code>14:54</code>、<code>14:54:39</code>、<code>14:54:39.929</code></li>
<li>日期和时间：<code>2011-11-18T14:54:39.929</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>音乐会在<span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;20:00&quot;</span>&gt;</span>晚上八点<span class="tag">&lt;/<span class="name">time</span>&gt;</span>开始。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;data&gt;</code>标签与<code>&lt;time&gt;</code>类似，也是提供机器可读的内容，但是用于非时间的场合。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本次马拉松比赛第一名是<span class="tag">&lt;<span class="name">data</span> <span class="attr">value</span>=<span class="string">&quot;39&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>。</span><br></pre></td></tr></table></figure>
<p>上面代码中，选手的机读数据就放在<code>&lt;data&gt;</code>标签的<code>value</code>属性。</p>
<h3 id="lt-address-gt"><a href="#lt-address-gt" class="headerlink" title="&lt;address&gt;"></a><code>&lt;address&gt;</code></h3><p><code>&lt;address&gt;</code>标签是一个块级元素，表示某人或某个组织的联系方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>作者的联系方式：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:foo@example.com&quot;</span>&gt;</span>foo@example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tel:+555-34762301&quot;</span>&gt;</span>+555-34762301<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该标签有几个注意点。</p>
<p>（1）如果是文章里提到的地址（比如提到搬家前的地址），而不是联系信息，不要使用<code>&lt;address&gt;</code>标签。</p>
<p>（2）<code>&lt;address&gt;</code>的内容不得有非联系信息，比如发布日期。</p>
<p>（3）<code>&lt;address&gt;</code>不能嵌套，并且内部不能有标题标签（<code>&lt;h1&gt;</code>~`<h6><code>），也不能有</code><article><code>、</code><aside><code>、</code><section><code>、</code><nav><code>、</code><header><code>、</code><footer>`等标签。</p>
<p>（4）通常，<code>&lt;address&gt;</code>会放在<code>&lt;footer&gt;</code>里面，下面是一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    文章的相关问题请联系<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:zhangsan@example.com&quot;</span>&gt;</span>张三</span><br><span class="line">    McClure<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-abbr-gt"><a href="#lt-abbr-gt" class="headerlink" title="&lt;abbr&gt;"></a><code>&lt;abbr&gt;</code></h3><p><code>&lt;abbr&gt;</code>标签是一个行内元素，表示标签内容是一个缩写。它的<code>title</code>属性给出缩写的完整形式，或者缩写的描述。鼠标悬停在该元素上方时，<code>title</code>属性值作为提示，会完整显示出来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;HyperText Markup Language&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，某些浏览器可能对该标签提供圆点下划线。</p>
<h3 id="lt-ins-gt-，-lt-del-gt"><a href="#lt-ins-gt-，-lt-del-gt" class="headerlink" title="&lt;ins&gt;，&lt;del&gt;"></a><code>&lt;ins&gt;</code>，<code>&lt;del&gt;</code></h3><p><code>&lt;ins&gt;</code>标签是一个行内元素，表示原始文档添加（insert）的内容。<code>&lt;del&gt;</code>与之类似，表示删除（delete）的内容。它们通常用于展示文档的删改。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议定于5月8日举行。<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>会议定于5月9日举行。<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器默认为<code>&lt;del&gt;</code>标签的内容加上删除线，为<code>&lt;ins&gt;</code>标签的内容加上下划线。</p>
<p>这两个标签都有以下属性。</p>
<ul>
<li><code>cite</code>：该属性的值是一个 URL，表示该网址可以解释本次删改。</li>
<li><code>datetime</code>：表示删改发生的时间。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ins</span> <span class="attr">cite</span>=<span class="string">&quot;./why.html&quot;</span> <span class="attr">datetime</span>=<span class="string">&quot;2018-05&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>项目比原定时间提前两周结束。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-dfn-gt"><a href="#lt-dfn-gt" class="headerlink" title="&lt;dfn&gt;"></a><code>&lt;dfn&gt;</code></h3><p><code>&lt;dfn&gt;</code>是一个行内元素，表示标签内容是一个术语（definition），本段或本句包含它的定义。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">通过 TCP/IP 协议连接的全球性计算机网络，叫做 <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>Internet<span class="tag">&lt;/<span class="name">dfn</span>&gt;</span>。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了脚本操作的方便，可以把术语的定义写入<code>&lt;dfn&gt;</code>标签的<code>title</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">通过 TCP/IP 协议连接的全球性计算机网络，叫做</span><br><span class="line"><span class="tag">&lt;<span class="name">dfn</span> <span class="attr">title</span>=<span class="string">&quot;全球性计算机网络&quot;</span>&gt;</span>Internet<span class="tag">&lt;/<span class="name">dfn</span>&gt;</span>。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>title</code>属性的一个作用是，鼠标悬浮的时候，术语的解释会以提示的形式显示出来。</p>
<p>某些时候，术语本身是一个缩写，这时<code>&lt;dfn&gt;</code>和<code>&lt;abbr&gt;</code>可以结合使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dfn</span>&gt;</span><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;acquired immune deficiency syndrome&quot;</span>&gt;</span>AIDS<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span><span class="tag">&lt;/<span class="name">dfn</span>&gt;</span></span><br><span class="line">的全称是获得性免疫缺陷综合征。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-ruby-gt"><a href="#lt-ruby-gt" class="headerlink" title="&lt;ruby&gt;"></a><code>&lt;ruby&gt;</code></h3><p><code>&lt;ruby&gt;</code>标签表示文字的语音注释，主要用于东亚文字，比如汉语拼音和日语的片假名。它默认将语音注释，以小字体显示在文字的上方。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">汉<span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>han<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">字<span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的渲染结果是，<code>汉字</code>上方有小字体的拼音<code>han zi</code>。</p>
<p><code>&lt;ruby&gt;</code>标签是一个行内元素，也是一个容器标签。如果要使用语音注释，就必须把文字和注释都放在这个标签里面。</p>
<p><code>&lt;ruby&gt;</code>的内部还有许多配套的标签。</p>
<p><strong>（1）<code>&lt;rp&gt;</code></strong></p>
<p><code>&lt;rp&gt;</code>标签的用处，是为不支持语音注释的浏览器，提供一个兼容方案。对于那些支持语音注释的浏览器，该标签的内容不显示。</p>
<p><code>&lt;rp&gt;</code>标签一般用于放置圆括号，如果遇到不支持的浏览器，就会将语音注释显示在括号里面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">汉<span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>han<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">字<span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在不支持语音注释的浏览器中，渲染结果为<code>汉(han)字(zi)</code>。遇到支持语音注释的浏览器，就不会显示圆括号。</p>
<p><strong>（2）<code>&lt;rt&gt;</code></strong></p>
<p><code>&lt;rt&gt;</code>标签用于放置语音注释。</p>
<p><strong>（3）<code>&lt;rb&gt;</code></strong></p>
<p><code>&lt;rb&gt;</code>标签用于划分文字单位，与语音注释一一对应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rb</span>&gt;</span>汉<span class="tag">&lt;/<span class="name">rb</span>&gt;</span><span class="tag">&lt;<span class="name">rb</span>&gt;</span>字<span class="tag">&lt;/<span class="name">rb</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rt</span>&gt;</span>han<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>汉字</code>这两个字是写在一起的，<code>&lt;rb&gt;</code>标签用于每个字划分出来，跟<code>&lt;rt&gt;</code>标签一一对应。</p>
<p><strong>（4）<code>&lt;rbc&gt;</code>，<code>&lt;rtc&gt;</code></strong></p>
<p><code>&lt;rbc&gt;</code>标签表示一组文字，通常包含多个<code>&lt;rb&gt;</code>元素。<code>&lt;rtc&gt;</code>标签表示一组语音注释，跟<code>&lt;rbc&gt;</code>对应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span> <span class="attr">style</span>=<span class="string">&quot;ruby-position: under;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rbc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rb</span>&gt;</span>汉<span class="tag">&lt;/<span class="name">rb</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>han<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rb</span>&gt;</span>字<span class="tag">&lt;/<span class="name">rb</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rbc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rtc</span> <span class="attr">style</span>=<span class="string">&quot;ruby-position: over;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>Chinese<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">rtc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>汉字</code>这两个字有两组语音注释，分别是汉语拼音与英语。一组语音注释放在<code>&lt;rbc&gt;</code>标签中，另一组语音注释放在<code>&lt;rtc&gt;</code>，用来对应<code>&lt;rbc&gt;</code>。同时，分别使用<code>style</code>属性，指定汉语拼音显示在文字下方，英语显示在文字上方。</p>
<h3 id="lt-bdo-gt-，-lt-bdi-gt"><a href="#lt-bdo-gt-，-lt-bdi-gt" class="headerlink" title="&lt;bdo&gt;，&lt;bdi&gt;"></a><code>&lt;bdo&gt;</code>，<code>&lt;bdi&gt;</code></h3><p>大部分文字的阅读方向是从左到右，但是有些文字的方向是从右到左，比如阿拉伯语、希伯来语等。<code>&lt;bdo&gt;</code>标签是一个行内元素，表示文字方向与网页主体内容的方向不一致。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>床前明月光，<span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>霜上地是疑<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;bdo&gt;</code>标签里面的文字，会以相反的方向渲染，结果就是“床前明月光，疑是地上霜”。</p>
<p><code>&lt;bdo&gt;</code>的<code>dir</code>属性，指定具体的文字方向。它有两个值，<code>ltr</code>表示从左到右，<code>rtl</code>表示从右到左。</p>
<p><code>&lt;bdi&gt;</code>标签用于不确定文字方向的情况。比如，网页有一个部分是用户输入的内容，但是不知道输入内容的文字方向。这种情况就可以使用<code>&lt;bdi&gt;</code>标签，告诉浏览器，不确定文字的方向，由浏览器自己决定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">bdi</span>&gt;</span>床前明月光，疑是地上霜。<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>列表是一系列排列好的项目，主要分成两类：有序列表和无序列表。</p>
<p>有序列表是每个列表项前面有编号，呈现出顺序，就像下面这样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. 列表项 A</span><br><span class="line">2. 列表项 B</span><br><span class="line">3. 列表项 C</span><br></pre></td></tr></table></figure>
<p>无序列表则是列表项前面没有编号，只有一个列表符号，默认是一个圆点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">· 列表项 A</span><br><span class="line">· 列表项 B</span><br><span class="line">· 列表项 C</span><br></pre></td></tr></table></figure>
<h3 id="lt-ol-gt"><a href="#lt-ol-gt" class="headerlink" title="&lt;ol&gt;"></a><code>&lt;ol&gt;</code></h3><p><code>&lt;ol&gt;</code>标签是一个有序列表容器（ordered list），会在内部的列表项前面产生数字编号。列表项的顺序有意义时，比如排名，就会采用这个标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会在列表项 A、B、C 前面，分别产生1、2、3的编号。</p>
<p><code>&lt;ol&gt;</code>标签内部可以嵌套<code>&lt;ol&gt;</code>标签或<code>&lt;ul&gt;</code>标签，形成多级列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，一个有序列表内部嵌套了另一个有序列表，渲染结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. 列表项 A</span><br><span class="line">2. 列表项 B</span><br><span class="line">  1. 列表项 B1</span><br><span class="line">  2. 列表项 B2</span><br><span class="line">  3. 列表项 B3</span><br><span class="line">3. 列表项 C</span><br></pre></td></tr></table></figure>
<p>该标签有以下属性。</p>
<p><strong>（1）reversed</strong></p>
<p><code>reversed</code>属性产生倒序的数字列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，列表项 A、B、C 前面，产生的编号是3、2、1。</p>
<p><strong>（2）start</strong></p>
<p><code>start</code>属性的值是一个整数，表示数字列表的起始编号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，列表项 A、B、C 前面，产生的编号是5、6、7。</p>
<p><strong>（3）type</strong></p>
<p><code>type</code>属性指定数字编号的样式。目前，浏览器支持以下样式。</p>
<ul>
<li><code>a</code>：小写字母</li>
<li><code>A</code>：大写字母</li>
<li><code>i</code>：小写罗马数字</li>
<li><code>I</code>：大写罗马数字</li>
<li><code>1</code>：整数（默认值）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，列表项 A、B、C 前面的编号，分别是英文小写字母a、b、c。</p>
<p>注意，即使编号是字母，<code>start</code>属性也依然使用整数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span> <span class="attr">start</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>type</code>属性指定编号采用小写英文字母，<code>start</code>属性等于<code>3</code>，表示从<code>c</code>开始编号。</p>
<h3 id="lt-ul-gt"><a href="#lt-ul-gt" class="headerlink" title="&lt;ul&gt;"></a><code>&lt;ul&gt;</code></h3><p><code>&lt;ul&gt;</code>标签是一个无序列表容器（unordered list），会在内部的列表项前面产生实心小圆点，作为列表符号。列表项的顺序无意义时，采用这个标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的渲染结果是，列表项 A、B、C 前面，分别产生一个实心小圆点，作为列表符号。</p>
<p><code>&lt;ul&gt;</code>标签内部可以嵌套<code>&lt;ul&gt;</code>或<code>&lt;ol&gt;</code>，形成多级列表。</p>
<p><code>type</code>属性指定样式。：</p>
<ul>
<li> <code>disc</code>(实心原点，默认)</li>
<li> <code>square</code>(实心方点)</li>
<li> <code>circle</code>(空心圆)</li>
</ul>
<h3 id="lt-li-gt"><a href="#lt-li-gt" class="headerlink" title="&lt;li&gt;"></a><code>&lt;li&gt;</code></h3><p><code>&lt;li&gt;</code>（list item）表示列表项，只能用在<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>容器之中。</p>
<p>有序列表<code>&lt;ol&gt;</code>之中，<code>&lt;li&gt;</code>有一个<code>value</code>属性，定义当前列表项的编号，后面列表项会从这个值开始编号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 A<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>列表项 B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项 C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>value</code>属性指定第二个列表项的编号是<code>4</code>，因此三个列表项的编号，分别为1、4、5。</p>
<p><code>&lt;li&gt;</code>标签也有<code>type</code>属性。</p>
<h3 id="lt-dl-gt-，-lt-dt-gt-，-lt-dd-gt"><a href="#lt-dl-gt-，-lt-dt-gt-，-lt-dd-gt" class="headerlink" title="&lt;dl&gt;，&lt;dt&gt;，&lt;dd&gt;"></a><code>&lt;dl&gt;</code>，<code>&lt;dt&gt;</code>，<code>&lt;dd&gt;</code></h3><p><code>&lt;dl&gt;</code>标签是一个块级元素，表示一组术语的列表（description list）。</p>
<p>术语名（description term）由<code>&lt;dt&gt;</code>标签定义，这个标签是必须的。</p>
<p>术语解释（description detail）由<code>&lt;dd&gt;</code>标签定义。</p>
<p><code>&lt;dl&gt;</code>常用来定义词汇表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>CPU<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>中央处理器<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Memory<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内存<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Hard Disk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>硬盘<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>都是块级元素，<code>&lt;dd&gt;</code>默认会在<code>&lt;dt&gt;</code>下方缩进显示。上面代码的默认渲染结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CPU</span><br><span class="line">  中央处理器</span><br><span class="line"></span><br><span class="line">Memory</span><br><span class="line">  内存</span><br><span class="line"></span><br><span class="line">Hard Disk</span><br><span class="line">  硬盘</span><br></pre></td></tr></table></figure>
<p>多个术语（<code>&lt;dt&gt;</code>）对应一个解释（<code>&lt;dd&gt;</code>），或者多个解释（<code>&lt;dd&gt;</code>）对应一个术语（<code>&lt;dt&gt;</code>），都是合法的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>A<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>B<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>C<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>D<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>E<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>F<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>A</code>和<code>B</code>有共同的解释<code>C</code>，而<code>D</code>有两个解释<code>E</code>和<code>F</code>。</p>
<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><p>图片是互联网的重要组成部分，让网页变得丰富多彩。</p>
<h3 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h3><p><code>&lt;img&gt;</code>标签用于插入图片。它是单独使用的，没有闭合标签。网页html文档支持的图片格式有 jpg、gif 、png   和   bmp   这四种。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在网页插入一张图片<code>foo.jpg</code>。<code>src</code>属性指定图片的网址，上例是相对 URL，表示图片与网页在同一个目录。</p>
<p><code>&lt;img&gt;</code>默认是一个行内元素，与前后的文字处在同一行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的渲染结果是，文字和图片在同一行显示。</p>
<p>图像默认以原始大小显示。如果图片很大，又与文字处在同一行，那么图片将把当前行的行高撑高，并且图片的底边与文字的底边在同一条水平线上。</p>
<p><code>&lt;img&gt;</code>可以放在<code>&lt;a&gt;</code>标签内部，使得图片变成一个可以点击的链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;example.html&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，图片可以像链接那样点击，点击后会产生跳转。</p>
<p><strong>（1）alt 属性</strong></p>
<p><code>alt</code>属性用来设定图片的文字说明。图片不显示时（比如下载失败，或用户关闭图片加载），图片的位置上会显示该文本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>alt</code>是图片的说明。图片下载失败时，浏览器会在图片位置，显示文字“示例图片”。</p>
<p>所有的 <code>img</code> 元素必须有 <code>alt</code> 属性。 视觉障碍用户无法通过视觉获取信息，而是通过屏幕阅读器将网页内容转换为音频以获取信息。 他们无法通过直观的呈现理解信息。 屏幕阅读器可以识别 <code>alt</code> 属性，朗读其中的内容，来告知用户图片包含的关键信息。 </p>
<p>在图片已经有了文字说明，或者仅仅为了美化页面的情况下，把 <code>alt</code> 的属性值设置为空是最佳实践。理想情况下，<code>alt</code> 属性不应该包含特殊字符，除非有特殊需要。对于有标题的图片，依然需要添加 <code>alt</code> 文本，因为这样有助于搜索引擎记录图片内容。</p>
<p><strong>（2）width 属性，height 属性</strong></p>
<p>图片默认以原始大小插入网页，<code>width</code>属性和<code>height</code>属性可以指定图片显示时的宽度和高度，单位是像素或百分比。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>width</code>属性指定图片显示的宽度为400像素，<code>height</code>属性指定显示高度为300像素。</p>
<p>注意，一旦设置了这两个属性，浏览器会在网页中预先留出这个大小的空间，不管图片有没有加载成功。不过，由于图片的显示大小可以用 CSS 设置，所以不建议使用这两个属性。</p>
<p>一种特殊情况是，<code>width</code>属性和<code>height</code>属性只设置了一个，另一个没有设置。这时，浏览器会根据图片的原始大小，自动设置对应比例的图片宽度或高度。举例来说，图片大小是 800像素 x 800像素，<code>width</code>属性设置成200，那么浏览器会自动将<code>height</code>设成200。</p>
<p><strong>（3）srcset，sizes</strong></p>
<p>详见下文。</p>
<p><strong>（4）referrerpolicy</strong></p>
<p><code>&lt;img&gt;</code>导致的图片加载的 HTTP 请求，默认会带有<code>Referer</code>的头信息。<code>referrerpolicy</code>属性对这个行为进行设置。</p>
<p><strong>（5）crossorigin</strong></p>
<p>有时，图片和网页属于不同的网站，网页加载图片就会导致跨域请求，对方服务器可能要求跨域认证。<code>crossorigin</code>属性用来告诉浏览器，是否采用跨域的形式下载图片，默认是不采用。</p>
<p>简单说，只要打开了这个属性，HTTP 请求的头信息里面，就会加入<code>origin</code>字段，给出请求发出的域名，不打开这个属性就不加。</p>
<p>一旦打开该属性，它可以设为两个值。</p>
<ul>
<li><code>anonymous</code>：跨域请求不带有用户凭证（通常是 Cookie）。</li>
<li><code>use-credentials</code>：跨域请求带有用户凭证。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>crossorigin</code>属性如果省略值的部分，则等同于<code>anonymous</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span> <span class="attr">crossorigin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>（6）loading</strong></p>
<p>浏览器的默认行为是，只要解析到<code>&lt;img&gt;</code>标签，就开始加载图片。对于很长的网页，这样做很浪费带宽，因为用户不一定会往下滚动，一直看到网页结束。用户很可能是点开网页，看了一会就关掉了，那些不在视口的图片加载的流量，就都浪费了。</p>
<p><code>loading</code>属性改变了这个行为，可以指定图片的懒加载，即图片默认不加载，只有即将滚动进入视口，变成用户可见时才会加载，这样就节省了带宽。</p>
<p><code>loading</code>属性可以取以下三个值。</p>
<blockquote>
<ul>
<li><code>auto</code>：浏览器默认行为，等同于不使用<code>loading</code>属性。</li>
<li><code>lazy</code>：启用懒加载。</li>
<li><code>eager</code>：立即加载资源，无论它在页面上的哪个位置。</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;…&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于行内图片的懒加载，可能会导致页面布局重排，所以使用这个属性的时候，最好指定图片的高和宽。</p>
<h3 id="lt-figure-gt-，-lt-figcaption-gt"><a href="#lt-figure-gt-，-lt-figcaption-gt" class="headerlink" title="&lt;figure&gt;，&lt;figcaption&gt;"></a><code>&lt;figure&gt;</code>，<code>&lt;figcaption&gt;</code></h3><p><code>&lt;figure&gt;</code>标签可以理解为一个图像区块，将图像和相关信息封装在一起。<code>&lt;figcaption&gt;</code>是它的可选子元素，表示图像的文本描述，通常用于放置标题，可以出现多个。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/foo.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>示例图片<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了图像，<code>&lt;figure&gt;</code>还可以封装引言、代码、诗歌等等。它等于是一个将主体内容与附加信息，封装在一起的语义容器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>JavaScript 代码示例<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>const foo = &#x27;hello&#x27;;<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="响应式图像"><a href="#响应式图像" class="headerlink" title="响应式图像"></a>响应式图像</h3><p>网页在不同尺寸的设备上，都能产生良好的显示效果，叫做<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDUvcmVzcG9uc2l2ZV93ZWJfZGVzaWduLmh0bWw=">“响应式设计”<i class="fa fa-external-link-alt"></i></span>（responsive web design）。响应式设计的网页图像，就是“响应式图像”（responsive image）。</p>
<p>响应式图像的解决方案有很多，JavaScript 和 CSS 都可以实现。这里只介绍语义性最好的 HTML 方法，浏览器原生支持。</p>
<h4 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h4><p>我们知道，<code>&lt;img&gt;</code>标签用于插入网页图像，所有情况默认插入的都是同一张图像。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在桌面端和手机上，插入的都是图像文件<code>foo.jpg</code>。</p>
<p>这种处理方法固然简单，但是有三大弊端。</p>
<p><strong>（1）体积</strong></p>
<p>一般来说，桌面端显示的是大尺寸的图像，文件体积较大。手机的屏幕较小，只需要小尺寸的图像，可以节省带宽，加速网页渲染。</p>
<p><strong>（2）像素密度</strong></p>
<p>随着联网设备的增加，设备间的区别不仅发生在尺寸和规格上，还发生在用于显示的设备上。 像素密度就是区分不同显示设备的一个指标，它一般会以  PPI（Pixel Per Inch，即每英寸像素）或 DPI（每英寸点数）为计量单位。</p>
<p>桌面显示器一般是单倍像素密度，而手机的显示屏往往是多倍像素密度，即显示时多个像素合成为一个像素，这种屏幕称为 Retina 屏幕。图像文件很可能在桌面端很清晰，放到手机上会有点模糊，因为图像没有那么高的像素密度，浏览器自动把图像的每个像素复制到周围像素，满足像素密度的要求，导致图像的锐利度有所下降。</p>
<p><strong>（3）视觉风格</strong></p>
<p>桌面显示器的面积较大，图像可以容纳更多细节。手机的屏幕较小，许多细节是看不清的，需要突出重点。</p>
<img data-src="/2021/04/27/01HTML-I/%E8%A7%86%E8%A7%89%E9%A3%8E%E6%A0%BC.jpg" class="" title="视觉风格">

<img data-src="/2021/04/27/01HTML-I/%E8%A7%86%E8%A7%89%E9%A3%8E%E6%A0%BC2.jpg" class="" title="视觉风格2">

<p>上面两张图片，下方的手机图片经过裁剪以后，更突出图像重点，明显效果更好。</p>
<h4 id="srcset属性"><a href="#srcset属性" class="headerlink" title="srcset属性"></a><code>srcset</code>属性</h4><p>为了解决上面这些问题，HTML 语言提供了一套完整的解决方案。首先，<code>&lt;img&gt;</code>标签引入了<code>srcset</code>属性。</p>
<p><code>srcset</code>属性用来指定多张图像，适应不同像素密度的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，然后是像素密度的描述符。请看下面的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;foo-320w.jpg,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-480w.jpg 1.5x,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-640w.jpg 2x&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;foo-640w.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>srcset</code>属性给出了三个图像 URL，适应三种不同的像素密度。</p>
<p>图像 URL 后面的像素密度描述符，格式是像素密度倍数 + 字母<code>x</code>。<code>1x</code>表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度，选择需要加载的图像。</p>
<p>如果<code>srcset</code>属性都不满足条件，那么就加载<code>src</code>属性指定的默认图像。</p>
<h4 id="sizes属性"><a href="#sizes属性" class="headerlink" title="sizes属性"></a><code>sizes</code>属性</h4><p>像素密度的适配，只适合显示区域一样大小的图像。如果希望不同尺寸的屏幕，显示不同大小的图像，<code>srcset</code>属性就不够用了，必须搭配<code>sizes</code>属性。</p>
<p>第一步，<code>srcset</code>属性列出所有可用的图像。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;foo-160.jpg 160w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-320.jpg 320w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-640.jpg 640w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-1280.jpg 1280w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;foo-1280.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>srcset</code>属性列出四张可用的图像，每张图像的 URL 后面是一个空格，再加上宽度描述符。</p>
<p>宽度描述符就是图像原始的宽度，加上字符<code>w</code>。上例的四种图片的原始宽度分别为160像素、320像素、640像素和1280像素。</p>
<p>第二步，<code>sizes</code>属性列出不同设备的图像显示宽度。</p>
<p><code>sizes</code>属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;foo-160.jpg 160w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-320.jpg 320w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-640.jpg 640w,</span></span></span><br><span class="line"><span class="tag"><span class="string">             foo-1280.jpg 1280w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 440px) 100vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">            (max-width: 900px) 33vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">            254px&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">src</span>=<span class="string">&quot;foo-1280.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>sizes</code>属性给出了三种屏幕条件，以及对应的图像显示宽度。宽度不超过440像素的设备，图像显示宽度为100%；宽度441像素到900像素的设备，图像显示宽度为33%；宽度900像素以上的设备，图像显示宽度为<code>254px</code>。</p>
<p>第三步，浏览器根据当前设备的宽度，从<code>sizes</code>属性获得图像的显示宽度，然后从<code>srcset</code>属性找出最接近该宽度的图像，进行加载。</p>
<p>假定当前设备的屏幕宽度是<code>480px</code>，浏览器从<code>sizes</code>属性查询得到，图片的显示宽度是<code>33vw</code>（即33%），等于<code>160px</code>。<code>srcset</code>属性里面，正好有宽度等于<code>160px</code>的图片，于是加载<code>foo-160.jpg</code>。</p>
<p>如果省略<code>sizes</code>属性，那么浏览器将根据实际的图像显示宽度，从<code>srcset</code>属性选择最接近的图片。一旦使用<code>sizes</code>属性，就必须与<code>srcset</code>属性搭配使用，单独使用<code>sizes</code>属性是无效的。</p>
<h3 id="lt-picture-gt"><a href="#lt-picture-gt" class="headerlink" title="&lt;picture&gt;"></a><code>&lt;picture&gt;</code></h3><h4 id="响应式用法"><a href="#响应式用法" class="headerlink" title="响应式用法"></a>响应式用法</h4><p><code>&lt;img&gt;</code>标签的<code>srcset</code>属性和<code>sizes</code>属性分别解决了像素密度和屏幕大小的适配，但如果要同时适配不同像素密度、不同大小的屏幕，就要用到<code>&lt;picture&gt;</code>标签。</p>
<p><code>&lt;picture&gt;</code>是一个容器标签，内部使用<code>&lt;source&gt;</code>和<code>&lt;img&gt;</code>，指定不同情况下加载的图像。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 500px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;cat-vertical.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 501px)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;cat-horizontal.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;cat.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;cat&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;picture&gt;</code>标签内部有两个<code>&lt;source&gt;</code>标签和一个<code>&lt;img&gt;</code>标签。</p>
<p><code>&lt;picture&gt;</code>内部的<code>&lt;source&gt;</code>标签，主要使用<code>media</code>属性和<code>srcset</code>属性。<code>media</code>属性给出媒体查询表达式，<code>srcset</code>属性就是<code>&lt;img&gt;</code>标签的<code>srcset</code>属性，给出加载的图像文件。<code>sizes</code>属性其实这里也可以用，但由于有了<code>media</code>属性，就没有必要了。</p>
<p>浏览器按照<code>&lt;source&gt;</code>标签出现的顺序，依次判断当前设备是否满足<code>media</code>属性的媒体查询表达式，如果满足就加载<code>srcset</code>属性指定的图片文件，并且不再执行后面的<code>&lt;source&gt;</code>标签和<code>&lt;img&gt;</code>标签。</p>
<p><code>&lt;img&gt;</code>标签是默认情况下加载的图像，用来满足上面所有<code>&lt;source&gt;</code>都不匹配的情况，或者不支持<code>&lt;picture&gt;</code>的老式浏览器。</p>
<p>上面例子中，设备宽度如果不超过<code>500px</code>，就加载竖屏的图像，否则加载横屏的图像。</p>
<p>下面给出一个例子，同时考虑屏幕尺寸和像素密度的适配。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;homepage-person@desktop.png,</span></span></span><br><span class="line"><span class="tag"><span class="string">                  homepage-person@desktop-2x.png 2x&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">media</span>=<span class="string">&quot;(min-width: 990px)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;homepage-person@tablet.png,</span></span></span><br><span class="line"><span class="tag"><span class="string">                  homepage-person@tablet-2x.png 2x&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">media</span>=<span class="string">&quot;(min-width: 750px)&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;homepage-person@mobile.png,</span></span></span><br><span class="line"><span class="tag"><span class="string">               homepage-person@mobile-2x.png 2x&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">alt</span>=<span class="string">&quot;Shopify Merchant, Corrine Anestopoulos&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;source&gt;</code>标签的<code>media</code>属性给出屏幕尺寸的适配条件，每个条件都用<code>srcset</code>属性，再给出两种像素密度的图像 URL。</p>
<h4 id="图像格式的选择"><a href="#图像格式的选择" class="headerlink" title="图像格式的选择"></a>图像格式的选择</h4><p>除了响应式图像，<code>&lt;picture&gt;</code>标签还可以用来选择不同格式的图像。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图像，否则加载 PNG 图像。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;logo.xml&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;logo.webp&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;ACME Corp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;source&gt;</code>标签的<code>type</code>属性给出图像的 MIME 类型，<code>srcset</code>是对应的图像 URL。</p>
<p>浏览器按照<code>&lt;source&gt;</code>标签出现的顺序，依次检查是否支持<code>type</code>属性指定的图像格式，如果支持就加载图像，并且不再检查后面的<code>&lt;source&gt;</code>标签了。上面例子中，图像加载优先顺序依次为 svg 格式、webp 格式和 png 格式。</p>
<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><p>链接（hyperlink）是互联网的核心。它允许用户在页面上，从一个网址跳转到另一个网址，从而把所有资源联系在一起。</p>
<p>URL 是链接指向的地址。链接不仅可以指向另一个网页，也可以指向文本、图像、文件等资源。可以这样说，所有互联网上的资源，都可以通过链接访问。</p>
<h3 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt;a&gt;"></a><code>&lt;a&gt;</code></h3><p>链接通过<code>&lt;a&gt;</code>（Anchor，简写为 a）标签表示，用户点击后，浏览器会跳转到指定的网址。下面就是一个典型的链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://wikipedia.org/&quot;</span>&gt;</span>维基百科<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码就定义了一个超级链接。浏览器显示“维基百科”，文字下面默认会有下划线，表示这是一个链接。用户点击后，浏览器跳转到<code>href</code>属性指定的网址。</p>
<p><code>&lt;a&gt;</code>标签内部不仅可以放置文字，也可以放置其他元素，比如段落、图像、多媒体等等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com/foo.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;a&gt;</code>标签内部就是一个图像。用户点击图像，就会跳转到指定网址。</p>
<p>你可以在其他文本元素内嵌套链接。通常，文本是被包裹在 <code>p</code> 元素内。<code>a</code> 元素内的文本叫作锚文本，会显示为一个可以点击的链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Here&#x27;s a <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://freecodecamp.org&quot;</span>&gt;</span> link to freecodecamp.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span> for you to follow.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时你想为网站添加一个 <code>a</code> 元素，但还不确定要将它链接到哪里。可用 <code>#</code> 作为链接占位符。</p>
<p>屏幕阅读器用户可以选择其设备读取的内容的类型，这包括跳转到（或跳过）标志标签，以便跳转到主要内容，或者从标题中获取页面摘要，还可以选择只听取页面中的有效链接。</p>
<p>屏幕阅读器通过阅读链接文本或者锚点标签（<code>a</code>）之间的内容来完成这个操作。拥有 “click here” 或者 “read more” 列表并没有什么用处。相反地，应该在<code>a</code>标签中使用简洁的描述性语言来为用户提供更多的信息。</p>
<p><code>&lt;a&gt;</code>标签有如下属性。</p>
<p><strong>（1）href</strong></p>
<p><code>href</code>（hypertext refrence）属性给出链接指向的网址。读作“喝瑞夫”。它的值应该是一个 URL 或者锚点。</p>
<p>上文已经给出了完整 URL 的例子，下面是锚点的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#demo&quot;</span>&gt;</span>示例<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>href</code>属性的值是<code>#</code>加上锚点名称。点击后，浏览器会自动滚动，停在当前页面里面<code>demo</code>锚点所在的位置。</p>
<p><strong>（2）hreflang</strong></p>
<p><code>hreflang</code>属性给出链接指向的网址所使用的语言，纯粹是提示性的，没有实际功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;https://www.example.com&quot;</span><br><span class="line">  hreflang=&quot;en&quot;</span><br><span class="line">&gt;示例网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，<code>href</code>属性指向的网址的语言是英语。</p>
<p>该属性的值跟通用属性<code>lang</code>一样。</p>
<p><strong>（3）title</strong></p>
<p><code>title</code>属性给出链接的说明信息。鼠标悬停在链接上方时，浏览器会将这个属性的值，以提示块的形式显示出来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;https://www.example.com/&quot;</span><br><span class="line">  title=&quot;hello&quot;</span><br><span class="line">&gt;示例<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户鼠标停留在链接上面，会出现文字提示<code>hello</code>。</p>
<p><strong>（4）target</strong></p>
<p><code>target</code>属性指定如何展示打开的链接。它可以是在指定的窗口打开，也可以在<code>&lt;iframe&gt;</code>里面打开。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://foo.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;test&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://bar.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;test&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，两个链接都在名叫<code>test</code>的窗口打开。首先点击链接<code>foo</code>，浏览器发现没有叫做<code>test</code>的窗口，就新建一个窗口，起名为<code>test</code>，在该窗口打开<code>foo.com</code>。然后，用户又点击链接<code>bar</code>，由于已经存在<code>test</code>窗口，浏览器就在该窗口打开<code>bar.com</code>，取代里面已经打开的<code>foo.com</code>。</p>
<p><code>target</code>属性的值也可以是以下四个关键字之一。</p>
<ul>
<li><code>_self</code>：当前窗口打开，这是默认值。</li>
<li><code>_blank</code>：新窗口打开。</li>
<li><code>_parent</code>：上层窗口打开，这通常用于从父窗口打开的子窗口，或者<code>&lt;iframe&gt;</code>里面的链接。如果当前窗口没有上层窗口，这个值等同于<code>_self</code>。</li>
<li><code>_top</code>：顶层窗口打开。如果当前窗口就是顶层窗口，这个值等同于<code>_self</code>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;https://www.example.com&quot;</span><br><span class="line">  target=&quot;_blank&quot;</span><br><span class="line">&gt;示例链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码点击后，浏览器会新建一个窗口，在该窗口打开链接，并且新窗口没有名字。</p>
<p>注意，使用<code>target</code>属性的时候，最好跟<code>rel=&quot;noreferrer&quot;</code>一起使用，这样可以避免安全风险。</p>
<p><strong>（5）rel</strong></p>
<p><code>rel</code>属性说明链接与当前页面的关系。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;help.html&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;help&quot;</span>&gt;</span>帮助<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>rel</code>属性，说明链接是当前页面的帮助文档。</p>
<p>下面是一些常见的<code>rel</code>属性的值。</p>
<ul>
<li><code>alternate</code>：当前文档的另一种形式，比如翻译。</li>
<li><code>author</code>：作者链接。</li>
<li><code>bookmark</code>：用作书签的永久地址。</li>
<li><code>external</code>：当前文档的外部参考文档。</li>
<li><code>help</code>：帮助链接。</li>
<li><code>license</code>：许可证链接。</li>
<li><code>next</code>：系列文档的下一篇。</li>
<li><code>nofollow</code>：告诉搜索引擎忽略该链接，主要用于用户提交的内容，防止有人企图通过添加链接，提高该链接的搜索排名。</li>
<li><code>noreferrer</code>：告诉浏览器打开链接时，不要将当前网址作为 HTTP 头信息的<code>Referer</code>字段发送出去，这样可以隐藏点击的来源。</li>
<li><code>noopener</code>：告诉浏览器打开链接时，不让链接窗口通过 JavaScript 的<code>window.opener</code>属性引用原始窗口，这样就提高了安全性。</li>
<li><code>prev</code>：系列文档的上一篇。</li>
<li><code>search</code>：文档的搜索链接。</li>
<li><code>tag</code>：文档的标签链接。</li>
</ul>
<p><strong>（6）referrerpolicy</strong></p>
<p><code>referrerpolicy</code>属性用于精确设定点击链接时，浏览器发送 HTTP 头信息的<code>Referer</code>字段的行为。</p>
<p>该属性可以取下面八个值：<code>no-referrer</code>、<code>no-referrer-when-downgrade</code>、<code>origin</code>、<code>origin-when-cross-origin</code>、<code>unsafe-url</code>、<code>same-origin</code>、<code>strict-origin</code>、<code>strict-origin-when-cross-origin</code>。</p>
<p>其中，<code>no-referrer</code>表示不发送<code>Referer</code>字段，<code>same-origin</code>表示同源时才发送<code>Referer</code>字段，<code>origin</code>表示只发送源信息（协议+域名+端口）。其他几项的解释，请查阅 HTTP 文档。</p>
<p><strong>（7）ping</strong></p>
<p><code>ping</code>属性指定一个网址，用户点击的时候，会向该网址发出一个 POST 请求，通常用于跟踪用户的行为。</p>
<p><strong>（8）type</strong></p>
<p><code>type</code>属性给出链接 URL 的 MIME 类型，比如到底是网页，还是图像或文件。它也是纯粹提示性的属性，没有实际功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;smile.jpg&quot;</span><br><span class="line">  type=&quot;image/jpeg&quot;</span><br><span class="line">&gt;示例图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>type</code>属性提示这是一张图片。</p>
<p><strong>（9）download</strong></p>
<p><code>download</code>属性表明当前链接用于下载，而不是跳转到另一个 URL。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo.txt&quot;</span> <span class="attr">download</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码点击后，会出现下载对话框。</p>
<p>注意，<code>download</code>属性只在链接与网址同源时，才会生效。也就是说，链接应该与网址属于同一个网站。</p>
<p>如果<code>download</code>属性设置了值，那么这个值就是下载的文件名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;foo.exe&quot;</span><br><span class="line">  download=&quot;bar.exe&quot;</span><br><span class="line">&gt;点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，下载文件的原始文件名是<code>foo.exe</code>。点击后，下载对话框提示的文件名是<code>bar.exe</code>。</p>
<p>注意，如果链接点击后，服务器的 HTTP 回应的头信息设置了<code>Content-Disposition</code>字段，并且该字段的值与<code>download</code>属性不一致，那么该字段优先，下载时将显示其设置的文件名。</p>
<p><code>download</code>属性还有一个用途，就是有些地址不是真实网址，而是数据网址，比如<code>data:</code>开头的网址。这时，<code>download</code>属性可以为虚拟网址指定下载的文件名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;data:,Hello%2C%20World!&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面链接点击后，会打开一个虚拟网页，上面显示<code>Hello World!</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;data:,Hello%2C%20World!&quot;</span><br><span class="line">  download=&quot;hello.txt&quot;</span><br><span class="line">&gt;点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面链接点击后，下载的<code>hello.txt</code>文件内容就是“Hello, World!”。</p>
<h3 id="邮件链接"><a href="#邮件链接" class="headerlink" title="邮件链接"></a>邮件链接</h3><p>链接也可以指向一个邮件地址，使用<code>mailto</code>协议。用户点击后，浏览器会打开本机默认的邮件程序，让用户向指定的地址发送邮件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:contact@example.com&quot;</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，链接就指向邮件地址。点击后，浏览器会打开一个邮件地址，让你可以向<code>contact@example.com</code>发送邮件。</p>
<p>除了邮箱，邮件协议还允许指定其他几个邮件要素。</p>
<ul>
<li><code>subject</code>：主题</li>
<li><code>cc</code>：抄送</li>
<li><code>bcc</code>：密送</li>
<li><code>body</code>：邮件内容</li>
</ul>
<p>使用方法是将这些邮件要素，以查询字符串的方式，附加在邮箱地址后面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  href=&quot;mailto:foo@bar.com?cc=test@test.com&amp;subject=The%20subject&amp;body=The%20body&quot;</span><br><span class="line">&gt;发送邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，邮件链接里面不仅包含了邮箱地址，还包含了<code>cc</code>、<code>subject</code>、<code>body</code>等邮件要素。这些要素的值需要经过 URL 转义，比如空格转成<code>%20</code>。</p>
<p>不指定邮箱也是允许的，就像下面这样。这时用户自己在邮件程序里面，填写想要发送的邮箱，通常用于邮件分享网页。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:&quot;</span>&gt;</span>告诉朋友<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="电话链接"><a href="#电话链接" class="headerlink" title="电话链接"></a>电话链接</h3><p>如果是手机浏览的页面，还可以使用<code>tel</code>协议，创建电话链接。用户点击该链接，会唤起电话，可以进行拨号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tel:13312345678&quot;</span>&gt;</span>13312345678<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在手机中，点击链接会唤起拨号界面，可以直接拨打指定号码。</p>
<h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a><code>&lt;link&gt;</code></h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>&lt;link&gt;</code>标签主要用于将当前网页与相关的外部资源联系起来，通常放在<code>&lt;head&gt;</code>元素里面。最常见的用途就是加载 CSS 样式表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;theme.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码为网页加载样式表<code>theme.css</code>。</p>
<p>除了默认样式表，网页还可以加载替代样式表，即默认不生效、需要用户手动切换的样式表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;default.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Default Style&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;fancy.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Fancy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;basic.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Basic&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>default.css</code>是默认样式表，默认就会生效。<code>fancy.css</code>和<code>basic.css</code>是替换样式表（<code>rel=&quot;alternate stylesheet&quot;</code>），默认不生效。<code>title</code>属性在这里是必需的，用来在浏览器菜单里面列出这些样式表的名字，供用户选择，以替代默认样式表。</p>
<p><code>&lt;link&gt;</code>还可以加载网站的 favicon 图标文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>手机访问时，网站通常需要提供不同分辨率的图标文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;114x114&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon114.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;72x72&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon72.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定 iPhone 设备需要的114像素和72像素的图标。</p>
<p><code>&lt;link&gt;</code>也用于提供文档的相关链接，比如下面是给出文档的 RSS Feed 地址。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/atom+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/blog/news/atom&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="rel-属性"><a href="#rel-属性" class="headerlink" title="rel 属性"></a>rel 属性</h4><p><code>rel</code>属性表示外部资源与当前文档之间的关系，是<code>&lt;link&gt;</code>标签的必需属性。它可以但不限于取以下值。</p>
<ul>
<li><code>alternate</code>：文档的另一种表现形式的链接，比如打印版。</li>
<li><code>author</code>：文档作者的链接。</li>
<li><code>dns-prefetch</code>：要求浏览器提前执行指定网址的 DNS 查询。</li>
<li><code>help</code>：帮助文档的链接。</li>
<li><code>icon</code>：加载文档的图标文件。</li>
<li><code>license</code>：许可证链接。</li>
<li><code>next</code>：系列文档下一篇的链接。</li>
<li><code>pingback</code>：接收当前文档 pingback 请求的网址。</li>
<li><code>preconnect</code>：要求浏览器提前与给定服务器，建立 HTTP 连接。</li>
<li><code>prefetch</code>：要求浏览器提前下载并缓存指定资源，供下一个页面使用。它的优先级较低，浏览器可以不下载。</li>
<li><code>preload</code>：要求浏览器提前下载并缓存指定资源，当前页面稍后就会用到。它的优先级较高，浏览器必须立即下载。</li>
<li><code>prerender</code>：要求浏览器提前渲染指定链接。这样的话，用户稍后打开该链接，就会立刻显示，感觉非常快。</li>
<li><code>prev</code>：表示当前文档是系列文档的一篇，这里给出上一篇文档的链接。</li>
<li><code>search</code>：提供当前网页的搜索链接。</li>
<li><code>stylesheet</code>：加载一张样式表。</li>
</ul>
<p>下面是一些示例。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作者信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;author&quot;</span> <span class="attr">href</span>=<span class="string">&quot;humans.txt&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 版权信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;license&quot;</span> <span class="attr">href</span>=<span class="string">&quot;copyright.html&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 另一个语言的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://es.example.com/&quot;</span> <span class="attr">hreflang</span>=<span class="string">&quot;es&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 联系方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;me&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com/profiles/someone&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;me&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mailto:name@example.com&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;me&quot;</span> <span class="attr">href</span>=<span class="string">&quot;sms:+15035550125&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 历史资料 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;archives&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/archives/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;index&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/article/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 导航 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;first&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/article/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;last&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/article/?page=42&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prev&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/article/?page=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;next&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/article/?page=3&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="资源的预加载"><a href="#资源的预加载" class="headerlink" title="资源的预加载"></a>资源的预加载</h4><p>某些情况下，你需要浏览器预加载某些资源，也就是先把资源缓存下来，等到使用的时候，就不用再从网上下载了，立即就能使用。预处理指令可以做到这一点。</p>
<p>预加载主要有下面五种类型。</p>
<p>（1）<code>&lt;link rel=&quot;preload&quot;&gt;</code></p>
<p><code>&lt;link rel=&quot;preload&quot;&gt;</code>告诉浏览器尽快下载并缓存资源（如脚本或样式表），该指令优先级较高，浏览器肯定会执行。当加载页面几秒钟后需要该资源时，它会很有用。下载后，浏览器不会对资源执行任何操作，脚本未执行，样式表未应用。它只是缓存，当其他东西需要它时，它立即可用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;image.png&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>rel=&quot;preload&quot;</code>除了优先级较高，还有两个优点：一是允许指定预加载资源的类型，二是允许<code>onload</code>事件的回调函数。下面是<code>rel=&quot;preload&quot;</code>配合<code>as</code>属性，告诉浏览器预处理资源的类型，以便正确处理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码要求浏览器提前下载并缓存<code>style.css</code>和<code>main.js</code>。</p>
<p><code>as</code>属性指定加载资源的类型，它的值一般有下面几种。</p>
<ul>
<li>“script”</li>
<li>“style”</li>
<li>“image”</li>
<li>“media”</li>
<li>“document”</li>
</ul>
<p>如果不指定<code>as</code>属性，或者它的值是浏览器不认识的，那么浏览器会以较低的优先级下载这个资源。</p>
<p>有时还需要<code>type</code>属性，进一步明确 MIME 类型。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;sintel-short.mp4&quot;</span> <span class="attr">as</span>=<span class="string">&quot;video&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码要求浏览器提前下载视频文件，并且说明这是 MP4 编码。</p>
<p>下面是预下载字体文件的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;font.woff2&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">type</span>=<span class="string">&quot;font/woff2&quot;</span> <span class="attr">crossorigin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，所有预下载的资源，只是下载到浏览器的缓存，并没有执行。如果希望资源预下载后立刻执行，可以参考下面的写法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> <span class="attr">href</span>=<span class="string">&quot;async_style.css&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;this.rel=&#x27;stylesheet&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>onload</code>指定的回调函数会在脚本下载完成后执行，立即插入页面。</p>
<p>（2）<code>&lt;link rel=&quot;prefetch&quot;&gt;</code></p>
<p><code>&lt;link rel=&quot;prefetch&quot;&gt;</code>的使用场合是，如果后续的页面需要某个资源，并且希望预加载该资源，以便加速页面渲染。该指令不是强制性的，优先级较低，浏览器不一定会执行。这意味着，浏览器可以不下载该资源，比如连接速度很慢时。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（3）<code>&lt;link rel=&quot;preconnect&quot;&gt;</code></p>
<p><code>&lt;link rel=&quot;preconnect&quot;&gt;</code>要求浏览器提前与某个域名建立 TCP 连接。当你知道，很快就会请求该域名时，这会很有帮助。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（4）<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code></p>
<p><code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>要求浏览器提前执行某个域名的 DNS 解析。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（5）<code>&lt;link rel=&quot;prerender&quot;&gt;</code></p>
<p><code>&lt;link rel=&quot;prerender&quot;&gt;</code>要求浏览器加载某个网页，并且提前渲染它。用户点击指向该网页的链接时，就会立即呈现该页面。如果确定用户下一步会访问该页面，这会很有帮助。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="media-属性"><a href="#media-属性" class="headerlink" title="media 属性"></a>media 属性</h4><p><code>media</code>属性给出外部资源生效的媒介条件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;mobile.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (max-width: 600px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，打印时加载<code>print.css</code>，移动设备访问时（设备宽度小于600像素）加载<code>mobile.css</code>。</p>
<p>下面是使用<code>media</code>属性实现条件加载的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span> <span class="attr">href</span>=<span class="string">&quot;map.png&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 600px)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;map.js&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 601px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果屏幕宽度在600像素以下，则只加载第一个资源，否则就加载第二个资源。</p>
<h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p><code>&lt;link&gt;</code>标签的其他属性如下。</p>
<ul>
<li><code>crossorigin</code>：加载外部资源的跨域设置。</li>
<li><code>href</code>：外部资源的网址。</li>
<li><code>referrerpolicy</code>：加载时<code>Referer</code>头信息字段的处理方法。</li>
<li><code>as</code>：<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>时，设置外部资源的类型。</li>
<li><code>type</code>：外部资源的 MIME 类型，目前仅用于<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>的情况。</li>
<li><code>title</code>：加载样式表时，用来标识样式表的名称。</li>
<li><code>sizes</code>：用来声明图标文件的尺寸，比如加载苹果手机的图标文件。</li>
</ul>
<h3 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h3><p><code>&lt;script&gt;</code>用于加载脚本代码，目前主要是加载 JavaScript 代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码嵌入网页，会立即执行。</p>
<p><code>&lt;script&gt;</code>也可以加载外部脚本，<code>src</code>属性给出外部脚本的地址。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;javascript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会加载<code>javascript.js</code>脚本文件，并执行。指定了 src 属性的script元素标签内不应该再有嵌入的脚本。</p>
<p><code>type</code>属性给出脚本的类型，默认是 JavaScript 代码，所以可省略。完整的写法其实是下面这样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;javascript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>type</code>属性也可以设成<code>module</code>，表示这是一个 ES6 模块，不是传统脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于那些不支持 ES6 模块的浏览器，可以设置<code>nomodule</code>属性。支持 ES6 模块的浏览器，会不加载指定的脚本。这个属性通常与<code>type=&quot;module&quot;</code>配合使用，作为老式浏览器的回退方案。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;fallback.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;script&gt;</code>还有下面一些其他属性，大部分跟 JavaScript 语言有关，可以参考相关的 JavaScript 教程。</p>
<ul>
<li><code>async</code>：该属性指定 JavaScript 代码为异步执行，不是造成阻塞效果，JavaScript 代码默认是同步执行。</li>
<li><code>defer</code>：该属性指定 JavaScript 代码不是立即执行，而是页面解析完成后执行。</li>
<li><code>crossorigin</code>：如果采用这个属性，就会采用跨域的方式加载外部脚本，即 HTTP 请求的头信息会加上<code>origin</code>字段。</li>
<li><code>integrity</code>：给出外部脚本的哈希值，防止脚本被篡改。只有哈希值相符的外部脚本，才会执行。</li>
<li><code>nonce</code>：一个密码随机数，由服务器在 HTTP 头信息里面给出，每次加载脚本都不一样。它相当于给出了内嵌脚本的白名单，只有在白名单内的脚本才能执行。</li>
<li><code>referrerpolicy</code>：HTTP 请求的<code>Referer</code>字段的处理方法。</li>
</ul>
<h3 id="lt-noscript-gt"><a href="#lt-noscript-gt" class="headerlink" title="&lt;noscript&gt;"></a><code>&lt;noscript&gt;</code></h3><p><code>&lt;noscript&gt;</code>标签用于浏览器不支持或关闭 JavaScript 时，所要显示的内容。用户关闭 JavaScript 可能是为了节省带宽，以延长手机电池寿命，或者为了防止追踪，保护隐私。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">  您的浏览器不能执行 JavaScript 语言，页面无法正常显示。</span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码，只有浏览器不能执行 JavaScript 代码时才会显示，否则就不会显示。</p>
<h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><p>除了图像，网页还可以放置视频和音频。</p>
<h3 id="lt-video-gt"><a href="#lt-video-gt" class="headerlink" title="&lt;video&gt;"></a><code>&lt;video&gt;</code></h3><p><code>&lt;video&gt;</code>标签是一个块级元素，用于放置视频。如果浏览器支持加载的视频格式，就会显示一个播放器，否则显示<code>&lt;video&gt;</code>内部的子元素。也可以将 <code>&lt;video&gt;</code>  标签用于音频内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;example.mp4&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频，请下载<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;example.mp4&quot;</span>&gt;</span>视频文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果浏览器不支持该种格式的视频，就会显示<code>&lt;video&gt;</code>内部的文字提示。</p>
<p><code>&lt;video&gt;</code>有以下属性。</p>
<ul>
<li><code>src</code>：视频文件的网址。</li>
<li><code>controls</code>：播放器是否显示控制栏。该属性是布尔属性，不用赋值，只要写上属性名，就表示打开。如果不想使用浏览器默认的播放器，而想使用自定义播放器，就不要使用该属性。</li>
<li><code>width</code>：视频播放器的宽度，单位像素。</li>
<li><code>height</code>：视频播放器的高度，单位像素。</li>
<li><code>autoplay</code>：视频是否自动播放，该属性为布尔属性。</li>
<li><code>loop</code>：视频是否循环播放，该属性为布尔属性。</li>
<li><code>muted</code>：是否默认静音，该属性为布尔属性。</li>
<li><code>poster</code>：视频播放器的封面图片的 URL。</li>
<li><code>preload</code>：视频播放之前，是否缓冲视频文件。这个属性仅适合没有设置<code>autoplay</code>的情况。它有三个值，分别是<code>none</code>（不缓冲）、<code>metadata</code>（仅仅缓冲视频文件的元数据）、<code>auto</code>（可以缓冲整个文件）。</li>
<li><code>playsinline</code>：iPhone 的 Safari 浏览器播放视频时，会自动全屏，该属性可以禁止这种行为。该属性为布尔属性。</li>
<li><code>crossorigin</code>：是否采用跨域的方式加载视频。它可以取两个值，分别是<code>anonymous</code>（跨域请求时，不发送用户凭证，主要是 Cookie），<code>use-credentials</code>（跨域时发送用户凭证）。</li>
<li><code>currentTime</code>：指定当前播放位置（双精度浮点数，单位为秒）。如果尚未开始播放，则会从这个属性指定的位置开始播放。</li>
<li><code>duration</code>：该属性只读，指示时间轴上的持续播放时间（总长度），值为双精度浮点数（单位为秒）。如果是流媒体，没有已知的结束时间，属性值为<code>+Infinity</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">       <span class="attr">poster</span>=<span class="string">&quot;poster.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，视频播放器的大小是 400 x 400，会自动播放和循环播放，并且静音，还带有封面图。这是网站首页背景视频的常见写法。</p>
<p>HTML 标准没有规定浏览器需要支持哪些视频格式，完全由浏览器厂商自己决定。为了避免浏览器不支持视频格式，可以使用<code>&lt;source&gt;</code>标签，放置同一个视频的多种格式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;example.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;example.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频，请下载<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;example.mp4&quot;</span>&gt;</span>视频文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;source&gt;</code>标签的<code>type</code>属性的值是视频文件的 MIME 类型，上例指定了两种格式的视频文件：MP4 和 WebM。如果浏览器支持 MP4，就加载 MP4 格式的视频，不再往下执行了。如果不支持 MP4，就检查是否支持 WebM，如果还是不支持，则显示提示。</p>
<h3 id="lt-audio-gt"><a href="#lt-audio-gt" class="headerlink" title="&lt;audio&gt;"></a><code>&lt;audio&gt;</code></h3><p><code>&lt;audio&gt;</code>标签是一个块级元素，用于放置音频，用法与<code>&lt;video&gt;</code>标签基本一致。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;foo.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;foo.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持 HTML5 音频，请直接下载<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;foo.mp3&quot;</span>&gt;</span>音频文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;audio&gt;</code>标签内部使用<code>&lt;source&gt;</code>标签，指定了两种音频格式：优先使用 MP3 格式，如果浏览器不支持则使用 Ogg 格式。如果浏览器不能播放音频，则提供下载链接。</p>
<p><code>&lt;audio&gt;</code>标签的属性与<code>&lt;video&gt;</code>标签类似。</p>
<ul>
<li><code>autoplay</code>：是否自动播放，布尔属性。声明该属性，音频会尽快自动播放，不会等待整个音频文件下载完成。 </li>
<li><code>controls</code>：是否显示播放工具栏，布尔属性。如果不设置，浏览器不显示播放界面，通常用于背景音乐。</li>
<li><code>crossorigin</code>：是否使用跨域方式请求。</li>
<li><code>loop</code>：是否循环播放，布尔属性。</li>
<li><code>muted</code>：是否静音，布尔属性。</li>
<li><code>preload</code>：音频文件的缓冲设置。<ul>
<li>让开发者自行思考来示意浏览器使用何种加载方式以达到最好的用户体验。不同浏览器会有自己的默认值，规范建议的默认值为 metadata。<ul>
<li><code>none</code>: 示意用户可能不会播放该音频，或者服务器希望节省带宽；换句话说，该音频不会被缓存；</li>
<li><code>metadata</code>: 示意即使用户可能不会播放该音频，但获取元数据 (例如音频长度) 还是有必要的。</li>
<li><code>auto</code>: 示意用户可能会播放音频；换句话说，如果有必要，整个音频都将被加载，即使用户不期望使用。</li>
<li><em>空字符串</em> : 等效于<code>auto</code>属性。</li>
</ul>
</li>
</ul>
</li>
<li><code>src</code>：音频文件网址。</li>
</ul>
<h3 id="lt-track-gt"><a href="#lt-track-gt" class="headerlink" title="&lt;track&gt;"></a><code>&lt;track&gt;</code></h3><p><code>&lt;track&gt;</code>标签用于指定视频的字幕，格式是 WebVTT （<code>.vtt</code>文件），放置在<code>&lt;video&gt;</code>标签内部。它是一个单独使用的标签，没有结束标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">src</span>=<span class="string">&quot;sample.mp4&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">track</span> <span class="attr">label</span>=<span class="string">&quot;英文&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">src</span>=<span class="string">&quot;subtitles_en.vtt&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">track</span> <span class="attr">label</span>=<span class="string">&quot;中文&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">src</span>=<span class="string">&quot;subtitles_cn.vtt&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;cn&quot;</span> <span class="attr">default</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定视频文件的英文字幕和中文字幕。</p>
<p><code>&lt;track&gt;</code>标签有以下属性。</p>
<ul>
<li><code>label</code>：播放器显示的字幕名称，供用户选择。</li>
<li><code>kind</code>：字幕的类型，默认是<code>subtitles</code>，表示将原始声音成翻译外国文字，比如英文视频提供中文字幕。另一个常见的值是<code>captions</code>，表示原始声音的文字描述，通常是视频原始使用的语言，比如英文视频提供英文字幕。</li>
<li><code>src</code>：vtt 字幕文件的网址。</li>
<li><code>srclang</code>：字幕的语言，必须是有效的语言代码。</li>
<li><code>default</code>：是否默认打开，布尔属性。</li>
</ul>
<h3 id="lt-source-gt"><a href="#lt-source-gt" class="headerlink" title="&lt;source&gt;"></a><code>&lt;source&gt;</code></h3><p><code>&lt;source&gt;</code>标签用于<code>&lt;picture&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>的内部，用于指定一项外部资源。单标签是单独使用的，没有结束标签。</p>
<p>它有如下属性，具体示例请参见相应的容器标签。</p>
<ul>
<li><code>type</code>：指定外部资源的 MIME 类型。</li>
<li><code>src</code>：指定源文件，用于<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>。</li>
<li><code>srcset</code>：指定不同条件下加载的图像文件，用于<code>&lt;picture&gt;</code>。</li>
<li><code>media</code>：指定媒体查询表达式，用于<code>&lt;picture&gt;</code>。</li>
<li><code>sizes</code>：指定不同设备的显示大小，用于<code>&lt;picture&gt;</code>，必须跟<code>srcset</code>搭配使用。</li>
</ul>
<h3 id="lt-embed-gt"><a href="#lt-embed-gt" class="headerlink" title="&lt;embed&gt;"></a><code>&lt;embed&gt;</code></h3><p><code>&lt;embed&gt;</code>标签用于嵌入外部内容，这个外部内容通常由浏览器插件负责控制。由于浏览器的默认插件都不一致，很可能不是所有浏览器的用户都能访问这部分内容，建议谨慎使用。</p>
<p>下面是嵌入视频播放器的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">src</span>=<span class="string">&quot;/media/examples/flower.mp4&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">width</span>=<span class="string">&quot;250&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码嵌入的视频，将由浏览器插件负责控制。如果浏览器没有安装 MP4 插件，视频就无法播放。</p>
<p><code>&lt;embed&gt;</code>标签具有如下的通用属性。</p>
<ul>
<li><code>height</code>：显示高度，单位为像素，不允许百分比。</li>
<li><code>width</code>：显示宽度，单位为像素，不允许百分比。</li>
<li><code>src</code>：嵌入的资源的 URL。</li>
<li><code>type</code>：嵌入资源的 MIME 类型。</li>
</ul>
<p>浏览器通过<code>type</code>属性得到嵌入资源的 MIME 类型，一旦该种类型已经被某个插件注册了，就会启动该插件，负责处理嵌入的资源。</p>
<p>下面是 QuickTime 插件播放 MOV 视频文件的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">type</span>=<span class="string">&quot;video/quicktime&quot;</span> <span class="attr">src</span>=<span class="string">&quot;movie.mov&quot;</span> <span class="attr">width</span>=<span class="string">&quot;640&quot;</span> <span class="attr">height</span>=<span class="string">&quot;480&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是启动 Flash 插件的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;whoosh.swf&quot;</span> <span class="attr">quality</span>=<span class="string">&quot;medium&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">bgcolor</span>=<span class="string">&quot;#ffffff&quot;</span> <span class="attr">width</span>=<span class="string">&quot;550&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;whoosh&quot;</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">allowScriptAccess</span>=<span class="string">&quot;sameDomain&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">allowFullScreen</span>=<span class="string">&quot;false&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">pluginspage</span>=<span class="string">&quot;http://www.macromedia.com/go/getflashplayer&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果浏览器没有安装 Flash 插件，就会提示去<code>pluginspage</code>属性指定的网址下载。</p>
<h3 id="lt-object-gt-，-lt-param-gt"><a href="#lt-object-gt-，-lt-param-gt" class="headerlink" title="&lt;object&gt;，&lt;param&gt;"></a><code>&lt;object&gt;</code>，<code>&lt;param&gt;</code></h3><p><code>&lt;object&gt;</code>标签作用跟<code>&lt;embed&gt;</code>相似，也是插入外部资源，由浏览器插件处理。它可以视为<code>&lt;embed&gt;</code>的替代品，有标准化行为，只限于插入少数几种通用资源，没有历史遗留问题，因此更推荐使用。</p>
<p>下面是插入 PDF 文件的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">&quot;application/pdf&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">data</span>=<span class="string">&quot;/media/examples/In-CC0.pdf&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;250&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果浏览器安装了 PDF 插件，就会在网页显示 PDF 浏览窗口。</p>
<p><code>&lt;object&gt;</code>具有如下的通用属性。</p>
<ul>
<li><code>data</code>：嵌入的资源的 URL。</li>
<li><code>form</code>：当前网页中相关联表单的<code>id</code>属性（如果有的话）。</li>
<li><code>height</code>：资源的显示高度，单位为像素，不能使用百分比。</li>
<li><code>width</code>：资源的显示宽度，单位为像素，不能使用百分比。</li>
<li><code>type</code>：资源的 MIME 类型。</li>
<li><code>typemustmatch</code>：布尔属性，表示<code>data</code>属性与<code>type</code>属性是否必须匹配。</li>
</ul>
<p>下面是插入 Flash 影片的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;movie.swf&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;object&gt;</code>标签是一个容器元素，内部可以使用<code>&lt;param&gt;</code>标签，给出插件所需要的运行参数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;movie.swf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p><code>&lt;iframe&gt;</code>标签用于在网页里面嵌入其他网页。</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>&lt;iframe&gt;</code>标签生成一个指定区域，在该区域中嵌入其他网页。它是一个容器元素，如果浏览器不支持<code>&lt;iframe&gt;</code>，就会显示内部的子元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">allowfullscreen</span> <span class="attr">sandbox</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>点击打开嵌入页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在当前网页嵌入<code>https://www.example.com</code>，显示区域的宽度是<code>100%</code>，高度是<code>500</code>像素。如果当前浏览器不支持<code>&lt;iframe&gt;</code>，则会显示一个链接，让用户点击。</p>
<p>浏览器普遍支持<code>&lt;iframe&gt;</code>，所以内部的子元素可以不写。</p>
<p><code>&lt;iframe&gt;</code>的属性如下。</p>
<ul>
<li><code>allowfullscreen</code>：允许嵌入的网页全屏显示，需要全屏 API 的支持。</li>
<li><code>frameborder</code>：是否绘制边框，<code>0</code>为不绘制，<code>1</code>为绘制（默认值）。建议尽量少用这个属性，而是在 CSS 里面设置样式。</li>
<li><code>src</code>：嵌入的网页的 URL。</li>
<li><code>width</code>：显示区域的宽度。</li>
<li><code>height</code>：显示区域的高度。</li>
<li><code>sandbox</code>：设置嵌入的网页的权限。</li>
<li><code>importance</code>：浏览器下载嵌入的网页的优先级，可以设置三个值。<code>high</code>表示高优先级，<code>low</code>表示低优先级，<code>auto</code>表示由浏览器自行决定。</li>
<li><code>name</code>：内嵌窗口的名称，可以用于<code>&lt;a&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;base&gt;</code>的<code>target</code>属性。</li>
<li><code>referrerpolicy</code>：请求嵌入网页时，HTTP 请求的<code>Referer</code>字段的设置。参见<code>&lt;a&gt;</code>标签的介绍。</li>
</ul>
<h3 id="sandbox-属性"><a href="#sandbox-属性" class="headerlink" title="sandbox 属性"></a>sandbox 属性</h3><p>嵌入的网页默认具有正常权限，比如执行脚本、提交表单、弹出窗口等。如果嵌入的网页是其他网站的页面，你不了解对方会执行什么操作，因此就存在安全风险。为了限制<code>&lt;iframe&gt;</code>的风险，HTML 提供了<code>sandbox</code>属性，允许设置嵌入的网页的权限，等同于提供了一个隔离层，即“沙箱”。</p>
<p><code>sandbox</code>可以当作布尔属性使用，表示打开所有限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">sandbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>sandbox</code>属性可以设置具体的值，表示逐项打开限制。未设置某一项，就表示不具有该权限。</p>
<ul>
<li><code>allow-forms</code>：允许提交表单。</li>
<li><code>allow-modals</code>：允许提示框，即允许执行<code>window.alert()</code>等会产生弹出提示框的 JavaScript 方法。</li>
<li><code>allow-popups</code>：允许嵌入的网页使用<code>window.open()</code>方法弹出窗口。</li>
<li><code>allow-popups-to-escape-sandbox</code>：允许弹出窗口不受沙箱的限制。</li>
<li><code>allow-orientation-lock</code>：允许嵌入的网页用脚本锁定屏幕的方向，即横屏或竖屏。</li>
<li><code>allow-pointer-lock</code>：允许嵌入的网页使用 Pointer Lock API，锁定鼠标的移动。</li>
<li><code>allow-presentation</code>：允许嵌入的网页使用 Presentation API。</li>
<li><code>allow-same-origin</code>：不打开该项限制，将使得所有加载的网页都视为跨域。</li>
<li><code>allow-scripts</code>：允许嵌入的网页运行脚本（但不创建弹出窗口）。</li>
<li><code>allow-storage-access-by-user-activation</code>：<code>sandbox</code>属性同时设置了这个值和<code>allow-same-origin</code>的情况下，允许<code>&lt;iframe&gt;</code>嵌入的第三方网页通过用户发起<code>document.requestStorageAccess()</code>请求，经由 Storage Access API 访问父窗口的 Cookie。</li>
<li><code>allow-top-navigation</code>：允许嵌入的网页对顶级窗口进行导航。</li>
<li><code>allow-top-navigation-by-user-activation</code>：允许嵌入的网页对顶级窗口进行导航，但必须由用户激活。</li>
<li><code>allow-downloads-without-user-activation</code>：允许在没有用户激活的情况下，嵌入的网页启动下载。</li>
</ul>
<p>注意，不要同时设置<code>allow-scripts</code>和<code>allow-same-origin</code>属性，这将使得嵌入的网页可以改变或删除<code>sandbox</code>属性。</p>
<h3 id="loading-属性"><a href="#loading-属性" class="headerlink" title="loading 属性"></a>loading 属性</h3><p><code>&lt;iframe&gt;</code>指定的网页会立即加载，有时这不是希望的行为。<code>&lt;iframe&gt;</code>滚动进入视口以后再加载，这样会比较节省带宽。</p>
<p><code>loading</code>属性可以触发<code>&lt;iframe&gt;</code>网页的懒加载。该属性可以取以下三个值。</p>
<ul>
<li><code>auto</code>：浏览器的默认行为，与不使用<code>loading</code>属性效果相同。</li>
<li><code>lazy</code>：<code>&lt;iframe&gt;</code>的懒加载，即将滚动进入视口时开始加载。</li>
<li><code>eager</code>：立即加载资源，无论在页面上的位置如何。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会启用<code>&lt;iframe&gt;</code>的懒加载。</p>
<p>有一点需要注意，如果<code>&lt;iframe&gt;</code>是隐藏的，则<code>loading</code>属性无效，将会立即加载。只要满足以下任一个条件，Chrome 浏览器就会认为<code>&lt;iframe&gt;</code>是隐藏的。</p>
<ul>
<li><code>&lt;iframe&gt;</code>的宽度和高度为4像素或更小。</li>
<li>样式设为<code>display: none</code>或<code>visibility: hidden</code>。</li>
<li>使用定位坐标为负<code>X</code>或负<code>Y</code>，将<code>&lt;iframe</code>&gt;放置在屏幕外。</li>
</ul>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p><strong>创建比一般的 DOM 元素慢了 1-2 个数量级</strong></p>
<p>iframe 的创建比其它包括 scripts 和 css 的 DOM 元素的创建慢了 1-2 个数量级，使用 iframe 的页面一般不会包含太多 iframe，所以创建 DOM 节点所花费的时间不会占很大的比重。但带来一些其它的问题：onload 事件以及连接池（connection pool）</p>
<p><strong>阻塞页面加载</strong></p>
<p>及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。</p>
<p>window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况</p>
<p><strong>唯一的连接池</strong></p>
<p>浏览器只能开少量的连接到 web 服务器。比较老的浏览器，包含 Internet Explorer 6 &amp; 7 和 Firefox 2，只能对一个域名（hostname）同时打开两个连接。这个数量的限制在新版本的浏览器中有所提高。Safari 3+ 和 Opera 9+ 可同时对一个域名打开 4 个连接，Chrome 1+, IE 8 以及 Firefox 3 可以同时打开 6 个</p>
<p>绝大部分浏览器，主页面和其中的 iframe 是共享这些连接的。这意味着 iframe 在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。如果 iframe 中的内容比主页面的内容更重要，这当然是很好的。但通常情况下，iframe 里的内容是没有主页面的内容重要的。这时 iframe 中用光了可用的连接就是不值得的了。一种解决办法是，在主页面上重要的元素加载完毕后，再动态设置 iframe 的 SRC。</p>
<p><strong>不利于 SEO</strong></p>
<p>搜索引擎的检索程序无法解读 iframe。另外，iframe 本身不是动态语言，样式和脚本都需要额外导入。综上，iframe 应谨慎使用。 </p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>  1：典型系统结构，左侧是功能树，右侧就是一些常见的table或者表单之类的。为了每一个功能，单独分离出来，采用iframe。<br>  2：ajax上传文件。<br>  3：加载别的网站内容，例如google广告，网站流量分析。</p>
<p>  4：  在上传图片时，不用flash实现无刷新。</p>
<p>  5：  跨域访问的时候可以用到iframe，使用iframe请求不同域名下的资源。</p>
<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><p>表格（table）以行（row）和列（column）的形式展示数据。</p>
<h3 id="lt-table-gt-，-lt-caption-gt"><a href="#lt-table-gt-，-lt-caption-gt" class="headerlink" title="&lt;table&gt;，&lt;caption&gt;"></a><code>&lt;table&gt;</code>，<code>&lt;caption&gt;</code></h3><p><code>&lt;table&gt;</code>是一个块级容器标签，所有表格内容都要放在这个标签里面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  ... ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;caption&gt;</code>总是<code>&lt;table&gt;</code>里面的第一个子元素，表示表格的标题。该元素是可选的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span>示例表格<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-thead-gt-、-lt-tbody-gt-、-lt-tfoot-gt"><a href="#lt-thead-gt-、-lt-tbody-gt-、-lt-tfoot-gt" class="headerlink" title="&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;"></a><code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code></h3><p><code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code>都是块级容器元素，且都是<code>&lt;table&gt;</code>的一级子元素，分别表示表头、表体和表尾。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span>... ...<span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span>... ...<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>... ...<span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这三个元素都是可选的。如果使用了<code>&lt;thead&gt;</code>，那么<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>一定在<code>&lt;thead&gt;</code>的后面。如果使用了<code>&lt;tbody&gt;</code>，那么<code>&lt;tfoot&gt;</code>一定在<code>&lt;tbody&gt;</code>后面。即书写顺序可以任意，浏览器显示按照 thead、tbody、tfoot 的顺序依次来显示内容。</p>
<p>大型表格内部可以使用多个<code>&lt;tbody&gt;</code>，表示连续的多个部分。</p>
<p>当表格非常大内容非常多的时候，用 thead、tbody、tfoot 标签的话，那么数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。</p>
<h3 id="lt-colgroup-gt-，-lt-col-gt"><a href="#lt-colgroup-gt-，-lt-col-gt" class="headerlink" title="&lt;colgroup&gt;，&lt;col&gt;"></a><code>&lt;colgroup&gt;</code>，<code>&lt;col&gt;</code></h3><p><code>&lt;colgroup&gt;</code>是<code>&lt;table&gt;</code>的一级子元素，用来包含一组列的定义。<code>&lt;col&gt;</code>是<code>&lt;colgroup&gt;</code>的子元素，用来定义表格的一列。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明表格有3列。</p>
<p><code>&lt;col&gt;</code>不仅是一个单独使用的标签，没有结束标志，而且还是一个空元素，没有子元素。它的主要作用，除了申明表格结构，还可以为表格附加样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">class</span>=<span class="string">&quot;c3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;colgroup&gt;</code>声明表格有三列，每一列有自己的 class，可以使用 CSS 针对每个 class 设定样式，会对整个表格生效。</p>
<p><code>&lt;col&gt;</code>有一个<code>span</code>属性，值为正整数，默认为<code>1</code>。如果大于1，就表示该列的宽度包含连续的多列。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">span</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，表格的表头定义了3列，实际数据有4列。表头的第2列会连续跨2列。</p>
<h3 id="lt-tr-gt"><a href="#lt-tr-gt" class="headerlink" title="&lt;tr&gt;"></a><code>&lt;tr&gt;</code></h3><p><code>&lt;tr&gt;</code>标签表示表格的一行（table row）。如果表格有<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code>，那么<code>&lt;tr&gt;</code>就放在这些容器元素之中，否则直接放在<code>&lt;table&gt;</code>的下一级。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示表格共有3行。</p>
<h3 id="lt-th-gt-，-lt-td-gt"><a href="#lt-th-gt-，-lt-td-gt" class="headerlink" title="&lt;th&gt;，&lt;td&gt;"></a><code>&lt;th&gt;</code>，<code>&lt;td&gt;</code></h3><p><code>&lt;th&gt;</code>和<code>&lt;td&gt;</code>都用来定义表格的单元格。其中，<code>&lt;th&gt;</code>是标题单元格，<code>&lt;td&gt;</code>是数据单元格。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>001<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>002<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，表格一共有三行。第一行是标题行，所以使用<code>&lt;th&gt;</code>；第二行和第三行是数据行，所以使用<code>&lt;td&gt;</code>。</p>
<p><strong>（1）<code>colspan</code>属性，<code>rowspan</code>属性</strong></p>
<p>单元格会有跨越多行或多列的情况，这要通过<code>colspan</code>属性和<code>rowspan</code>属性设置，前者表示单元格跨越的栏数，后者表示单元格跨越的行数。它们的值都是一个非负整数，默认为1。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>B<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一行的第一个单元格会跨两列。</p>
<p><strong>（2）<code>headers</code>属性</strong></p>
<p>如果表格很大，单元格很多，源码里面会看不清，哪个单元格对应哪个表头，这时就可以使用<code>headers</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;no&quot;</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span> <span class="attr">id</span>=<span class="string">&quot;names&quot;</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;no&quot;</span>&gt;</span>001<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;names&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;no&quot;</span>&gt;</span>002<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">headers</span>=<span class="string">&quot;names&quot;</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，标题栏的<code>&lt;th&gt;</code>设置了<code>id</code>属性，后面的<code>&lt;td&gt;</code>单元格的<code>headers</code>属性就对应这些<code>id</code>属性的值，因此就能看出来这些单元格对应哪个标题栏。</p>
<p><code>headers</code>属性的值总是对应<code>&lt;th&gt;</code>标签的<code>id</code>属性的值。由于一个单元格可以对应多个标题栏（跨行的情况），所以<code>headers</code>属性可以是一个空格分隔的字符串，对应多个<code>id</code>属性的值。</p>
<p><strong>（3）<code>scope</code>属性</strong></p>
<p><code>scope</code>属性只有<code>&lt;th&gt;</code>标签支持，一般不在<code>&lt;td&gt;</code>标签使用，表示该<code>&lt;th&gt;</code>单元格到底是栏的标题，还是列的标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一行的标题栏都是列标题，所以<code>&lt;th&gt;</code>的<code>scope</code>属性为<code>col</code>，第二行和第三行的第一列是行标题，所以<code>&lt;th&gt;</code>标签的<code>scope</code>属性为<code>row</code>。</p>
<p><code>scope</code>属性可以取下面这些值。</p>
<ul>
<li><code>row</code>：该行的所有单元格，都与该标题单元格相关。</li>
<li><code>col</code>：该列的所有单元格，都与该标题单元格相关。</li>
<li><code>rowgroup</code>：多行组成的一个行组的所有单元格，都与该标题单元格相关，可以与<code>rowspan</code>属性配合使用。</li>
<li><code>colgroup</code>：多列组成的一个列组的所有单元格，都与该标题单元格相关，可以与<code>colspan</code>属性配合使用。</li>
<li><code>auto</code>：默认值，表示由浏览器自行决定。</li>
</ul>
<p>下面是一个<code>colgroup</code>属性和<code>rowgroup</code>属性的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>海报名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>颜色<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;colgroup&quot;</span>&gt;</span>尺寸<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">&quot;3&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;rowgroup&quot;</span>&gt;</span>Zodiac<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>Full color<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>Black and white<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span>&gt;</span>Sepia<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>A5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，列标题“尺寸”的<code>scope</code>属性为<code>colgroup</code>，表示这个标题单元格对应多列（本例为3列）；行标题的<code>scope</code>属性为<code>rowgroup</code>，表示这个标题单元格对应多行（本例为3行）。</p>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>表单（form）是用户输入信息与网页互动的一种形式。大多数情况下，用户提交的信息会发给服务器，比如网站的搜索栏就是表单。</p>
<p>表单由一种或多种的小部件组成，比如输入框、按钮、单选框或复选框。这些小部件称为控件（controls）。</p>
<h3 id="lt-form-gt"><a href="#lt-form-gt" class="headerlink" title="&lt;form&gt;"></a><code>&lt;form&gt;</code></h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>&lt;form&gt;</code>标签用来定义一个表单，所有表单内容放到这个容器元素之中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 各种表单控件--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码就是表单的基本形式。</p>
<p>下面是一个比较常见的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://example.com/api&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;POST-name&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;POST-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码就是一个表单，一共包含三个控件：一个<code>&lt;label&gt;</code>标签，一个文本输入框，一个提交按钮。其中，文本输入框的<code>name</code>属性是<code>user</code>，表示将向服务器发送一个键名为<code>user</code>的键值对，键值就是这个控件的<code>value</code>属性，等于用户输入的值。</p>
<p>用户在文本输入框里面，输入用户名，比如<code>foobar</code>，然后点击提交按钮，浏览器就会向服务器<code>https://example.com/api</code>发送一个 POST 请求，发送<code>user=foobar</code>这样一段数据。</p>
<p><code>&lt;form&gt;</code>有以下属性。</p>
<ul>
<li><code>accept-charset</code>：服务器接受的字符编码列表，使用空格分隔，默认与网页编码相同。</li>
<li><code>action</code>：服务器接收数据的 URL。指定表单数据的处理程序。</li>
<li><code>autocomplete</code>：如果用户没有填写某个控件，浏览器是否可以自动填写该值。它的可能取值分别为<code>off</code>（不自动填写）和<code>on</code>（自动填写）。</li>
<li><code>method</code>：提交数据的 HTTP 方法，可能的值有<code>post</code>（表单数据作为 HTTP 数据体发送），<code>get</code>（表单数据作为 URL 的查询字符串发送），<code>dialog</code>（表单位于<code>&lt;dialog&gt;</code>内部使用）。</li>
<li><code>enctype</code>：当<code>method</code>属性等于<code>post</code>时，该属性指定提交给服务器的 MIME 类型。可能的值为<code>application/x-www-form-urlencoded</code>（默认值），<code>multipart/form-data</code>（文件上传的情况），<code>text/plain</code>（用于调试）。</li>
<li><code>name</code>：表单的名称，应该在网页中是唯一的。注意，如果一个控件没有设置<code>name</code>属性，那么这个控件的值就不会作为键值对，向服务器发送。</li>
<li><code>novalidate</code>：布尔属性，表单提交时是否取消验证。</li>
<li><code>target</code>：在哪个窗口展示服务器返回的数据，可能的值有<code>_self</code>（当前窗口），<code>_blank</code>（新建窗口），<code>_parent</code>（父窗口），<code>_top</code>（顶层窗口），<code>&lt;iframe&gt;</code>标签的<code>name</code>属性（即表单返回结果展示在<code>&lt;iframe&gt;</code>窗口）。</li>
</ul>
<h4 id="enctype-属性"><a href="#enctype-属性" class="headerlink" title="enctype 属性"></a>enctype 属性</h4><p><code>&lt;form&gt;</code>表单的<code>enctype</code>属性，指定了采用 POST 方法提交数据时，浏览器给出的数据的 MIME 类型。该属性可以取以下值。</p>
<p>（1）<code>application/x-www-form-urlencoded</code></p>
<p><code>application/x-www-form-urlencoded</code>是默认类型，控件名和控件值都要转义（空格转为<code>+</code>号，非数字和非字母转为<code>%HH</code>的形式，换行转为CR LF），控件名和控件值之间用<code>=</code>分隔。控件按照出现顺序排列，控件之间用<code>&amp;</code>分隔。</p>
<p>（2）<code>multipart/form-data</code></p>
<p><code>multipart/form-data</code>主要用于文件上传。这个类型上传大文件时，会将文件分成多块传送，每一块的 HTTP 头信息都有<code>Content-Disposition</code>属性，值为<code>form-data</code>，以及一个<code>name</code>属性，值为控件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;mycontrol&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面是上传文件的表单。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://example.com/api&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit-name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清除&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，输入用户名<code>Larry</code>，选中一个<code>file1.txt</code>文件，然后点击“上传”。浏览器发送的实际数据如下。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=--AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit-name&quot;</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure>
<p>上面代码中，浏览器将这个表单发成多个数据块。最上面使用<code>Content-Type</code>字段告诉服务器，数据格式是<code>multipart/form-data</code>（即多个数据块），每个数据块的分隔标志是<code>--AaB03x</code>。每个数据块的第一行是<code>Content-Disposition</code>，其中的<code>name</code>字段表示这个数据块的控件名，数据体则是该控件的数据值，比如第一个数据块的<code>name</code>属性是<code>submit-name</code>控件，数据体是该控件的值<code>Larry</code>。第二个数据块是控件<code>files</code>，由于该控件是上传文件，所以还要用<code>filename</code>属性给出文件名<code>file1.txt</code>，数据体是<code>file1.txt</code>的内容。</p>
<h3 id="lt-fieldset-gt-，-lt-legend-gt"><a href="#lt-fieldset-gt-，-lt-legend-gt" class="headerlink" title="&lt;fieldset&gt;，&lt;legend&gt;"></a><code>&lt;fieldset&gt;</code>，<code>&lt;legend&gt;</code></h3><p><code>&lt;fieldset&gt;</code>标签是一个块级容器标签，表示控件的集合，用于将一组相关控件组合成一组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，两个输入框是一组，它们的外面会显示一个方框。</p>
<p><code>&lt;fieldset&gt;</code>有以下属性。</p>
<ul>
<li><code>disabled</code>：布尔属性，一旦设置会使得<code>&lt;fieldset&gt;</code>内部包含的控件都不可用，都变成灰色状态。</li>
<li><code>form</code>：指定控件组所属的<code>&lt;form&gt;</code>，它的值等于<code>&lt;form&gt;</code>的<code>id</code>属性。</li>
<li><code>name</code>：该控件组的名称。</li>
</ul>
<p><code>&lt;legend&gt;</code>标签用来设置<code>&lt;fieldset&gt;</code>控件组的标题，通常是<code>&lt;fieldset&gt;</code>内部的第一个元素，会嵌入显示在控件组的上边框里面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span>学生情况登记<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，这个控件组的标题会，嵌入显示在<code>&lt;fieldset&gt;</code>的上边框。</p>
<h3 id="lt-label-gt"><a href="#lt-label-gt" class="headerlink" title="&lt;label&gt;"></a><code>&lt;label&gt;</code></h3><p><code>&lt;label&gt;</code>标签是一个行内元素，提供控件的文字说明，帮助用户理解控件的目的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;user&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，输入框前面会有文字说明“用户名：”。</p>
<p><code>&lt;label&gt;</code>的一大优势是增加了控件的可用性。有些控件比较小（比如单选框），不容易点击，那么点击对应的<code>&lt;label&gt;</code>标签，也能选中该控件。点击<code>&lt;label&gt;</code>，就相当于控件本身的<code>click</code>事件。</p>
<p><code>&lt;label&gt;</code>的<code>for</code>属性关联相对应的控件，它的值是对应控件的<code>id</code>属性。所以，控件最好设置<code>id</code>属性。</p>
<p>控件也可以放在<code>&lt;label&gt;</code>之中，这时不需要<code>for</code>属性和<code>id</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;label&gt;</code>的属性如下。</p>
<ul>
<li><code>for</code>：关联控件的<code>id</code>属性。</li>
<li><code>form</code>：关联表单的<code>id</code>属性。设置了该属性后，<code>&lt;label&gt;</code>可以放置在页面的任何位置，否则只能放在<code>&lt;form&gt;</code>内部。</li>
</ul>
<p>一个控件可以有多个关联的<code>&lt;label&gt;</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;required&quot;</span>&gt;</span>*<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;input&gt;</code>有两个关联的<code>&lt;label&gt;</code>。</p>
<h3 id="lt-input-gt"><a href="#lt-input-gt" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p><code>&lt;input&gt;</code>标签是一个行内元素，用来接收用户的输入。它是一个单独使用的标签，没有结束标志。</p>
<p>它有多种类型，取决于<code>type</code>属性的值，默认值是<code>text</code>，表示一个输入框。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会生成一个单行的输入框，用户可以在里面输入文本。</p>
<p><code>&lt;input&gt;</code>的属性非常多，有些属性是某个类型专用的，放在下文的“类型”部分介绍。这里介绍一些所有类型的共同属性。</p>
<ul>
<li><code>autofocus</code>：布尔属性，是否在页面加载时自动获得焦点。</li>
<li><code>disabled</code>：布尔属性，是否禁用该控件。一旦设置，该控件将变灰，用户可以看到，但是无法操作。</li>
<li><code>form</code>：关联表单的<code>id</code>属性。设置了该属性后，控件可以放置在页面的任何位置，否则只能放在<code>&lt;form&gt;</code>内部。</li>
<li><code>list</code>：关联的<code>&lt;datalist&gt;</code>的<code>id</code>属性，设置该控件相关的数据列表。</li>
<li><code>name</code>：控件的名称，主要用于向服务器提交数据时，控件键值对的键名。注意，只有设置了<code>name</code>属性的控件，才会向服务器提交，不设置就不会提交。</li>
<li><code>readonly</code>：布尔属性，是否为只读。</li>
<li><code>required</code>：布尔属性，是否为必填。</li>
<li><code>type</code>：控件类型。</li>
<li><code>value</code>：控件的值。</li>
</ul>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p><code>type</code>属性决定了<code>&lt;input&gt;</code>的形式。该属性可以取以下值。</p>
<p><strong>（1）text</strong></p>
<p><code>type=&quot;text&quot;</code>是普通的文本输入框，用来输入单行文本。如果用户输入换行符，换行符会自动从输入中删除。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">required</span></span></span><br><span class="line"><span class="tag">       <span class="attr">minlength</span>=<span class="string">&quot;4&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;8&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>text</code>输入框有以下配套属性。</p>
<ul>
<li><code>maxlength</code>：可以输入的最大字符数，值为一个非负整数。</li>
<li><code>minlength</code>：可以输入的最小字符数，值为一个非负整数，且必须小于<code>maxlength</code>。</li>
<li><code>pattern</code>：用户输入必须匹配的正则表达式，比如要求用户输入4个～8个英文字符，可以写成<code>pattern=&quot;[a-z]&#123;4,8&#125;&quot;</code>。如果用户输入不符合要求，浏览器会弹出提示，不会提交表单。</li>
<li><code>placeholder</code>：输入字段为空时，用于提示的示例值。只要用户没有任何字符，该提示就会出现，否则会消失。</li>
<li><code>readonly</code>：布尔属性，表示该输入框是只读的，用户只能看，不能输入。</li>
<li><code>size</code>：表示输入框的显示长度有多少个字符宽，它的值是一个正整数，默认等于20。超过这个数字的字符，必须移动光标才能看到。</li>
<li><code>spellcheck</code>：是否对用户输入启用拼写检查，可能的值为<code>true</code>或<code>false</code>。</li>
</ul>
<p><strong>（2）search</strong></p>
<p><code>type=&quot;search&quot;</code>是一个用于搜索的文本输入框，输入文本中的换行会被自动去除，基本等同于<code>type=&quot;text&quot;</code>。某些浏览器会在输入的时候，在输入框的尾部显示一个删除按钮，点击就会删除所有输入，让用户从头开始输入。</p>
<p>下面是一个例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mySearch&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">&quot;输入搜索词……&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;搜索&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）button</strong></p>
<p><code>type=&quot;button&quot;</code>是没有默认行为的按钮，通常脚本指定<code>click</code>事件的监听函数来使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>建议尽量不使用这个类型，而使用<code>&lt;button&gt;</code>标签代替，一则语义更清晰，二则<code>&lt;button&gt;</code>标签内部可以插入图片或其他 HTML 代码。</p>
<p><strong>（4）submit</strong></p>
<p><code>type=&quot;submit&quot;</code>是表单的提交按钮。用户点击这个按钮，就会把表单提交给服务器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不指定<code>value</code>属性，浏览器会在提交按钮上显示默认的文字，通常是<code>Submit</code>。</p>
<p>该类型有以下配套属性，用来覆盖<code>&lt;form&gt;</code>标签的相应设置。</p>
<ul>
<li><code>formaction</code>：提交表单数据的服务器 URL。</li>
<li><code>formenctype</code>：表单数据的编码类型。</li>
<li><code>formmethod</code>：提交表单使用的 HTTP 方法（<code>get</code>或<code>post</code>）。</li>
<li><code>formnovalidate</code>：一个布尔值，表示数据提交给服务器之前，是否要忽略表单验证。</li>
<li><code>formtarget</code>：收到服务器返回的数据后，在哪一个窗口显示。</li>
</ul>
<p><strong>（5）image</strong></p>
<p><code>type=&quot;image&quot;</code>表示将一个图像文件作为提交按钮，行为和用法与<code>type=&quot;submit&quot;</code>完全一致。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;登陆&quot;</span> <span class="attr">src</span>=<span class="string">&quot;login-button.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，图像文件是一个可以点击的按钮，点击后会提交数据到服务器。</p>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>alt</code>：图像无法加载时显示的替代字符串。</li>
<li><code>src</code>：加载的图像 URL。</li>
<li><code>height</code>：图像的显示高度，单位为像素。</li>
<li><code>width</code>：图像的显示宽度，单位为像素。</li>
<li><code>formaction</code>：提交表单数据的服务器 URL。</li>
<li><code>formenctype</code>：表单数据的编码类型。</li>
<li><code>formmethod</code>：提交表单使用的 HTTP 方法（<code>get</code>或<code>post</code>）。</li>
<li><code>formnovalidate</code>：一个布尔值，表示数据提交给服务器之前，是否要忽略表单验证。</li>
<li><code>formtarget</code>：收到服务器返回的数据后，在哪一个窗口显示。</li>
</ul>
<p>用户点击图像按钮提交时，会额外提交两个参数<code>x</code>和<code>y</code>到服务器，表示鼠标的点击位置，比如<code>x=52&amp;y=55</code>。<code>x</code>是横坐标，<code>y</code>是纵坐标，都以图像左上角作为原点<code>(0, 0)</code>。如果图像按钮设置了<code>name</code>属性，比如<code>name=&quot;position&quot;</code>，那么将以该值作为坐标的前缀，比如<code>position.x=52&amp;position.y=55</code>。这个功能通常用来地图类型的操作，让服务器知道用户点击了地图的哪个部分。</p>
<p><strong>（6）reset</strong></p>
<p><code>type=&quot;reset&quot;</code>是一个重置按钮，用户点击以后，所有表格控件重置为初始值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不设置<code>value</code>属性，浏览器会在按钮上面加上默认文字，通常是<code>Reset</code>。</p>
<p>这个控件用处不大，用户点错了还会使得所有已经输入的值都被重置，建议不要使用。</p>
<p><strong>（7）checkbox</strong></p>
<p><code>type=&quot;checkbox&quot;</code>是复选框，允许选择或取消选择该选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agreement&quot;</span> <span class="attr">name</span>=<span class="string">&quot;agreement&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agreement&quot;</span>&gt;</span>是否同意<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会在文字前面，显示一个可以点击的选择框，点击可以选中，再次点击可以取消。上面代码中，<code>checked</code>属性表示默认选中。</p>
<p><code>value</code>属性的默认值是<code>on</code>。也就是说，如果没有设置<code>value</code>属性，以上例来说，选中复选框时，会提交<code>agreement=on</code>。如果没有选中，提交时不会有该项。</p>
<p>多个相关的复选框，可以放在<code>&lt;fieldset&gt;</code>里面。所有关联的复选框应该拥有相同的 <code>name</code> 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span>你的兴趣<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;coding&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;coding&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;coding&quot;</span>&gt;</span>编码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;music&quot;</span> <span class="attr">name</span>=<span class="string">&quot;interest&quot;</span> <span class="attr">value</span>=<span class="string">&quot;music&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;music&quot;</span>&gt;</span>音乐<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果用户同时选中两个复选框，提交的时候就会有两个<code>name</code>属性，比如<code>interest=coding&amp;interest=music</code>。</p>
<p><strong>（8）radio</strong></p>
<p><code>type=&quot;radio&quot;</code>是单选框，表示一组选择之中，只能选中一项。单选框通常为一个小圆圈，选中时会被填充或突出显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，性别只能在两个选项之中，选择一项。</p>
<p>注意，多个单选框的<code>name</code>属性的值，应该都是一致的。提交到服务器的就是选中的那个值。</p>
<p>该类型的配套属性如下。</p>
<ul>
<li><code>checked</code>：布尔属性，表示是否默认选中当前项。</li>
<li><code>value</code>：用户选中该项时，提交到服务器的值，默认为<code>on</code>。</li>
</ul>
<p><strong>（9）email</strong></p>
<p><code>type=&quot;email&quot;</code>是一个只能输入电子邮箱的文本输入框。表单提交之前，浏览器会自动验证是否符合电子邮箱的格式，如果不符合就会显示提示，无法提交到服务器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;.+@foobar.com&quot;</span> <span class="attr">size</span>=<span class="string">&quot;30&quot;</span> <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会生成一个必填的文本框，只能输入后缀为<code>foobar.com</code>的邮箱地址。</p>
<p>该类型有一个<code>multiple</code>的布尔属性，一旦设置，就表示该输入框可以输入多个逗号分隔的电子邮箱。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;emailAddress&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">multiple</span> <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，如果同时设置了<code>multiple</code>属性和<code>required</code>属性，零个电子邮箱是允许的，也就是该输入框允许为空。</p>
<p>该类型的配套属性如下。</p>
<ul>
<li><code>maxlength</code>：可以输入的最大字符数。</li>
<li><code>minlength</code>：可以输入的最少字符数。</li>
<li><code>multiple</code>：布尔属性，是否允许输入多个以逗号分隔的电子邮箱。</li>
<li><code>pattern</code>：输入必须匹配的正则表达式。</li>
<li><code>placeholder</code>：输入为空时的显示文本。</li>
<li><code>readonly</code>：布尔属性，该输入框是否只读。</li>
<li><code>size</code>：一个非负整数，表示输入框的显示长度为多少个字符。</li>
<li><code>spellcheck</code>：是否对输入内容启用拼写检查，可能的值为<code>true</code>或<code>false</code>。</li>
</ul>
<p>该类型还可以搭配<code>&lt;datalist&gt;</code>标签，提供输入的备选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">size</span>=<span class="string">&quot;40&quot;</span> <span class="attr">list</span>=<span class="string">&quot;defaultEmails&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;defaultEmails&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;jbond007@mi6.defence.gov.uk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;jbourne@unknown.net&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;nfury@shield.org&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;tony@starkindustries.com&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;hulk@grrrrrrrr.arg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，输入焦点进入输入框以后，会显示一个下拉列表，里面有五个参考项，供用户参考。</p>
<p><strong>（10）password</strong></p>
<p><code>type=&quot;password&quot;</code>是一个密码输入框。用户的输入会被遮挡，字符通常显示星号（<code>*</code>）或点（<code>·</code>）。如果站点不安全，会警告用户。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">minlength</span>=<span class="string">&quot;8&quot;</span> <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器对该类型输入框的显示，会有所差异。一种常见的处理方法是，用户每输入一个字符，先在输入框里面显示一秒钟，然后再遮挡该字符。</p>
<p>如果用户输入内容包含换行符（<code>U+000A</code>）和回车符（<code>U+000D</code>），浏览器会自动将这两个字符过滤掉。</p>
<p>该类型的配套属性如下。</p>
<ul>
<li><code>maxlength</code>：可以输入的最大字符数。</li>
<li><code>minlength</code>：可以输入的最少字符数。</li>
<li><code>pattern</code>：输入必须匹配的正则表达式。</li>
<li><code>placeholder</code>：输入为空时的显示文本。</li>
<li><code>readonly</code>：布尔属性，该输入框是否只读。</li>
<li><code>size</code>：一个非负整数，表示输入框的显示长度为多少个字符。</li>
<li><code>autocomplete</code>：是否允许自动填充，可能的值有<code>on</code>（浏览器可以根据用户先前的填表情况对此字段自动填值）、<code>off</code>（用户必须手动填值，或者该页面提供了自己的自动补全方法。浏览器不对此字段自动填充）、<code>current-password</code>（填入当前网站保存的密码）、<code>new-password</code>（自动生成一个随机密码）。</li>
<li><code>inputmode</code>：允许用户输入的数据类型，可能的值有<code>none</code>（不使用系统输入法）、<code>text</code>（标准文本输入）、<code>decimal</code>（数字，包含小数）、<code>numeric</code>（数字0-9）等。</li>
</ul>
<p><strong>（11）file</strong></p>
<p><code>type=&quot;file&quot;</code>是一个文件选择框，允许用户选择一个或多个文件，常用于文件上传功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;avatar&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">accept</span>=<span class="string">&quot;image/png, image/jpeg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该类型有以下属性。</p>
<ul>
<li><code>accept</code>：允许选择的文件类型，使用逗号分隔，可以使用 MIME 类型（比如<code>image/jpeg</code>），也可以使用后缀名（比如<code>.doc</code>），还可以使用<code>audio/*</code>（任何音频文件）、<code>video/*</code>（任何视频文件）、<code>image/*</code>（任何图像文件）等表示法。</li>
<li><code>capture</code>：用于捕获图像或视频数据的源，可能的值有<code>user</code>（面向用户的摄像头或麦克风），<code>environment</code>（外接的摄像头或麦克风）。</li>
<li><code>multiple</code>：布尔属性，是否允许用户选择多个文件。</li>
</ul>
<p><strong>（12）hidden</strong></p>
<p><code>type=&quot;hidden&quot;</code>是一个不显示在页面的控件，用户无法输入它的值，主要用来向服务器传递一些隐藏信息。比如，CSRF 攻击会伪造表单数据，那么使用这个控件，可以为每个表单生成一个独一无二的隐藏编号，防止伪造表单提交。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;prodId&quot;</span> <span class="attr">name</span>=<span class="string">&quot;prodId&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xm234jq&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这个控件，页面上是看不见的。用户提交表单的时候，浏览器会将<code>prodId=xm234jq</code>发给服务器。</p>
<p><strong>（13）number</strong></p>
<p><code>type=&quot;number&quot;</code>是一个数字输入框，只能输入数字。浏览器通常会在输入框的最右侧，显示一个可以点击的上下箭头，点击向上箭头，数字会递增，点击向下箭头，数字会递减。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tentacles&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tentacles&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;10&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定数字输入框，最小可以输入10，最大可以输入100。</p>
<p>该类型可以接受任何数值，包括小数和整数。可以通过<code>step</code>属性，限定只接受整数。</p>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>max</code>：允许输入的最大数值。</li>
<li><code>min</code>：允许输入的最小数值。</li>
<li><code>placeholder</code>：用户输入为空时，显示的示例值。</li>
<li><code>readonly</code>：布尔属性，表示该控件是否为只读。</li>
<li><code>step</code>：点击向上和向下箭头时，数值每次递减的步长值。如果用户输入的值，不符合步长值的设定，浏览器会自动四舍五入到最近似的值。默认的步长值是<code>1</code>，如果初始的<code>value</code>属性设为<code>1.5</code>，那么点击向上箭头得到<code>2.5</code>，点击向下箭头得到<code>0.5</code>。</li>
</ul>
<p><strong>（14）range</strong></p>
<p><code>type=&quot;range&quot;</code>是一个滑块，用户拖动滑块，选择给定范围之中的一个数值。因为拖动产生的值是不精确的，如果需要精确数值，不建议使用这个控件。常见的例子是调节音量。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">name</span>=<span class="string">&quot;volume&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;11&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会产生一个最小值为<code>0</code>、最大值为<code>11</code>的滑块区域。用户拖动滑块，选择想要的音量。</p>
<p>该类型的配套属性如下，用法与<code>type=&quot;number&quot;</code>一致。</p>
<ul>
<li><code>max</code>：允许的最大值，默认为100。</li>
<li><code>min</code>：允许的最小值，默认为0。</li>
<li><code>step</code>：步长值，默认为1。</li>
</ul>
<p><code>value</code>属性的初始值就是滑块的默认位置。如果没有设置<code>value</code>属性，滑块默认就会停在最大值和最小值中间。如果<code>max</code>属性、<code>min</code>属性、<code>value</code>属性都没有设置，那么<code>value</code>属性为50。</p>
<p>该类型与<code>&lt;datalist&gt;</code>标签配合使用，可以在滑动区域产生刻度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">list</span>=<span class="string">&quot;tickmarks&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;tickmarks&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">label</span>=<span class="string">&quot;0%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;40&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span> <span class="attr">label</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;60&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;70&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;80&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;90&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> <span class="attr">label</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会在0～100之间产生11个刻度。其中，<code>0%</code>、<code>50%</code>和<code>100%</code>三个位置会有文字提示，不过浏览器很可能不支持。</p>
<p>注意，浏览器生成的都是水平滑块。如果想要生成垂直滑块，可以使用 CSS 改变滑块区域的方向。</p>
<p><strong>（15）url</strong></p>
<p><code>type=&quot;url&quot;</code>是一个只能输入网址的文本框。提交表单之前，浏览器会自动检查网址格式是否正确，如果不正确，就会无法提交。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">id</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">placeholder</span>=<span class="string">&quot;https://example.com&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">pattern</span>=<span class="string">&quot;https://.*&quot;</span> <span class="attr">size</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>pattern</code>属性指定输入的网址只能使用 HTTPS 协议。</p>
<p>注意，该类型规定，不带有协议的网址是无效的，比如<code>foo.com</code>是无效的，<code>http://foo.com</code>是有效的。</p>
<p>该类型的配套属性如下。</p>
<ul>
<li><code>maxlength</code>：允许的最大字符数。</li>
<li><code>minlength</code>：允许的最少字符串。</li>
<li><code>pattern</code>：输入内容必须匹配的正则表达式。</li>
<li><code>placeholder</code>：输入为空时显示的示例文本。</li>
<li><code>readonly</code>：布尔属性，表示该控件的内容是否只读。</li>
<li><code>size</code>：一个非负整数，表示该输入框显示宽度为多少个字符。</li>
<li><code>spellcheck</code>：是否启动拼写检查，可能的值为<code>true</code>（启用）和<code>false</code>（不启用）。</li>
</ul>
<p>该类型与<code>&lt;datalist&gt;</code>标签搭配使用，可以形成下拉列表供用户选择。随着用户不断键入，会缩小显示范围，只显示匹配的备选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;myURL&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myURL&quot;</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">list</span>=<span class="string">&quot;defaultURLs&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;defaultURLs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;https://developer.mozilla.org/&quot;</span> <span class="attr">label</span>=<span class="string">&quot;MDN Web Docs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;http://www.google.com/&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Google&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;http://www.microsoft.com/&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Microsoft&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;https://www.mozilla.org/&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Mozilla&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;http://w3.org/&quot;</span> <span class="attr">label</span>=<span class="string">&quot;W3C&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;option&gt;</code>的<code>label</code>属性表示文本标签，显示在备选下拉框的右侧，网址显示在左侧。</p>
<p><strong>（16）tel</strong></p>
<p><code>type=&quot;tel&quot;</code>是一个只能输入电话号码的输入框。由于全世界的电话号码格式都不相同，因此浏览器没有默认的验证模式，大多数时候需要自定义验证。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">id</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">pattern</span>=<span class="string">&quot;[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>Format: 123-456-7890<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个只能输入10位电话号码的输入框。</p>
<p>该类型的配套属性如下。</p>
<ul>
<li><code>maxlength</code>：允许的最大字符数。</li>
<li><code>minlength</code>：允许的最少字符串。</li>
<li><code>pattern</code>：输入内容必须匹配的正则表达式。</li>
<li><code>placeholder</code>：输入为空时显示的示例文本。</li>
<li><code>readonly</code>：布尔属性，表示该控件的内容是否只读。</li>
<li><code>size</code>：一个非负整数，表示该输入框显示宽度为多少个字符。</li>
</ul>
<p><strong>（17）color</strong></p>
<p><code>type=&quot;color&quot;</code>是一个选择颜色的控件，它的值一律都是<code>#rrggbb</code>格式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;background&quot;</span> <span class="attr">name</span>=<span class="string">&quot;background&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">value</span>=<span class="string">&quot;#e66465&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在 Chrome 浏览器中，会显示一个<code>#e66465</code>的色块。点击色块，就会出现一个拾色器，供用户选择颜色。</p>
<p>如果没有指定<code>value</code>属性的初始值，默认值为<code>#000000</code>（黑色）。</p>
<p><strong>（18）date</strong></p>
<p><code>type=&quot;date&quot;</code>是一个只能输入日期的输入框，用户可以输入年月日，但是不能输入时分秒。输入格式是<code>YYYY-MM-DD</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">value</span>=<span class="string">&quot;2018-07-22&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;2018-01-01&quot;</span> <span class="attr">max</span>=<span class="string">&quot;2018-12-31&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会显示一个输入框，默认日期是2018年7月22日。用户点击以后，会日期选择器，供用户选择新的日期。</p>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>max</code>：可以允许的最晚日期，格式为<code>yyyy-MM-dd</code>。</li>
<li><code>min</code>：可以允许的最早日期，格式为<code>yyyy-MM-dd</code>。</li>
<li><code>step</code>：步长值，一个数字，以天为单位。</li>
</ul>
<p><strong>（19）time</strong></p>
<p><code>type=&quot;time&quot;</code>是一个只能输入时间的输入框，可以输入时分秒，不能输入年月日。日期格式是24小时制的<code>hh:mm</code>，如果包括秒数，格式则是<code>hh:mm:ss</code>。日期选择器的形式则随浏览器不同而不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">id</span>=<span class="string">&quot;appt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;appt&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;9:00&quot;</span> <span class="attr">max</span>=<span class="string">&quot;18:00&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>营业时间上午9点到下午6点<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>max</code>：允许的最晚时间。</li>
<li><code>min</code>：允许的最早时间。</li>
<li><code>readonly</code>：布尔属性，表示用户是否不可以编辑时间。</li>
<li><code>step</code>：步长值，单位为秒。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;appt&quot;</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;appt&quot;</span> <span class="attr">step</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调节控件的话，时间每次改变的幅度是2秒钟。</p>
<p><strong>（20）month</strong></p>
<p><code>type=&quot;month&quot;</code>是一个只能输入年份和月份的输入框，格式为<code>YYYY-MM</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;month&quot;</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> <span class="attr">name</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;2018-03&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2018-05&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>max</code>：允许的最晚时间，格式为<code>yyyy-MM</code>。</li>
<li><code>min</code>：允许的最早时间，格式为<code>yyyy-MM</code>。</li>
<li><code>readonly</code>：布尔属性，表示用户是否不可以编辑时间。</li>
<li><code>step</code>：步长值，单位为月。</li>
</ul>
<p><strong>（21）week</strong></p>
<p><code>type=&quot;week&quot;</code>是一个输入一年中第几周的输入框。格式为<code>yyyy-Www</code>，比如<code>2018-W18</code>表示2018年第18周。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;week&quot;</span> <span class="attr">name</span>=<span class="string">&quot;week&quot;</span> <span class="attr">id</span>=<span class="string">&quot;camp-week&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;2018-W18&quot;</span> <span class="attr">max</span>=<span class="string">&quot;2018-W26&quot;</span> <span class="attr">required</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>max</code>：允许的最晚时间，格式为<code>yyyy-Www</code>。</li>
<li><code>min</code>：允许的最早时间，格式为<code>yyyy-Www</code>。</li>
<li><code>readonly</code>：布尔属性，表示用户是否不可以编辑时间。</li>
<li><code>step</code>：步长值，单位为周。</li>
</ul>
<p><strong>（22）datetime-local</strong></p>
<p><code>type=&quot;datetime-local&quot;</code>是一个时间输入框，让用户输入年月日和时分，格式为<code>yyyy-MM-ddThh:mm</code>。注意，该控件不支持秒。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">id</span>=<span class="string">&quot;meeting-time&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;meeting-time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2018-06-12T19:30&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;2018-06-07T00:00&quot;</span> <span class="attr">max</span>=<span class="string">&quot;2018-06-14T00:00&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该类型有以下配套属性。</p>
<ul>
<li><code>max</code>：允许的最晚时间，格式为<code>yyyy-MM-ddThh:mm</code>。</li>
<li><code>min</code>：允许的最早时间，格式为<code>yyyy-MM-ddThh:mm</code>。</li>
<li><code>step</code>：步长值，单位为秒，默认值是60。</li>
</ul>
<h3 id="lt-button-gt"><a href="#lt-button-gt" class="headerlink" title="&lt;button&gt;"></a><code>&lt;button&gt;</code></h3><p><code>&lt;button&gt;</code>标签会生成一个可以点击的按钮，没有默认行为，通常需要用<code>type</code>属性或脚本指定按钮的功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会产生一个按钮，上面的文字就是“点击”。</p>
<p><code>&lt;button&gt;</code>内部不仅放置文字，还可以放置图像，这可以形成图像按钮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;search.gif&quot;</span>&gt;</span>搜索</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;button&gt;</code>具有以下属性。</p>
<ul>
<li><code>autofocus</code>：布尔属性，表示网页加载时，焦点就在这个按钮。网页里面只能有一个元素，具有这个属性。</li>
<li><code>disabled</code>：布尔属性，表示按钮不可用，会导致按钮变灰，不可点击。</li>
<li><code>name</code>：按钮的名称（与<code>value</code>属性配合使用），将以<code>name=value</code>的形式，随表单一起提交到服务器。</li>
<li><code>value</code>：按钮的值（与<code>name</code>属性配合使用），将以<code>name=value</code>的形式，随表单一起提交到服务器。</li>
<li><code>type</code>：按钮的类型，可能的值有三种：<code>submit</code>（点击后将数据提交给服务器），<code>reset</code>（将所有控件的值重置为初始值），<code>button</code>（没有默认行为，由脚本指定按钮的行为）。</li>
<li><code>form</code>：指定按钮关联的<code>&lt;form&gt;</code>表单，值为<code>&lt;form&gt;</code>的<code>id</code>属性。如果省略该属性，默认关联按钮所在父表单。</li>
<li><code>formaction</code>：数据提交到服务器的目标 URL，会覆盖<code>&lt;form&gt;</code>元素的<code>action</code>属性。</li>
<li><code>formenctype</code>：数据提交到服务器的编码方式，会覆盖<code>&lt;form&gt;</code>元素的<code>enctype</code>属性。可能的值有三种：<code>application/x-www-form-urlencoded</code>（默认值），<code>multipart/form-data</code>（只用于文件上传），<code>text/plain</code>。</li>
<li><code>formmethod</code>：数据提交到服务器使用的 HTTP 方法，会覆盖<code>&lt;form&gt;</code>元素的<code>method</code>属性，可能的值为<code>post</code>或<code>get</code>。</li>
<li><code>formnovalidate</code>：布尔属性，数据提交到服务器时关闭本地验证，会覆盖<code>&lt;form&gt;</code>元素的<code>novalidate</code>属性。</li>
<li><code>formtarget</code>：数据提交到服务器后，展示服务器返回数据的窗口，会覆盖<code>&lt;form&gt;</code>元素的<code>target</code>属性。可能的值有<code>_self</code>（当前窗口），<code>_blank</code>（新的空窗口）、<code>_parent</code>（父窗口）、<code>_top</code>（顶层窗口）。</li>
</ul>
<h3 id="lt-select-gt"><a href="#lt-select-gt" class="headerlink" title="&lt;select&gt;"></a><code>&lt;select&gt;</code></h3><p><code>&lt;select&gt;</code>标签用于生成一个下拉菜单。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pet-select&quot;</span>&gt;</span>宠物：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;pet-select&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pet-select&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>--请选择一项--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dog&quot;</span>&gt;</span>狗<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cat&quot;</span>&gt;</span>猫<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;others&quot;</span>&gt;</span>其他<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;select&gt;</code>生成一个下拉菜单，菜单标题是“–请选择一项–”，最右侧有一个下拉箭头。点击下拉箭头，会显示三个菜单项，供用户点击选择。</p>
<p>下拉菜单的菜单项由<code>&lt;option&gt;</code>标签给出，每个<code>&lt;option&gt;</code>代表可以选择的一个值。选中的<code>&lt;option&gt;</code>的<code>value</code>属性，就是<code>&lt;select&gt;</code>控件发送的服务器的值。</p>
<p><code>&lt;option&gt;</code>有一个布尔属性<code>selected</code>，一旦设置，就表示该项是默认选中的菜单项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;choice&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;first&quot;</span>&gt;</span>First Value<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;second&quot;</span> <span class="attr">selected</span>&gt;</span>Second Value<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;third&quot;</span>&gt;</span>Third Value<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第二项<code>Second Value</code>是默认选中的。页面加载的时候，会直接显示在下拉菜单上。</p>
<p><code>&lt;select&gt;</code>有如下属性。</p>
<ul>
<li><code>autofocus</code>：布尔属性，页面加载时是否自动获得焦点。</li>
<li><code>disabled</code>：布尔属性，是否禁用当前控件。</li>
<li><code>form</code>：关联表单的<code>id</code>属性。</li>
<li><code>multiple</code>：布尔属性，是否可以选择多个菜单项。默认情况下，只能选择一项。一旦设置，多数浏览器会显示一个滚动列表框。用户可能需要按住<code>Shift</code>或其他功能键，选中多项。</li>
<li><code>name</code>：控件名。</li>
<li><code>required</code>：布尔属性，是否为必填控件。</li>
<li><code>size</code>：设置了<code>multiple</code>属性时，页面显示时一次可见的行数，其他行需要滚动查看。默认值为 0。</li>
</ul>
<h3 id="lt-option-gt-，-lt-optgroup-gt"><a href="#lt-option-gt-，-lt-optgroup-gt" class="headerlink" title="&lt;option&gt;，&lt;optgroup&gt;"></a><code>&lt;option&gt;</code>，<code>&lt;optgroup&gt;</code></h3><p><code>&lt;option&gt;</code>标签用在<code>&lt;select&gt;</code>、<code>&lt;optgroup&gt;</code>、<code>&lt;datalist&gt;</code>里面，表示一个菜单项，参见<code>&lt;select&gt;</code>的示例。</p>
<p>它有如下属性。</p>
<ul>
<li><code>disabled</code>：布尔属性，是否禁用该项。</li>
<li><code>label</code>：该项的说明。如果省略，则等于该项的文本内容。</li>
<li><code>selected</code>：布尔属性，是否为默认值。显然，一组菜单中，只能有一个菜单项设置该属性。</li>
<li><code>value</code>：该项提交到服务器的值。如果省略，则等于该项的文本内容。</li>
</ul>
<p><code>&lt;optgroup&gt;</code>表示菜单项的分组，通常用在<code>&lt;select&gt;</code>内部。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>宠物：</span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;pets&quot;</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;四条腿的宠物&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;dog&quot;</span>&gt;</span>狗<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;cat&quot;</span>&gt;</span>猫<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;鸟类&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;parrot&quot;</span>&gt;</span>鹦鹉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;thrush&quot;</span>&gt;</span>画眉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;select&gt;</code>是一个下拉菜单，它的内部使用<code>&lt;optgroup&gt;</code>将菜单项分成两组。每组有自己的标题，会加粗显示，但是用户无法选中。</p>
<p>它的属性如下。</p>
<ul>
<li><code>disabled</code>：布尔设置，是否禁用该组。一旦设置，该组所有的菜单项都不可选。</li>
<li><code>label</code>：菜单项分组的标题。</li>
</ul>
<h3 id="lt-datalist-gt"><a href="#lt-datalist-gt" class="headerlink" title="&lt;datalist&gt;"></a><code>&lt;datalist&gt;</code></h3><p><code>&lt;datalist&gt;</code>标签是一个容器标签，用于为指定控件提供一组相关数据，通常用于生成输入提示。它的内部使用<code>&lt;option&gt;</code>，生成每个菜单项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ice-cream-choice&quot;</span>&gt;</span>冰淇淋：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;ice-cream-flavors&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ice-cream-choice&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ice-cream-choice&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;ice-cream-flavors&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;巧克力&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;椰子&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;薄荷&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;草莓&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香草&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;input&gt;</code>生成一个文本输入框，用户可以输入文本。<code>&lt;input&gt;</code>的<code>list</code>属性指定关联的<code>&lt;datalist&gt;</code>的<code>id</code>属性。<code>&lt;datalist&gt;</code>的数据列表用于输入建议，用户点击输入框的时候，会显示一个下拉菜单，里面是建议的输入项。并且还会自动匹配用户已经输入的字符，缩小可选的范围，比如用户输入“香”，则只会显示“香草”这一项。</p>
<p>注意，<code>&lt;option&gt;</code>在这里可以不需要闭合标签。</p>
<p><code>&lt;option&gt;</code>标签还可以加入<code>label</code>属性，作为说明文字。Chrome 浏览器会将其显示在<code>value</code>的下一行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;ide&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Brackets&quot;</span> <span class="attr">label</span>=<span class="string">&quot;by Adobe&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Coda&quot;</span> <span class="attr">label</span>=<span class="string">&quot;by Panic&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的渲染结果是，Chrome 浏览器会在下拉列表显示<code>value</code>值（比如<code>Brackets</code>），然后在其下方以小字显示<code>label</code>值（比如<code>by Adobe</code>）。</p>
<h3 id="lt-textarea-gt"><a href="#lt-textarea-gt" class="headerlink" title="&lt;textarea&gt;"></a><code>&lt;textarea&gt;</code></h3><p><code>&lt;textarea&gt;</code>是一个块级元素，用来生成多行的文本框。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;story&quot;</span> <span class="attr">name</span>=<span class="string">&quot;story&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;33&quot;</span>&gt;</span></span><br><span class="line">这是一个很长的故事。</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会生成一个长度为5行，宽度为33个字符的文本框。</p>
<p>该标签有如下属性。</p>
<ul>
<li><code>autofocus</code>：布尔属性，是否自动获得焦点。</li>
<li><code>cols</code>：文本框的宽度，单位为字符，默认值为20。</li>
<li><code>disabled</code>：布尔属性，是否禁用该控件。</li>
<li><code>form</code>：关联表单的<code>id</code>属性。</li>
<li><code>maxlength</code>：允许输入的最大字符数。如果未指定此值，用户可以输入无限数量的字符。</li>
<li><code>minlength</code>：允许输入的最小字符数。</li>
<li><code>name</code>：控件的名称。</li>
<li><code>placeholder</code>：输入为空时显示的提示文本。</li>
<li><code>readonly</code>：布尔属性，控件是否为只读。和 disabled 属性不同的是，这个能让用户点击和选择元素内的文本。如果在表单里，这个元素的值还是会跟随表单一起提交。</li>
<li><code>required</code>：布尔属性，控件是否为必填。</li>
<li><code>rows</code>：文本框的高度，单位为行。</li>
<li><code>spellcheck</code>：是否打开浏览器的拼写检查。可能的值有<code>true</code>（打开），<code>default</code>（由父元素或网页设置决定），<code>false</code>（关闭）。</li>
<li><code>wrap</code>：输入的文本是否自动换行。可能的值有<code>hard</code>（浏览器自动插入换行符<code>CR + LF</code>，使得每行不超过控件的宽度），<code>soft</code>（输入内容超过宽度时自动换行，但不会加入新的换行符，并且浏览器保证所有换行符都是<code>CR + LR</code>，这是默认值），<code>off</code>（关闭自动换行，单行长度超过宽度时，会出现水平滚动条）。</li>
</ul>
<h3 id="lt-output-gt"><a href="#lt-output-gt" class="headerlink" title="&lt;output&gt;"></a><code>&lt;output&gt;</code></h3><p><code>&lt;output&gt;</code>标签是一个行内元素，用于显示用户操作的结果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span> +</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span> =</span><br><span class="line"><span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;result&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该标签有如下属性。</p>
<ul>
<li><code>for</code>：关联控件的<code>id</code>属性，表示为该控件的操作结果。</li>
<li><code>form</code>：关联表单的<code>id</code>属性。</li>
<li><code>name</code>：控件的名称。</li>
</ul>
<h3 id="lt-progress-gt"><a href="#lt-progress-gt" class="headerlink" title="&lt;progress&gt;"></a><code>&lt;progress&gt;</code></h3><p><code>&lt;progress&gt;</code>标签是一个行内元素，表示任务的完成进度。浏览器通常会将显示为进度条。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;70&quot;</span>&gt;</span> 70% <span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该标签有如下属性。</p>
<ul>
<li><code>max</code>：进度条的最大值，应该是一个大于<code>0</code>的浮点数。默认值为1。</li>
<li><code>value</code>：进度条的当前值。它必须是<code>0</code>和<code>max</code>属性之间的一个有效浮点数。如果省略了<code>max</code>属性，该值则必须在<code>0</code>和<code>1</code>之间。如果省略了<code>value</code>属性，则进度条会出现滚动，表明正在进行中，无法知道完成的进度。</li>
</ul>
<h3 id="lt-meter-gt"><a href="#lt-meter-gt" class="headerlink" title="&lt;meter&gt;"></a><code>&lt;meter&gt;</code></h3><p><code>&lt;meter&gt;</code>标签是一个行内元素，表示指示器，用来显示已知范围内的一个值，很适合用于任务的当前进度、磁盘已用空间、充电量等带有比例性质的场合。浏览器通常会将其显示为一个不会滚动的指示条。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>烤箱的当前温度是<span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">&quot;200&quot;</span> <span class="attr">max</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">&quot;350&quot;</span>&gt;</span> 350 度<span class="tag">&lt;/<span class="name">meter</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会显示一个指示条，左侧表示<code>200</code>，右侧表示<code>500</code>，当前位置停留在<code>350</code>。</p>
<p>注意，<code>&lt;meter&gt;</code>元素的子元素，正常情况下不会显示。只有在浏览器不支持<code>&lt;meter&gt;</code>时才会显示。</p>
<p>该标签有如下属性。</p>
<ul>
<li><code>min</code>：范围的下限，必须小于<code>max</code>属性。如果省略，则默认为<code>0</code>。</li>
<li><code>max</code>：范围的上限，必须大于<code>min</code>属性。如果省略，则默认为<code>1</code>。</li>
<li><code>value</code>：当前值，必须在<code>min</code>属性和<code>max</code>属性之间。如果省略，则默认为<code>0</code>。</li>
<li><code>low</code>：表示“低端”的上限门槛值，必须大于<code>min</code>属性，小于<code>high</code>属性和<code>max</code>属性。如果省略，则等于<code>min</code>属性。</li>
<li><code>high</code>：表示“高端”的下限门槛值，必须小于<code>max</code>属性，大于<code>low</code>属性和<code>min</code>属性。如果省略，则等于<code>max</code>属性。</li>
<li><code>optimum</code>：指定最佳值，必须在<code>min</code>属性和<code>max</code>属性之间。它应该与<code>low</code>属性和<code>high</code>属性一起使用，表示最佳范围。如果<code>optimum</code>小于<code>low</code>属性，则表示“低端”是最佳范围；如果大于<code>high</code>属性，则表示“高端”是最佳范围；如果在<code>low</code>和<code>high</code>之间，则表示“中间地带”是最佳范围。如果省略，则等于<code>min</code>和<code>max</code>的中间值。</li>
<li><code>form</code>：关联表单的<code>id</code>属性。</li>
</ul>
<p>Chrome 浏览器使用三种颜色，表示指示条所处的位置。较好情况时，当前位置为绿色；一般情况时，当前位置为黄色；较差情况时，当前位置为红色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">id</span>=<span class="string">&quot;fuel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fuel&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">low</span>=<span class="string">&quot;33&quot;</span> <span class="attr">high</span>=<span class="string">&quot;66&quot;</span> <span class="attr">optimum</span>=<span class="string">&quot;80&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">    at 50/100</span><br><span class="line"><span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，指示条可以分成三段：0 ～ 32，33 ～ 65，66 ～ 100。由于<code>optimum</code>属性是<code>80</code>，因此<code>66 ～ 100</code>是较好情况，<code>33 ～ 65</code>是一般情况，<code>0 ～ 32</code>是较差情况。浏览器因此会根据<code>value</code>属性，将当前位置显示为不同颜色，小于<code>33</code>时显示红色，大于<code>65</code>时显示绿色，两者之间显示黄色。</p>
<h2 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h2><h3 id="lt-dialog-gt"><a href="#lt-dialog-gt" class="headerlink" title="&lt;dialog&gt;"></a><code>&lt;dialog&gt;</code></h3><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>&lt;dialog&gt;</code>标签表示一个可以关闭的对话框。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dialog</span>&gt;</span></span><br><span class="line">  Hello world</span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面就是一个最简单的对话框。</p>
<p>默认情况下，对话框是隐藏的，不会在网页上显示。如果要让对话框显示，必须加上<code>open</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">open</span>&gt;</span></span><br><span class="line">  Hello world</span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码会在网页显示一个方框，内容是<code>Hello world</code>。</p>
<p><code>&lt;dialog&gt;</code>元素里面，可以放入其他 HTML 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">open</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的对话框里面，有一个输入框和提交按钮。</p>
<p>注意，上例中<code>&lt;form&gt;</code>的<code>method</code>属性设为<code>dialog</code>，这时点击提交按钮，对话框就会消失。但是，表单不会提交到服务器，浏览器会将表单元素的<code>returnValue</code>属性设为 Submit 按钮的<code>value</code>属性（上例是<code>foo</code>）。</p>
<h4 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h4><p><code>&lt;dialog&gt;</code>元素的 JavaScript API 提供<code>Dialog.showModal()</code>和<code>Dialog.close()</code>两个方法，用于打开/关闭对话框。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modal = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;dialog&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框显示，相当于增加 open 属性</span></span><br><span class="line">modal.showModal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框关闭，相当于移除 open 属性</span></span><br><span class="line">modal.close();</span><br></pre></td></tr></table></figure>
<p>开发者可以提供关闭按钮，让其调用<code>Dialog.close()</code>方法，关闭对话框。</p>
<p><code>Dialog.close()</code>方法可以接受一个字符串作为参数，用于传递信息。<code>&lt;dialog&gt;</code>接口的<code>returnValue</code>属性可以读取这个字符串，否则<code>returnValue</code>属性等于提交按钮的<code>value</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">modal.close(<span class="string">&#x27;Accepted&#x27;</span>);</span><br><span class="line">modal.returnValue <span class="comment">// &quot;Accepted&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Dialog.showModal()</code>方法唤起对话框时，会有一个透明层，阻止用户与对话框外部的内容互动。CSS 提供了一个 Dialog 元素的<code>::backdrop</code>伪类，用于选中这个透明层，因此可以编写样式让透明层变得可见。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dialog</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.6rem</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dialog</span><span class="selector-pseudo">::backdrop</span> &#123;</span><br><span class="line">  <span class="comment">/* make the backdrop a semi-transparent black */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码不仅为<code>&lt;dialog&gt;</code>指定了样式，还将对话框的透明层变成了灰色透明。</p>
<p><code>&lt;dialog&gt;</code>元素还有一个<code>Dialog.show()</code>方法，也能唤起对话框，但是没有透明层，用户可以与对话框外部的内容互动。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p><code>&lt;dialog&gt;</code>元素有两个事件，可以监听。</p>
<ul>
<li><code>close</code>：对话框关闭时触发</li>
<li><code>cancel</code>：用户按下<code>esc</code>键关闭对话框时触发</li>
</ul>
<p>如果希望用户点击透明层，就关闭对话框，可以用下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">modal.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target === modal) &#123;</span><br><span class="line">    modal.close(<span class="string">&#x27;cancelled&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="lt-details-gt-，-lt-summary-gt"><a href="#lt-details-gt-，-lt-summary-gt" class="headerlink" title="&lt;details&gt;，&lt;summary&gt;"></a><code>&lt;details&gt;</code>，<code>&lt;summary&gt;</code></h3><h4 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>&lt;details&gt;</code>标签用来折叠内容，浏览器会折叠显示该标签的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">这是一段解释文本。</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在浏览器里面，会折叠起来，显示<code>Details</code>，前面有一个三角形，就像下面这样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">▶ Details</span><br></pre></td></tr></table></figure>
<p>用户点击这段文本，折叠的文本就会展开，显示详细内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">▼ Details</span><br><span class="line">这是一段解释文本。</span><br></pre></td></tr></table></figure>
<p>再点击一下，展开的文本又会重新折叠起来。</p>
<p><code>&lt;details&gt;</code>标签的<code>open</code>属性，用于默认打开折叠。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">open</span>&gt;</span></span><br><span class="line">这是一段解释文本。</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码默认打开折叠。</p>
<p><code>&lt;summary&gt;</code>标签用来定制折叠内容的标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  这是一段解释文本。</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码显示结果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">▶ 这是标题</span><br></pre></td></tr></table></figure>
<p>点击后，展示的效果如下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">▼ 这是标题</span><br><span class="line">这是一段解释文本。</span><br></pre></td></tr></table></figure>
<p>通过 CSS 设置<code>summary::-webkit-details-marker</code>，可以改变标题前面的三角箭头。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">summary</span><span class="selector-pseudo">::-webkit-details-marker</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(https://example.com/foo.svg);</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的样式是另一种替换箭头的方法。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">summary</span><span class="selector-pseudo">::-webkit-details-marker</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">summary</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;\2714&quot;</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#696f7c</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JavaScript-API-1"><a href="#JavaScript-API-1" class="headerlink" title="JavaScript API"></a>JavaScript API</h4><p><code>Details</code>元素的<code>open</code>属性返回<code>&lt;details&gt;</code>当前是打开还是关闭。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> details = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;details&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detail.open === <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 展开状态</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 折叠状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Details</code>元素有一个<code>toggle</code>事件，打开或关闭折叠时，都会触发这个事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">details.addEventListener(<span class="string">&#x27;toggle&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (details.open) &#123;</span><br><span class="line">    <span class="comment">/* 展开状况 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 折叠状态 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="HTML-自定义元素"><a href="#HTML-自定义元素" class="headerlink" title="HTML 自定义元素"></a>HTML 自定义元素</h2><p>浏览器对待自定义元素，就像对待标准元素一样，只是没有默认的样式和行为。</p>
<p>浏览器提供了一个<code>HTMLUnknownElement</code>对象，所有自定义元素都是该对象的实例。</p>
<h4 id="HTML-import"><a href="#HTML-import" class="headerlink" title="HTML import"></a>HTML import</h4><p>自定义元素，就可以写出语义性非常好的 HTML 代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">share-buttons</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">social-button</span> <span class="attr">type</span>=<span class="string">&quot;weibo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span>微博<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">social-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">social-button</span> <span class="attr">type</span>=<span class="string">&quot;weixin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span>微信<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">social-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">share-buttons</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果将<code>&lt;share-buttons&gt;</code>元素的样式与脚本，封装在一个 HTML 文件<code>share-buttons.html</code>之中，这个元素就可以复用了。</p>
<p>使用的时候，先引入<code>share-buttons.html</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;import&quot; href&#x3D;&quot;share-buttons.html&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
