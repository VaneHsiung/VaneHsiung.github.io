<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="uXmcnam1s6y-h_YGHukGYhDQ8zMBAOHTHrJ6RfsDN6I">
  <meta name="msvalidate.01" content="687D92122214353CF2ACE3AEA2977A9C">
  <meta name="baidu-site-verification" content="code-lURpXjbL6l">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Share+Tech+Mono:300,300italic,400,400italic,700,700italic%7CArchitects+Daughter:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vanehsiung.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="在实现方法时，选择不同的数据结构会导致其实现风格以及性能存在着很大差异。">
<meta property="og:type" content="article">
<meta property="og:title" content="09集合">
<meta property="og:url" content="https://vanehsiung.github.io/2021/04/26/09%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="BAIHEZI">
<meta property="og:description" content="在实现方法时，选择不同的数据结构会导致其实现风格以及性能存在着很大差异。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-26T02:17:24.000Z">
<meta property="article:modified_time" content="2021-06-10T13:47:29.777Z">
<meta property="article:author" content="vane">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://vanehsiung.github.io/2021/04/26/09%E9%9B%86%E5%90%88/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>09集合 | BAIHEZI</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=sG-KKYP310LB0"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'sG-KKYP310LB0');
      }
    </script>

  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3032f7a989f15a8faf91348571efe03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="BAIHEZI" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BAIHEZI</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Vane Hsiung's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fas fa-link fa-fw"></i>Links</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>


 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~";
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~";
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>


</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-text">Java 集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="nav-text">将集合的接口与实现分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collection-%E6%8E%A5%E5%8F%A3"><span class="nav-text">Collection 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">泛型实用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">集合框架中的接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-text">具体的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="nav-text">数组列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E9%9B%86"><span class="nav-text">散列集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E9%9B%86"><span class="nav-text">树集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-text">优先级队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="nav-text">基本映射操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E9%A1%B9"><span class="nav-text">更新映射项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E8%A7%86%E5%9B%BE"><span class="nav-text">映射视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%B1%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84"><span class="nav-text">弱散列映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-text">链接散列集与映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="nav-text">枚举集与映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84"><span class="nav-text">标识散列映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8"><span class="nav-text">视图与包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%9B%86%E5%90%88%E5%8C%85%E8%A3%85%E5%99%A8"><span class="nav-text">轻量级集合包装器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E8%8C%83%E5%9B%B4"><span class="nav-text">子范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E8%A7%86%E5%9B%BE"><span class="nav-text">不可修改的视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E8%A7%86%E5%9B%BE"><span class="nav-text">同步视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%97%E6%9F%A5%E8%A7%86%E5%9B%BE"><span class="nav-text">受查视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-text">关于可选操作的说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%B7%B7%E6%8E%92"><span class="nav-text">排序与混排</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E6%93%8D%E4%BD%9C"><span class="nav-text">批操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">集合与数组的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">编写自己的算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%97%E7%95%99%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-text">遗留的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hashtable-%E7%B1%BB"><span class="nav-text">Hashtable 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84"><span class="nav-text">属性映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E9%9B%86"><span class="nav-text">位集</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vane"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">vane</p>
  <div class="site-description" itemprop="description">"Life is 10% what happens to you and 90% how you react to it."</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZhbmVIc2l1bmc=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;VaneHsiung"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOm1pY3JvZnV0Y3NAb3V0bG9vay5jb20=" title="E-Mail → mailto:microfutcs@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9lbg=="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vanehsiung.github.io/2021/04/26/09%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="vane">
      <meta itemprop="description" content=""Life is 10% what happens to you and 90% how you react to it."">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BAIHEZI">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          09集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-26 10:17:24" itemprop="dateCreated datePublished" datetime="2021-04-26T10:17:24+08:00">2021-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-10 21:47:29" itemprop="dateModified" datetime="2021-06-10T21:47:29+08:00">2021-06-10</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>14 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在实现方法时，选择不同的数据结构会导致其实现风格以及性能存在着很大差异。</p>
<a id="more"></a>

<h3 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h3><p>Java 最初版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet 与Enumeration 接口。</p>
<p>随着Java SE 1.2 的问世，设计人员感到是推出一组功能完善的数据结构的时机了。</p>
<h5 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h5><p>Java 集合类库将接口（ interface ) 与实现( implementation) 分离。</p>
<p>队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; // <span class="title">a</span> <span class="title">simplified</span> <span class="title">form</span> <span class="title">of</span> <span class="title">the</span> <span class="title">interface</span> <span class="title">in</span> <span class="title">the</span> <span class="title">standard</span> <span class="title">library</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>;</span><br><span class="line">	<span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列通常有两种实现方式： 一种是使用循环数组； 另一种是使用链表。每一个实现都可以通过一个实现了Queue 接口的类表示。如果需要一个循环数组队列， 就可以使用ArrayDeque 类。如果需要一个链表队列， 就直接使用LinkedList类。</p>
<p>当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了哪种实现。因此， 只有在构建集合对象时，使用具体的类才有意义。可以使用接口类型存放集合的引用：<br><code>Queue&lt;Customer&gt; expresslane = new ArrayDeque&lt;&gt;(100);</code><br>利用这种方式，一旦改变了想法， 可以轻松地使用另外一种不同的实现。只需要对程序的一个地方做出修改， 即调用构造器的地方：<br><code>Queue&lt;Custoaer&gt; expressLane = new LinkedList();</code></p>
<p>接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效， 因此多数人优先选择循环数组。循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。</p>
<p>如果想要实现自己的队列类，可以扩展AbstractQueue 类。</p>
<h5 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h5><p>在Java 类库中，集合类的基本接口是Collection 接口。这个接口有两个基本方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">	<span class="function">Ierator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">	. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回true, 如果集合没有发生变化就返回false。</p>
<p>iterator 方法用于返回一个实现了Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</p>
<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>Iterator 接口包含4 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">boolean</span> hasNextO;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反复调用next 方法，可以逐个访问集合中的每个元素。但是， 如果到达了集合的末尾，next 方法将抛出一个NoSuchElementException。因此，需要在调用next 之前调用hasNext方法。如果迭代器对象还有多个供访问的元素， 这个方法就返回true。如果想要査看集合中的所有元素，就请求一个迭代器，并在hasNext 返回true 时反复地调用next 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = . . .;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator()；</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">	String element = iter.next()；</span><br><span class="line">	<span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用“ for each” 循环可以更加简练地表示同样的循环操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span> something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器简单地将“ for each” 循环翻译为带有迭代器的循环。”for each” 循环可以与任何实现了Iterable 接口的对象一起工作， 这个接口只包含一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java SE 8 中， 甚至不用写循环。可以调用forEachRemaining 方法并提供一lambda表达式。将对迭代器的每一个元素调用这个lambda 表达式，直到再没有元素为止：<br><code>iterator.forEachRemaining(element -&gt; do something with element) ;</code></p>
<p>元素被访问的顺序取决于集合类型。如果对ArrayList 进行迭代， 迭代器将从索引 0 开始， 每迭代一次， 索引值加1。然而， 如果访问HashSet 中的元素， 每个元素将会按照某种随机的次序出现。</p>
<p>Iterator 接口的next 和hasNext 方法与Enumeration 接口的nextElement 和hasMoreElements 方法的作用一样。</p>
<p>Java 集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别。在传统的集合类库中， 迭代器是根据数组索引建模的，查找操作与位置变更是分离的，通过a[i]进行查找，通过 i++ 进行位置变更。但是，Java 迭代器查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用next, 而在执行查找操作的同时， 迭代器的位置随之向前移动。</p>
<p>应该将Java 迭代器认为是位于两个元素之间。当调用next 时， 迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。也可以将Iterator.next 与InputStream.read 看作为等效的。</p>
<p>Iterator 接口的remove 方法将会删除上次调用next 方法时返回的元素。如果调用remove 之前没有调用next 将是不合法的。如果这样做， 将会抛出一个IllegalStateException 异常。</p>
<h5 id="泛型实用方法"><a href="#泛型实用方法" class="headerlink" title="泛型实用方法"></a>泛型实用方法</h5><p>由于Collection 与Iterator 都是泛型接口， 可以编写操作任何集合类型的实用方法。</p>
<p>Collection 接口声明了很多有用的方法，所有的实现类都必须提供这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span> <span class="params">(Col1ection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span> <span class="params">(Collection&lt;? extends E&gt; from)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span> <span class="params">(Col1ection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Col1ection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] arrayToFill)</span></span></span><br></pre></td></tr></table></figure>
<p>为了能够让实现者更容易地实现Collection 接口， Java 类库提供了一个AbstractCollection 类，它只将基础方法size 和iterator 抽象化了。</p>
<h5 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h5><p>Java 集合框架为不同类型的集合定义了大量接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterable &lt;- Collection &lt;- List, Set, Queue</span><br><span class="line">Set &lt;- SortedSet &lt;- NavigableSet</span><br><span class="line">Queue &lt;- Deque</span><br><span class="line">Map &lt;- SortedMap &lt;- NavigableMap</span><br><span class="line">Iterator &lt; ListIterator</span><br><span class="line">RandomAccess</span><br></pre></td></tr></table></figure>
<p>集合有两个基本接口：Collection 和Map。由于映射包含键/ 值对，所以要用put 方法来插人。可以用迭代器访问元素。不过， 从映射中读取值则要使用get 方法。</p>
<p>List 是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素： 使用迭代器访问， 或者使用一个整数索引来访问。后一种方法称为随机访问（random access ), 因为这样可以按任意顺序访问元素。与之不同， 使用迭代器访问时，必须顺序地访问元素。List 接口定义了多个用于随机访问的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br></pre></td></tr></table></figure>
<p>ListIterator 接口是Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：<br>void add(E element)</p>
<p>实际中有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List 方法并提供一个整数索引来访问。与之不同， 链表尽管也是有序的， 但是随机访问很慢， 所以最好使用迭代器来遍历。</p>
<p>为了避免对链表完成随机访问操作， Java SE 1.4 引入了一个标记接口RandomAccess。这个接口不包含任何方法， 不过可以用它来测试一个特定的集合是否支持高效的随机访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">&#123;</span><br><span class="line">	use random access algorithm</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	use sequential access algorithm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set 接口等同于Collection 接口，不过其方法的行为有更严谨的定义。Set 的add 方法不允许增加重复的元素。要适当地定义集的equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。</p>
<p>SortedSet 和SortedMap 接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。</p>
<p>Java SE 6 引人了接口NavigableSet 和NavigableMap, 其中包含一些用于搜索和遍历有序集和映射的方法。TreeSet 和TreeMap 类实现了这些接口。</p>
<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p>Java库中的具体集合。除了以Map 结尾的类之外， 其他类都实现了Collection 接口，而以Map 结尾的类实现了Map 接口：</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>一种可以动态增长和缩减的索引序列</td>
</tr>
<tr>
<td>LinkedList</td>
<td>一种可以在任何位置进行高效地插人和删除操作的有序序列</td>
</tr>
<tr>
<td>ArrayDeque</td>
<td>一种用循环数组实现的双端队列</td>
</tr>
<tr>
<td>HashSet</td>
<td>一种没有重复元素的无序集合</td>
</tr>
<tr>
<td>TreeSet</td>
<td>—种有序集</td>
</tr>
<tr>
<td>EnumSet</td>
<td>一种包含枚举类型值的集</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>一种可以记住元素插人次序的集</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td>一种允许高效删除最小元素的集合</td>
</tr>
<tr>
<td>HashMap</td>
<td>一种存储键/ 值关联的数据结构</td>
</tr>
<tr>
<td>TreeMap</td>
<td>—种键值有序排列的映射表</td>
</tr>
<tr>
<td>EnumMap</td>
<td>一种键值属于枚举类型的映射表</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>一种可以记住键/ 值项添加次序的映射表</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>一种其值无用武之地后可以被垃圾回收器回收的映射表</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>一种用 == 而不是用equals 比较键值的映射表</td>
</tr>
</tbody></table>
<p>集合框架中的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Abstract &lt;- AbstractList, AbstractSet, AbstractQueue, ArrayQueue</span><br><span class="line">AbstractList &lt;- AbstractSequentialList, ArrayList</span><br><span class="line">AbstractSequentialList &lt; LinkedList</span><br><span class="line">AbstractSet &lt;- HashSet, EnumSet, TreeSet</span><br><span class="line">HashSet &lt;- LinkedHashSet</span><br><span class="line">AbstractQueue &lt;- PriorityQueue</span><br><span class="line"></span><br><span class="line">AbstractMap &lt;- HashMap, ThreeMap, EnumMap, WeakHashMap, IdentityHashMap</span><br><span class="line">HashMap &lt;- LinkedHashMap</span><br></pre></td></tr></table></figure>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。 在数组中间的位置上插入一个元素也是如此。</p>
<p>链表（ linked list ) 解决了这个问题。链表将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java 程序设计语言中， 所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用。</p>
<p>链表与泛型集合之间有一个重要的区别。链表是一个有序集合（ ordered collection ), 每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。由于迭代器是描述集合中位置的， 所以依赖于位置的add 方法将由迭代器负责。</p>
<p>只有对自然有序的集合使用迭代器添加元素才有实际意义。集合类库提供了子接口Listlterator, 其中包含add 方法，与Collection.add 不同， 这个方法不返回boolean 类型的值， 它假定添加操作总会改变链表。另外， Listlterator 接口有两个方法， 可以用来反向遍历链表：<br>E previous()<br>boolean hasPrevious()<br>与next 方法一样， previous 方法返回越过的对象。</p>
<p>LinkedList 类的listlterator 方法返回一个实现了Listlterator 接口的迭代器对象。add 方法在迭代器位置之前添加一个新对象。如果多次调用add 方法， 将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。</p>
<p>add 方法只依赖于迭代器的位置， 而remove 方法依赖于迭代器的状态。不能连续调用两次remove。</p>
<p>set 方法用一个新元素取代调用next 或previous 方法返回的上一个元素。</p>
<p>如果迭代器发现它的集合被另一个迭代器修改了， 或是被该集合自身的方法修改了， 就会抛出一个ConcurrentModificationException 异常。</p>
<p>为了避免发生并发修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。</p>
<p>有一种简单的方法可以检测到并发修改的问题。集合可以跟踪改写操作（诸如添加或删除元素）的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致， 抛出一个ConcurrentModificationException 异常。</p>
<p>链表只负责跟踪对列表的结构性修改， 例如， 添加元素、删除元素。set 方法不被视为结构性修改。</p>
<p>链表不支持快速地随机访问。如果要查看链表中第n个元素，就必须从头开始， 越过n -1个元素。LinkedList 类还是提供了一个用来访问某个特定元素的get 方法，这个方法的效率并不太高，每次査找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。</p>
<p>列表迭代器接口还有一个方法，可以告之当前位置的索引。由于Java 迭代器指向两个元素之间的位置， 所以可以同时产生两个索引：nextlndex 方法返回下一次调用next 方法时返回元素的整数索引；previouslndex 方法返回下一次调用previous 方法时返回元素的整数索引。这两个方法的效率<br>非常高，这是因为迭代器保持着当前位置的计数值。如果有一个整数索引 n, list.listlterator(n) 将返回一个迭代器， 这个迭代器指向索引为n 的元素前面的位置。</p>
<h5 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h5><p>ArrayList 类实现了List 接口。ArrayList 封装了一个动态再分配的对象数组。</p>
<p>Vector 类的所有方法都是同步的。可以由两个线程安全地访问一个Vector 对象。但是， 如果由一个线程访问Vector, 代码要在同步操作上耗费大量的时间。这种情况还是很常见的。而ArrayList 方法不是同步的，因此， 建议在不需要同步时使用ArrayList, 而不要使用Vector。</p>
<h5 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h5><p>如果不在意元素的顺序， 可以有几种能够快速査找元素的数据结构。其缺点是无法控制元素出现的次序。它们将按照有利于其操作目的的原则组织数据。</p>
<p>散列表为每个对象计算一个整数， 称为散列码（hashcode)。 散列码是由对象的实例域产生的一个整数。更准确地说， 具有不同数据域的对象将产生不同的散列码。如果自定义类，就要负责实现这个类的hashCode方法。注意，自己实现的hashCode 方法应该与equals 方法兼容，即如果a.equals(b) 为true, a 与b 必须具有相同的散列码。最重要的问题是散列码要能够快速地计算出来，并且这个计算只与要散列的对象状态有关，与散列表中的其他对象无关。</p>
<p>在Java 中， 散列表用链表数组实现。每个列表被称为桶（ bucket) 。要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。当然， 有时候会遇到桶被占满的情况， 这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。 这时， 需要用新对象与桶中的所有对象进行比较， 査看这个对象是否已经存在。在JavaSE 8 中， 桶满时会从链表变为平衡二叉树。</p>
<p>如果大致知道最终会有多少个元素要插人到散列表中， 就可以设置桶数。通常， 将桶数设置为预计元素个数的75% ~ 150%。有些研究人员认为：尽管还没有确凿的证据， 但最好将桶数设置为一个素数， 以防键的集聚。标准类库使用的桶数是2 的幂， 默认值为16。</p>
<p>如果散列表太满， 就需要再散列（rehashed)。如果要对散列表再散列， 就需要创建一个桶数更多的表，并将所有元素插入到这个新表中， 然后丢弃原来的表。装填因子（load factor ) 决定何时对散列表进行再散列。如果装填因子为0.75 (默认值)，而表中超过75%的位置已经填人元素， 这个表就会用双倍的桶数自动地进行再散列。</p>
<p>散列表可以用于实现几个重要的数据结构。其中最简单的是set 类型。set 是没有重复元素的元素集合。Java 集合类库提供了一个HashSet 类，它实现了基于散列表的集。</p>
<p>散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。</p>
<h5 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h5><p>树集是一个有序集合( sorted collection) 。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。</p>
<p>正如 TreeSet 类名所示，排序是用树结构完成的（当前实现使用的是红黑树) 。</p>
<p>将一个元素添加到树中要比添加到散列表中慢，如果树中包含 n 个元素， 査找新元素的正确位置平均需要 log2 n 次比较。</p>
<p>要使用树集， 必须能够比较元素。这些元素必须实现 Comparable 接口，或者构造集时必须提供一个 Comparator 。</p>
<h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><p>优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。优先级队列使用了为堆（heap)。堆是一个可以自我调整的二叉树，对树执行添加（ add) 和删除（remore) 操作， 可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>一个优先级队列既可以保存实现了 Comparable 接口的类对象， 也可以保存在构造器中提供的 Comparator 对象。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>映射用来存放键 / 值对。如果提供了键， 就能够查找到值。</p>
<h5 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h5><p>Java 类库为映射提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了 Map 接口。</p>
<p>散列映射对键进行散列， 树映射用键的整体顺序对元素进行排序， 并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。</p>
<p>每当往映射中添加对象时， 必须同时提供一个键。要想检索一个对象， 必须使用一个键。</p>
<p>如果在映射中没有与给定键对应的信息， get 将返回 null，null 返回值可能并不方便，有时可以有一个好的默认值， 用作为映射中不存在的键，然后使用 getOrDefault 方法。</p>
<p>键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用 put 方法， 第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。</p>
<p>remove 方法用于从映射中删除给定键对应的元素。size 方法用于返回映射中的元素数。</p>
<p>要迭代处理映射的键和值， 最容易的方法是使用 forEach 方法。可以提供一个接收键和值的 lambda 表达式。</p>
<h5 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h5><p>正常情况下，可以得到与一个键关联的原值，完成更新， 再放回更新后的值。不过，必须考虑一个特殊情况， 即键第一次出现。</p>
<p>作为一个简单的补救， 可以使用 getOrDefault 方法。</p>
<p>另一种方法是首先调用 putlfAbsent 方法。只有当键原先存在时才会放入一个值。</p>
<p>merge 方法可以简化这个常见的操作。<br>counts.merge(word, 1, Integer::sum);<br>将把 word 与 1 关联，否则使用 Integer::sum 函数组合原值和 1 。</p>
<h5 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h5><p>集合框架不认为映射本身是一个集合。 不过， 可以得到映射的视图（ View ）——这是实现了Collection 接口或某个子接口的对象。</p>
<p>有 3 种视图： 键集、 值集合（不是一个集） 以及键 / 值对集。下面的方法：<br>Set&lt;K&gt; keySet()<br>Collection&lt;V&gt; values()<br>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()<br>会分别返回这 3 个视图。</p>
<p>keySet 不是 HashSet 或 TreeSet， 而是实现了 Set 接口的另外某个类的对象。Set 接口扩展了 Collection 接口。因此， 可以像使用集合一样使用 keySet。</p>
<p>如果在键集视图上调用迭代器的 remove方法， 实际上会从映射中删除这个键和与它关联的值。不过，不能向键集视图增加元素。条目集视图有同样的限制。</p>
<h5 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h5><p>假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键 / 值对无法从映射中删除。垃圾回收器跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的， 它们不能被回收。因此， 需要由程序负责从长期存活的映射表中删除那些无用的值。 或者使用 WeakHashMap 完成这件事情。</p>
<p>WeakHashMap 使用WeakRefrence保存键。WeakReference 对象将引用保存到另外一个对象中，在这里，就是散列键。如果某个对象只能由 WeakReference 引用， 垃圾回收器仍然回收它，但要将引用这个对象的弱引用放人队列中。WeakHashMap 将周期性地检查队列， 以便找出新添加的弱引用。一个弱引用进人队列意味着这个键不再被他人使用， 并且已经被收集起来。于是， WeakHashMap 将删除对应的条目。</p>
<h5 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h5><p>LinkedHashSet 和 LinkedHashMap类用来记住插人元素项的顺序。</p>
<p>链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get 或put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。要想构造这样一个的散列映射表， 请调用:<br>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</p>
<h5 id="枚举集与映射"><a href="#枚举集与映射" class="headerlink" title="枚举集与映射"></a>枚举集与映射</h5><p>EnumSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1。</p>
<p>EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br></pre></td></tr></table></figure>
<p>EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型：<br>EnumMap&lt;Weekday, Employee&gt; personlnCharge = new EnumMapo(Weekday.class);</p>
<h5 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h5><p>类 IdentityHashMap 有特殊的作用。在这个类中， 键的散列值不是用 hashCode 函数计算的， 而是用 System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。</p>
<p>在实现对象遍历算法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。</p>
<h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用视图( views) 可以获得其他的实现了 Collection 接口和 Map 接口的对象。keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h5 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h5><p>Arrays 类的静态方法 asList 将返回一个包装了普通 Java 数组的 List 包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。它是一个视图对象， 带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法都会抛出一个UnsupportedOperationException 异常。</p>
<p>asList 方法可以接收可变数目的参数。这个方法调用：<br>Collections.nCopies(n, anObject)<br>将返回一个实现了 List 接口的不可修改的对象， 并给人一种包含n个元素， 每个元素都像是一个 anObject 的错觉。</p>
<p>Collections.singleton(anObject)则将返回一个视图对象。这个对象实现了 Set 接口。返回的对象实现了一个不可修改的单元素集， 而不需要付出建立数据结构的开销。singletonList方法与 singletonMap 方法类似。</p>
<h5 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h5><p>可以为很多集合建立子范围（subrange ) 视图。可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况。</p>
<p>对于有序集和映射， 可以使用排序顺序而不是元素位置建立子范围。SortedSet 接口声明了 3 个方法：<br>SortedSet&lt;E&gt; subSet(E from, E to)<br>SortedSet&lt;E&gt; headSet(E to)<br>SortedSet&lt;E&gt; tailSet(E from)<br>这些方法将返回大于等于 from 且小于 to 的所有元素子集。有序映射也有类似的方法：<br>SortedMap&lt;K, V&gt; subMap(K from, K to)<br>SortedMap&lt;K, V&gt; headMap(K to)<br>SortedMap&lt;K , V&gt; tailMap(K from)<br>返回映射视图， 该映射包含键落在指定范围内的所有元素。Java SE 6 引人的 NavigableSet 接口赋予子范围操作更多的控制能力。可以指定是否包括边界：<br>NavigableSet&lt;E&gt; subSet(E from, boolean fromlnclusive, E to, boolean tolnclusive)<br>NavigableSet&lt;E&gt; headSet(E to, boolean tolnclusive)<br>NavigableSet&lt;E&gt; tailSet(E from, boolean fromlnclusive)</p>
<h5 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h5><p>Collections 还有几个方法， 用于产生集合的不可修改视图。这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改， 就抛出一个异常，同时这个集合将保持未修改的状态。</p>
<p>可以使用下面 8 种方法获得不可修改视图：<br>Collections. unmodifiableCollection<br>Collections.unmodifiableList<br>Collections.unmodifiableSet<br>Collections.unmodifiableSortedSet<br>Collections.unmodifiableNavigableSet<br>Collections.unmodifiableMap<br>Collections.unmodifiableSortedMap<br>Collections.unmodifiableNavigableMap</p>
<p>不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用对集合进行修改。</p>
<p>由于视图只是包装了接口而不是实际的集合对象， 所以只能访问接口中定义的方法。</p>
<p>unmodifiableCollection 方法将返回一个集合， 它的 equals 方法不调用底层集合的 equals 方法。相反， 它继承了 Object 类的 equals 方法。unmodifiableSet 类和 unmodifiableList 类 却 使 用 底 层 集 合 的 equals 方 法 和 hashCode 方 法。</p>
<h5 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h5><p>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。例如，Collections 类的静态 synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的 Map。</p>
<h5 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h5><p>“ 受査” 视图用来对泛型类型发生问题时提供调试支持。</p>
<p>下面定义了一个安全列表：<br>List&lt;String&gt; safestrings = Collections.checkedList(strings，String.class);<br>视图的 add 方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个 ClassCastException。</p>
<p>受查视图受限于虚拟机可以运行的运行时检查。 </p>
<h5 id="关于可选操作的说明"><a href="#关于可选操作的说明" class="headerlink" title="关于可选操作的说明"></a>关于可选操作的说明</h5><p>在集合和迭代器接口的 API 文档中， 许多方法描述为“ 可选操作”。是否应该将“ 可选” 方法这一技术扩展到用户的设计中呢？ 我们认为不应该。尽管集合被频繁地使用， 其实现代码的风格也未必适用于其他问题领域。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>泛型集合接口有一个很大的优点， 即算法只需要实现一次。Java 类库中包含了基本的排序、二分查找等实用算法。</p>
<h5 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h5><p>Collections 类中的 sort 方法可以对实现了 List 接口的集合进行排。这个方法假定列表元素实现了 Comparable 接口。如果想采用其他方式对列表进行排序，可以使用 List 接口的 sort方法并传入一个 Comparator 对象。</p>
<p>如果想按照降序对列表进行排序， 可以使用一种非常方便的静态方法 Collections.reverseOrder()。这个方法将返回一个比较器， 比较器则返回 b.compareTo(a)。</p>
<p>Java 程序设计语言直接将所有元素转人一个数组，对数组进行排序，然后，再将排序后的序列复制回列表。集合类库中使用的排序算法比快速排序要慢一些，快速排序是通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定， 即不需要交换相同的元素。如果采用稳定的排序算法， 相同元素的顺序将会保留原排列的顺序。</p>
<p>因为集合不需要实现所有的“ 可选” 方法，因此， 所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法。可以传递什么类型的列表呢？ 根据文档说明，列表必须是可修改的， 但不必是可以改变大小的。</p>
<p>Collections 类有一个算法 shuffle,随机地混排列表中元素的顺序。如果提供的列表没有实现RandomAccess 接口，shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>如果数组是有序的，就可以直接査看位于数组中间的元素， 看一看是否大于要查找的元素。如果是， 用同样的方法在数组的前半部分继续查找；否则， 用同样的方法在数组的后半部分继续查找。这样就可以将查找范围缩减一半。一直用这种方式査找下去。</p>
<p>Collections 类的 binarySearch方法实现了这个算法。要想查找某个元素， 必须提供集合（这个集合要实现 List 接口）以及要查找的元素。如果集合没有采用 Comparable 接口的compareTo 方法进行排序， 就还要提供一个比较器对象。<br>i = Collections.binarySearch(c, element);<br>i = Collections.binarySearch(c, element, comparator);</p>
<p>如果 binarySearch 方法返回的数值大于等于 0, 则表示匹配对象的索引。c.get(i) 等于在这个比较顺序下的 element。</p>
<p>如果返回负值， 则表示没有匹配的元素。但是，可以利用返回值计算应该将 element 插人到集合的哪个位置， 以保持集合的有序性。插人的位置是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (i &lt; 0)</span><br><span class="line">	c.add(-i - 1, element);</span><br></pre></td></tr></table></figure>
<p>只有采用随机访问，二分査找才有意义。如果必须利用迭代方式一次次地遍历链表的一半元素来找到中间位置的元素，二分査找就完全失去了优势。因此，如果为 binarySearch 算法提供一个链表， 它将自动地变为线性查找。</p>
<h5 id="批操作"><a href="#批操作" class="headerlink" title="批操作"></a>批操作</h5><p>很多操作会“ 成批” 复制或删除元素。</p>
<h5 id="集合与数组的转换"><a href="#集合与数组的转换" class="headerlink" title="集合与数组的转换"></a>集合与数组的转换</h5><p>由于 Java 平台 API 的大部分内容都是在集合框架创建之前设计的， 所以，有时候需要在传统的数组和比较现代的集合之间进行转换。</p>
<p>如果需要把一个数组转换为集合，Arrays.asList 包装器可以达到这个目的。</p>
<p>集合得到数组会更困难一些。当然，可以使用 toArray 方法，toArray方法返回的数组是一个 Object[] 数组， 不能改变它的类型（不能强制类型转换）。<br>Object[] values = staff.toArray();<br>可以使用toArray 方法的一个变体形式，提供一个所需类型而且长度为 0 的数组。这样一来， 返回的数组就会创建为相同的数组类型：<br>String[] values = staff.toArray(new String[0]);<br>如果愿意，可以构造一个指定大小的数组：<br>staff.toArray(new String[staff.size()]);<br>在这种情况下，不会创建新数组。<br>为什么不能直接将一个 Class 对象（如 String.class) 传递到 toArray 方法。原因是这个方法有“ 双重职责”， 不仅要填充一个已有的数组（如果它足够长，) 还要创建一个新数组。</p>
<h5 id="编写自己的算法"><a href="#编写自己的算法" class="headerlink" title="编写自己的算法"></a>编写自己的算法</h5><p>如果编写自己的算法（实际上，是以集合作为参数的任何方法，) 应该尽可能地使用更加通用接口，而不要使用具体的实现。</p>
<p>既然将集合接口作为方法参数是个很好的想法， 为什么 Java 类库不更多地这样做呢？之所以没有这样做， 原因很简单： 时间问题。</p>
<p>如果编写了一个返回集合的方法，可能还想要一个返回接口，而不是返回类的方法，因为这样做可以在日后改变想法，并用另一个集合重新实现这个方法。</p>
<h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><p>从 Java 第 1 版问世以来， 在集合框架出现之前已经存在大量“ 遗留的” 容器类。这些类已经集成到集合框架中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack -&gt; Vector -&gt; AbstractList -&gt; List</span><br><span class="line">Vector -&gt; RandomAccess</span><br><span class="line">Properties -&gt; Hashtable -&gt; Map</span><br></pre></td></tr></table></figure>
<h5 id="Hashtable-类"><a href="#Hashtable-类" class="headerlink" title="Hashtable 类"></a>Hashtable 类</h5><p>Hashtable 类与 HashMap 类拥有相同的接口。Hashtable 的方法是同步的。如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 HashMap。如果需要并发访问， 则要使用 ConcurrentHashMap。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>遗留集合使用 Enumeration 接口对元素序列进行遍历。Enumeration 接口有两个方法， 即hasMoreElements 和 nextElement。</p>
<p>静态方法 Collections.enumeration将产生一个枚举对象，枚举集合中的元素。</p>
<h5 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h5><p>属性映射（property map) 是一个类型非常特殊的映射结构。它有下面 3 个特性：</p>
<ul>
<li><p>键与值都是字符串。</p>
</li>
<li><p>表可以保存到一个文件中， 也可以从文件中加载。</p>
</li>
<li><p>使用一个默认的辅助表。</p>
</li>
</ul>
<p>实现属性映射的 Java 平台类称为 Properties。属性映射通常用于程序的特殊配置选项，</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>从 1.0 版开始，标准类库中就包含了 Stack类，其中有大家熟悉的 push 方法和 pop方法。但是， Stack 类扩展为 Vector 类，从理论角度看，Vector 类并不太令人满意，它可以让栈使用不属于栈操作的 insert 和 remove 方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。</p>
<h5 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h5><p>Java 平台的 BitSet 类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适)。如果需要高效地存储位序列就可以使用位集。由于位集将位包装在字节里，所以，使用位集要比使用 Boolean 对象的 ArrayList 更加高效。</p>
<p>BitSet 类提供了一个便于读取、设置或清除各个位的接口。<br>例如，对于一个名为 bucketOfBits 的 BitSet:<br>bucketOfBits.get(i)<br>如果第 i 位处于“ 开” 状态，就返回 true; 否则返回 false。<br>bucketOfBits.set(i)<br>将第 i 位置为“ 开” 状态。<br>bucketOfBits.clear(i)<br>将第 i 位置为“ 关” 状态。</p>

    </div>

    
    
    

    <footer class="post-footer">


          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>vane
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://vanehsiung.github.io/2021/04/26/09%E9%9B%86%E5%90%88/" title="09集合">https://vanehsiung.github.io/2021/04/26/09集合/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9lbg=="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Programming/" rel="tag"># Programming</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/26/08%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="prev" title="08泛型程序设计">
                  <i class="fa fa-chevron-left"></i> 08泛型程序设计
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/26/10%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="next" title="10图形程序设计">
                  10图形程序设计 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vane Hsiung</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

<script src="https://cdn.jsdelivr.net/gh/suyin-long/activate-power-mode@1.0/dist/activate-power-mode.js"></script>
<script>
POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = false; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script>




    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
<script src="/js/local-search.js"></script>




<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.4/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>

  <script>
    NProgress.configure({
      showSpinner: false
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">


    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
