<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="uXmcnam1s6y-h_YGHukGYhDQ8zMBAOHTHrJ6RfsDN6I">
  <meta name="msvalidate.01" content="687D92122214353CF2ACE3AEA2977A9C">
  <meta name="baidu-site-verification" content="code-lURpXjbL6l">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Share+Tech+Mono:300,300italic,400,400italic,700,700italic%7CArchitects+Daughter:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vanehsiung.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="接口（ interface) 技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现（ implement) 一个或多个接口，并在需要接口的地方， 随时使用实现了相应接口的对象。 lambda表达式是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda 表达式， 可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。 内部类（ inner class) 定义">
<meta property="og:type" content="article">
<meta property="og:title" content="06接口、lambda表达式与内部类">
<meta property="og:url" content="https://vanehsiung.github.io/2021/04/26/06%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/index.html">
<meta property="og:site_name" content="BAIHEZI">
<meta property="og:description" content="接口（ interface) 技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现（ implement) 一个或多个接口，并在需要接口的地方， 随时使用实现了相应接口的对象。 lambda表达式是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda 表达式， 可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。 内部类（ inner class) 定义">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-26T02:13:24.000Z">
<meta property="article:modified_time" content="2021-07-04T14:23:39.187Z">
<meta property="article:author" content="vane">
<meta property="article:tag" content="Programming">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://vanehsiung.github.io/2021/04/26/06%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>06接口、lambda表达式与内部类 | BAIHEZI</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=sG-KKYP310LB0"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'sG-KKYP310LB0');
      }
    </script>

  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3032f7a989f15a8faf91348571efe03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="BAIHEZI" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BAIHEZI</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Vane Hsiung's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fas fa-link fa-fw"></i>Links</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>


 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~";
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~";
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>


</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5"><span class="nav-text">接口概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">接口的特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">接口与抽象类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81"><span class="nav-text">解决默认方法冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B"><span class="nav-text">接口示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83"><span class="nav-text">接口与回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Comparator-%E6%8E%A5%E5%8F%A3"><span class="nav-text">Comparator 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="nav-text">对象克隆</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">为什么引入lambda 表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-text">lambda 表达式的语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">处理lambda 表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%8D%E8%B0%88-Comparator"><span class="nav-text">再谈 Comparator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81"><span class="nav-text">使用内部类访问对象状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-text">内部类的特殊语法规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%A8%E3%80%81%E5%BF%85%E8%A6%81%E5%92%8C%E5%AE%89%E5%85%A8"><span class="nav-text">内部类是否有用、必要和安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="nav-text">由外部方法访问变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">静态内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="nav-text">何时使用代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建代理对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">代理类的特性</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vane"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">vane</p>
  <div class="site-description" itemprop="description">"Life is 10% what happens to you and 90% how you react to it."</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZhbmVIc2l1bmc=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;VaneHsiung"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOm1pY3JvZnV0Y3NAb3V0bG9vay5jb20=" title="E-Mail → mailto:microfutcs@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9lbg=="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vanehsiung.github.io/2021/04/26/06%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="vane">
      <meta itemprop="description" content=""Life is 10% what happens to you and 90% how you react to it."">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BAIHEZI">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          06接口、lambda表达式与内部类
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-26 10:13:24" itemprop="dateCreated datePublished" datetime="2021-04-26T10:13:24+08:00">2021-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-07-04 22:23:39" itemprop="dateModified" datetime="2021-07-04T22:23:39+08:00">2021-07-04</time>
      </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>10 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>接口（ interface) 技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现（ implement) 一个或多个接口，并在需要接口的地方， 随时使用实现了相应接口的对象。</p>
<p>lambda表达式是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda 表达式， 可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。</p>
<p>内部类（ inner class) 定义在另外一个类的内部， 其中的方法可以访问包含它们的外部类的域。内部类技术主要用于设计具有相互协作关系的类集合。</p>
<p>代理（proxy)是一种实现任意接口的对象。</p>
<a id="more"></a>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h5 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h5><p>在Java 程序设计语言中， 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<p>Arrays 类中的 sort 方法承诺可以对对象数组进行排序， 但要求满足下列前提： 对象所属的类必须实现了Comparable 接口。在JavaSE 5.0 中，Comparable 接口已经改进为泛型类型。</p>
<p>接口中的所有方法自动地属于public。因此， 在接口中声明方法时， 不必提供关键字public。不过，在实现接口时， 必须把方法声明为public; 否则， 编译器将认为这个方法的访问属性是包可见性，之后编译器就会给出试图提供更严格的访问权限的警告信息。</p>
<p>compareTo 方法必须确实比较两个对象的内容， 并返回比较的结果。当x 小于y 时， 返回一个负数；当x 等于y 时， 返回0; 否则返回一个正数。</p>
<p>接口绝不能含有实例域， 在JavaSE 8 之前， 也不能在接口中实现方法。</p>
<p>为了让类实现一个接口， 通常需要下面两个步骤：</p>
<ol>
<li>将类声明为实现给定的接口。使用关键字implements</li>
<li>对接口中的所有方法进行定义。</li>
</ol>
<p>compareTo方法的继承：</p>
<ol>
<li>如果子类之间的比较含义不一样， 每个compareTo 方法都应该在开始时进行下列检测：<br>if (getClass() != other.getClass()) throw new ClassCastExceptionO；</li>
<li>如果存在这样一种通用算法， 它能够对两个不同的子类对象进行比较， 则应该在超类中提供一个compareTo 方法， 并将这个方法声明为final 。</li>
</ol>
<h5 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h5><p>接口不是类，尤其不能使用new 运算符实例化一个接口，尽管不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象。可以使用instance 检查一个对象是否实现了某个特定的接口。接口也可以被扩展，这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。在接口中可以包含常量。接口中的域将被自动设为public static final。尽管每个类只能够拥有一个超类， 但却可以实现多个接口。</p>
<h5 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h5><p>为什么Java 程序设计语言还要不辞辛苦地引入接口概念，为什么不将接口直接设计成抽象类？<br>使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。</p>
<p>Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂（如同C++)，效率也会降低（如同Eiffel)。接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>在Java SE 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。</p>
<p>通常的做法都是将静态方法放在伴随类中。在标准库中， 你会看到成对出现的接口和实用工具类， 如Collection/Collections 或Path/Paths。</p>
<p>不过整个Java 库都以这种方式重构也是不太可能的， 但是实现你自己的接口时，不再需要为实用工具方法另外提供一个伴随类。</p>
<h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><p>在Java SE 8 中，可以为接口方法提供一个默认实现。必须用default 修饰符标记这样一个方法。默认方法可以调用任何其他方法。</p>
<p>在JavaAPI 中， 你会看到很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法， 如CoUection/AbstractCollectkm 或MouseListener/MouseAdapter。</p>
<p>默认方法的一个重要用法是“接口演化” （interface evolution)。为接口新增加一个非默认方法不能保证“ 源代码兼容”(Source compatible)，而默认方法可以解决这个问题。</p>
<h5 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h5><p>如果先在一个接口中将一个方法定义为默认方法， 然后又在超类或另一个接口中定义了同样的方法， 会发生什么情况？规则如下：</p>
<ol>
<li>超类优先。如果超类提供了一个具体方法， 同名而且有相同参数类型的默认方法会被忽略。这正是“ 类优先” 规则。“类优先” 规则可以确保与Java SE 7 的兼容性。如果为一个接口增加默认方法，这对于有这个默认方法之前能正常工作的代码不会有任何影响。</li>
<li>接口冲突。如果一个接口提供了一个默认方法， 另一个接口提供了一个同名而且参数类型相同的方法， 必须覆盖这个方法来解决冲突。</li>
</ol>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><h5 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h5><p>回调（ callback) 是一种常见的程序设计模式。在这种模式中， 可以指出某个特定事件发生时应该采取的动作。</p>
<h5 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h5><p>ArrayS.Sort 方法还有第二个版本， 用一个数组和一个比较器( comparator )作为参数， 比较器是实现了Comparator 接口的类的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparators&#123;</span><br><span class="line">	int compare(T first, T second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h5><p>Cloneable 接口指示一个类提供了一个安全的clone 方法。</p>
<p>如果希望copy 是一个新对象，它的初始状态与original 相同， 但是之后它们各自会有自己不同的状态， 这种情况下就可以使用clone 方法。</p>
<p>如果对象中的所有数据域都是数值或其他基本类型，拷贝这些域没有任何问题、但是如果对象包含子对象的引用，拷贝域就会得到相同子对象的另一个引用，这样一来， 原对象和克隆的对象仍然会共享一些信息。默认的克隆操作是“ 浅拷贝”，并没有克隆对象中引用的其他对象。如果原对象和浅克隆对象共享的子对象是不可变的， 那么这种共享就是安全的。不过， 通常子对象都是可变的， 必须重新定义clone 方法来建立一个深拷贝， 同时克隆所有子对象。</p>
<p>对于每一个类，需要确定：</p>
<ol>
<li>默认的clone 方法是否满足要求；</li>
<li>是否可以在可变的子对象上调用clone 来修补默认的clone 方法；</li>
<li>是否不该使用clone。<br>实际上第3 个选项是默认选项。如果选择第1 项或第2 项，类必须：</li>
<li>实现Cloneable 接口；</li>
<li>重新定义clone 方法，并指定public 访问修饰符。</li>
</ol>
<p>Object 类中clone 方法声明为protected , 所以你的代码不能直接调用anObject.clone()。子类只能调用受保护的clone方法来克隆它自己的对象。必须重新定义clone 为public 才能允许所有方法克隆对象。（理解：就是说，clone为protected的话，就有限制，非子类，非同一包的公有类之间就不能互相调用各自对象的clone方法，从而复制对象，所以说“你的代码不能直接调用anObject.clone()”；而作者的目的，是在代码中实现复制对象，而没有什么限制）</p>
<p>Cloneable这个接口只是作为一个标记，指示类设计者了解克隆过程。对象对于克隆很“ 偏执”， 如果一个对象请求克隆， 但没有实现这个接口， 就会生成一个受査异常。Cloneable 接口是Java 提供的一组标记接口( tagging interface ) 之一。（有些程序员称之为记号接口( marker interface)。标记接口不包含任何方法； 它唯一的作用就是允许在类型查询中使用instanceof。</p>
<p>实现Cloneable 接口， 将clone重新定义为public。在Java SE 1.4 之前， clone 方法的返回类型总是Object, 而现在可以为你的clone方法指定正确的返回类型，这是协变返回类型的一个例子。</p>
<p>如果在一个对象上调用clone, 但这个对象的类并没有实现Cloneable 接口， Object 类的clone 方法就会拋出一个CloneNotSupportedException。</p>
<p>一旦为超类类定义了clone 方法， 任何人都可以用它来克隆子类对象。不能保证子类的实现者一定会修正clone 方法让它正常工作。出于这个原因， 在Object类中clone 方法声明为protected。</p>
<p>所有数组类型都有一个public 的clone 方法， 而不是protected: 可以用这个方法建立一个新数组， 包含原数组所有元素的副本。</p>
<h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><h5 id="为什么引入lambda-表达式"><a href="#为什么引入lambda-表达式" class="headerlink" title="为什么引入lambda 表达式"></a>为什么引入lambda 表达式</h5><p>lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。</p>
<p>之前，在Java 中传递一个代码段并不容易， 不能直接传递代码段，Java 是一种面向对象语言， 所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。</p>
<h5 id="lambda-表达式的语法"><a href="#lambda-表达式的语法" class="headerlink" title="lambda 表达式的语法"></a>lambda 表达式的语法</h5><p>lambda 表达式就是一个代码块， 以及必须传人代码的变量规范。</p>
<p>为什么起这个名字呢？逻辑学家Alonzo Church 想要形式化地表示能有效计算的数学函数。他使用了希腊字母lambda (λ) 来标记参数。</p>
<p>Java 中的一种lambda 表达式形式：参数， 箭头（-&gt;) 以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return 语句。即使lambda 表达式没有参数， 仍然要提供空括号，就像无参数方法一样。如果可以推导出一个lambda 表达式的参数类型，则可以忽略其类型。如果方法只有一参数， 而且这个参数的类型可以推导得出，那么甚至还可以省略小括号。无需指定lambda 表达式的返回类型，lambda 表达式的返回类型总是会由上下文推导得出。</p>
<p>如果一个lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。例如，（int x)-&gt; { if (x &gt;= 0) return 1; } 就不合法。</p>
<h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><p>对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个lambda 表达式。这种接口称为函数式接口（ functional interface )。</p>
<p>在底层，方法会接收实现了函数式接口的某个类的对象。在这个对象上调用函数式接口的抽象方法会执行这个lambda 表达式的体。</p>
<p>实际上，在Java 中， 对lambda 表达式所能做的也只是能转换为函数式接口。（注释：也就是把lambda表达式赋值给函数式接口变量）</p>
<p>Java API 在java.util.function 包中定义了很多非常通用的函数式接口。</p>
<p>想要用lambda 表达式做某些处理，还是要谨记表达式的用途， 为它建立一个特定的函数式接口。</p>
<h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p>可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。</p>
<p>方法引用要用 :: 操作符分隔方法名与对象或类名。主要有3 种情况：<br>object::instanceMethod<br>Class::staticMethod<br>Class::instanceMethod<br>在前2 种情况中， 方法引用等价于提供方法参数的lambda 表达式。System.out::println 等价于x -&gt; System.out.println(x)。 Math::pow 等价于（x，y) -&gt; Math.pow(x, y)。<br>对于第3 种情况， 第1 个参数会成为方法的目标。String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y)。</p>
<p>如果有多个同名的重载方法， 编译器就会尝试从上下文中找出你指的那一个方法。选择哪一个版本取决于转换为哪个函数式接口的方法参数。类似于lambda 表达式， 方法引用不能独立存在，总是会转换为函数式接口的实例。</p>
<p>可以在方法引用中使用this 参数。使用super 也是合法的：<br>this::instanceMetod<br>super::instanceMethod</p>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><p>Class::new是Class 构造器的一个引用。调用哪一个构造器取决于上下文。</p>
<p>可以用数组类型建立构造器引用。例如， int[]::new 是一个构造器引用， 它有一个参数，即数组的长度。这等价于lambda 表达式 x-&gt; new int[x]。Java 有一个限制，无法构造泛型类型 T 的数组。数组构造器引用对于克服这个限制很有用。</p>
<h5 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h5><p>你可能希望能够在lambda 表达式中访问外围方法或类中的变量。<br>lambda 表达式有3个部分：</p>
<ol>
<li>一个代码块；</li>
<li>参数;</li>
<li>自由变量的值， 这是指非参数而且不在代码中定义的变量。<br>lambda 表达式的数据结构必须存储自由变量的值。我们说它被lambda 表达式捕获(captured)。lambda 表达式中捕获的变量必须实际上是最终变量( effectively final)。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。之所以有这个限制是有原因的。如果在lambda 表达式中改变变量， 并发执行多个动作时就会不安全。</li>
</ol>
<p>lambda 表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规则。在lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</p>
<p>在一个lambda 表达式中使用this 关键字时， 是指创建这个lambda 表达式的方法的this参数，而非转换的函数式接口实例的this参数。在lambda 表达式中， this 的使用并没有任何特殊之处，就是自由变量。</p>
<h5 id="处理lambda-表达式"><a href="#处理lambda-表达式" class="headerlink" title="处理lambda 表达式"></a>处理lambda 表达式</h5><p>使用lambda 表达式的重点是延迟执行（deferred execution )。毕竟， 如果想要立即执行代码，完全可以直接执行， 而无需把它包装在一个 lambda 表达式中。</p>
<p>要接受 lambda 表达式， 需要选择（偶尔可能需要提供）一个函数式接口。调用接口的抽象方法时会执行这个 lambda 表达式的主体。</p>
<table>
<thead>
<tr>
<th>常用函数式接口</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable</td>
<td>void</td>
<td>run</td>
<td>无参数和无返回值的动作运行</td>
</tr>
<tr>
<td>Supplier&lt;T&gt;</td>
<td>T</td>
<td>get</td>
<td>提供一个T 类型的值</td>
</tr>
<tr>
<td>Consumer&lt;T&gt;</td>
<td>void</td>
<td>accept</td>
<td>处理一个T 类型的值</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>void</td>
<td>accept</td>
<td>处理T 和U 类型的值</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;</td>
<td>R</td>
<td>apply</td>
<td>有一个T 类型参数的函数</td>
</tr>
<tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>R</td>
<td>apply</td>
<td>有T 和U 类型参数的函数</td>
</tr>
<tr>
<td>UnaryOperator&lt;T&gt;</td>
<td>T</td>
<td>apply</td>
<td>类型T 上的一元操作符</td>
</tr>
<tr>
<td>BinaryOperator&lt;T&gt;</td>
<td>T</td>
<td>apply</td>
<td>类型T 上的二元操作符</td>
</tr>
<tr>
<td>Predicate&lt;T&gt;</td>
<td>boolean</td>
<td>test</td>
<td>布尔值函数</td>
</tr>
<tr>
<td>BiPredicate&lt;T, U&gt;</td>
<td>boolean</td>
<td>test</td>
<td>有两个参数的布尔值函数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>基本类型的函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
</tr>
</thead>
<tbody><tr>
<td>BooleanSupplier</td>
<td>none</td>
<td>boolean</td>
<td>getAsBoolean</td>
</tr>
<tr>
<td>PSupplier</td>
<td>none</td>
<td>p</td>
<td>getAsP</td>
</tr>
<tr>
<td>PConsumer</td>
<td>p</td>
<td>void</td>
<td>accept</td>
</tr>
<tr>
<td>ObjPConsumer&lt;T&gt;</td>
<td>T,p</td>
<td>void</td>
<td>accept</td>
</tr>
<tr>
<td>PFunction&lt;T&gt;</td>
<td>p</td>
<td>T</td>
<td>apply</td>
</tr>
<tr>
<td>PToQFunction</td>
<td>p</td>
<td>q</td>
<td>applyAsQ</td>
</tr>
<tr>
<td>ToPFunction&lt;T&gt;</td>
<td>T</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>ToPBiFunction&lt;T, U&gt;</td>
<td>T, U</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PUnaryOperator</td>
<td>p</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PBinaryOperator</td>
<td>p,p</td>
<td>p</td>
<td>applyAsP</td>
</tr>
<tr>
<td>PPredicate</td>
<td>p</td>
<td>boolean</td>
<td>test</td>
</tr>
<tr>
<td>p，q为int, long, double;</td>
<td></td>
<td></td>
<td>P，Q 为Int, Long, Double</td>
</tr>
</tbody></table>
<p>最好使用上表中的接口。</p>
<p>如果设计你自己的接口，其中只有一个抽象方法， 可以用@FunctionalInterface 注解来标记这个接口。这样做有两个优点。如果你无意中增加了另一个非抽象方法， 编译器会产生一个错误消息。另外javadoc 页里会指出你的接口是一个函数式接口。</p>
<h5 id="再谈-Comparator"><a href="#再谈-Comparator" class="headerlink" title="再谈 Comparator"></a>再谈 Comparator</h5><p>Comparator 接口包含很多方便的静态方法来创建比较器。这些方法可以用于lambda 表达式或方法引用。</p>
<p>静态comparing 方法取一个“ 键提取器” 函数， 它将类型T 映射为一个可比较的类型。对要比较的对象应用这个函数， 然后对返回的键完成比较。可以把比较器与thenComparing 方法串起来。可以为comparing 和thenComparing 方法提取的键指定一个比较器。</p>
<p>如果键函数可以返回null, 可能就要用到nullsFirst 和nullsLast 适配器。这些静态方法会修改现有的比较器， 从而在遇到null 值时不会抛出异常， 而是将这个值标记为小于或大于正常值。nullsFirst 方法需要一个比较器。</p>
<p>naturalOrder 方法可以为任何实现了Comparable 的类建立一个比较器。</p>
<p>静态reverseOrder 方法会提供自然顺序的逆序。要让比较器逆序比较， 可以使用reversed实例方法。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类（ inner class ) 是定义在另一个类中的类。为什么需要使用内部类呢？ 其主要原因有以下三点：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous) 内部类比较便捷。</li>
</ol>
<h5 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h5><p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p>
<p>内部类的对象总有一个隐式引用， 它指向了创建它的外部类对象。这个引用在内部类的定义中是不可见的。外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器， 添加一个外围类引用的参数。</p>
<h5 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h5><p>表达式 OuterClass.this 表示外围类引用。</p>
<p>可以采用下列语法格式更加明确地编写内部对象的构造器：<br>outerObject.new InnerClass(construction parameters)</p>
<p>在外围类的作用域之外，可以这样引用内部类：<br>OuterClass.InnerClass</p>
<p>内部类中声明的所有静态域都必须是 final。我们希望一个静态域只有一个实例， 不过对于每个外部对象， 会分别有一个单独的内部类实例。如果这个域不是final , 它可能就不是唯一的。</p>
<p>内部类不能有static 方法。Java 语言规范对这个限制没有做任何解释。也可以允许有静态方法， 但只能访问外围类的静态域和方法。显然，Java 设计者认为相对于这种复杂性来说， 它带来的好处有些得不偿失。</p>
<h5 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h5><p>内部类是一种编译器现象， 与虚拟机无关。编译器将会把内部类翻译成用$ ( 美元符号）分隔外部类名与内部类名的常规类文件， 而虚拟机则对此一无所知。</p>
<p>编译器为了引用外围类， 生成了一个附加的实例域this$0 ( 名字this$0 是由编译器合成的，在自己编写的代码中不能够引用它）:<br>final OuterClass this$0;</p>
<p>由于内部类拥有访问特权， 所以与常规类比较起来功能更加强大。</p>
<p>编译器在外围类添加静态方法access$0：<br>static boolean access$0(outerObject);<br>它将返回作为参数传递给它的对象域。（方法名可能稍有不同， 如access$000, 这取决于你的编译器。）内部类方法将调用那个方法。这样做存在安全风险，任何人都可以通过调用access$0方法很容易地读取到私有域。当然， access$0 不是Java 的合法方法名。但熟悉类文件结构的黑客可以使用十六进制编辑器轻松地创建一个用虚拟机指令调用那个方法的类文件。由于隐秘地访问方法需要拥有包可见性，所以攻击代码需要与被攻击类放在同一个包中。</p>
<p>在虚拟机中不存在私有类， 因此编译器将会利用私有构造器生成一个包可见的类：<br>private OuterClass$InnerClass(OuterClass);<br>当然， 没有人可以调用这个构造器， 因此， 存在第二个包可见构造器：<br>OuterClass$InnerClass(OuterClass, OuterClass$1);<br>它将调用第一个构造器。</p>
<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>类只在方法中创建这个类型的对象时使用了一次。当遇到这类情况时， 可以在一个方法中定义局部类。局部类不能用public 或private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势， 即对外部世界可以完全地隐藏起来。</p>
<h5 id="由外部方法访问变量"><a href="#由外部方法访问变量" class="headerlink" title="由外部方法访问变量"></a>由外部方法访问变量</h5><p>与其他内部类相比较， 局部类还有一个优点。它们不仅能够访问包含它们的外部类， 还可以访问局部变量。不过， 那些局部变量必须事实上为final。这说明， 它们一旦赋值就绝不会改变。</p>
<p>当创建一个对象的时候， 局部变量beep 就会被传递给内部类构造器，并存储在val$beep 域中。编译器必须检测对局部变量的访问， 为每一个变量建立相应的数据域， 并将局部变量拷贝到构造器中， 以便将这些数据域初始化为局部变量的副本。在JavaSE 8 之前， 必须把从局部类访问的局部变量声明为final，从而使内部类能够访问局部变量。</p>
<p>有时， final 限制显得并不太方便。补救的方法是使用数组。</p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>将局部内部类的使用再深人一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class)。</p>
<p>通常的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new SuperType(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">	inner class methods and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的含义是： 创建一个实现（扩展）SuperType 接口（类）的类的新对象，需要实现的方法定义在括号内。</p>
<p>由于构造器的名字必须与类名相同， 而匿名类没有类名， 所以， 匿名类不能有构造器。取而代之的是，将构造器参数传递给超类（ superclass) 构造器。</p>
<p>“双括号初始化” （double brace initialization )，为一个匿名列表添加元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ArrayList&lt;T&gt;() &#123;&#123; add(T) ; add(T) ; ... &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>外层括号建立了ArrayList 的一个匿名子类。内层括号则是一个对象构造块。</p>
<p>外层括号建立了ArrayList 的一个匿名子类。内层括号则是一个对象构造块。</p>
<p>建立一个与超类大体类似（但不完全相同）的匿名子类通常会很方便。不过， 对于equals 方法要特别当心。以下测试：<br>if (getClass() != other.getClass()) return false;<br>对匿名子类做这个测试时会失败。</p>
<p>生成日志或调试消息时， 通常希望包含当前类的类名，不过， 这对于静态方法不奏效。毕竟， 调用getClass 时调用的是this.getClass(), 而静态方法没有this。所以应该使用以下表达式：<br>new Object(){}.getCIass().getEndosingClass()<br>在这里，newObject(){} 会建立Object 的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类， 也就是包含这个静态方法的类。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>有时候， 使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static, 以便取消产生的引用。有些程序员用嵌套类（nested class ) 表示静态内部类。与常规内部类不同， 静态内部类可以有静态域和方法。声明在接口中的内部类自动成为static 和public 类。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p>
<h5 id="何时使用代理"><a href="#何时使用代理" class="headerlink" title="何时使用代理"></a>何时使用代理</h5><p>假设有一个表示接口的Class 对象，它的确切类型在编译时无法知道。要想构造一个实现这些接口的类， 就需要使用newlnstance 方法或反射找出这个类的构造器。但是， 不能实例化一个接口，需要在程序处于运行状态时定义一个新类。为了解决这个问题， 有些程序将会生成新类代码；将这些代码放置在一个文件中；调用编译器；然后再加载结果类文件。很自然， 这样做的速度会比较慢，并且需要将编译器与程序放在一起。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：</p>
<ol>
<li>指定接口所需要的全部方法。</li>
<li>Object 类中的全部方法， 例如， toString、equals 等。<br>然而，不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（ invocation handler)。调用处理器是实现了InvocationHandler 接口的类对象。在这个接口中只有一个方法：<br>Object invoke(Object proxy, Method method, Object[] args)<br>无论何时调用代理对象的方法， 调用处理器的invoke 方法都会被调用， 并向其传递Method 对象和原始的调用参数。调用处理器必须给出处理调用的方式。</li>
</ol>
<h5 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h5><p>要想创建一个代理对象， 需要使用Proxy 类的newProxylnstance 方法。这个方法有三个参数：</p>
<ol>
<li>一个类加载器（ class loader)。 作为Java 安全模型的一部分， 对于系统类和从因特网上下载下来的类，可以使用不同的类加载器。用null 表示使用默认的类加载器。</li>
<li>一个Class 对象数组， 每个元素都是需要实现的接口。</li>
<li>一个调用处理器。</li>
</ol>
<h5 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h5><p>需要记住， 代理类是在程序运行过程中创建的。然而， 一旦被创建， 就变成了常规类， 与虚拟机中的任何其他类没有什么区别。</p>
<p>所有的代理类都扩展于Proxy 类。一个代理类只有一个实例域——调用处理器，它定义在Proxy 的超类中。为了履行代理对象的职责， 所需要的任何附加数据都必须存储在调用处理器中。</p>
<p>所有的代理类都覆盖了Object 类中的方法toString、equals 和hashCode。如同所有的代理方法一样， 这些方法仅仅调用了调用处理器的invoke。Object 类中的其他方法（如clone和getClass ) 没有被重新定义。</p>
<p>没有定义代理类的名字，Sun 虚拟机中的Proxy 类将生成一个以字符串SProxy 开头的类名。</p>
<p>对于特定的类加载器和预设的一组接口来说， 只能有一个代理类。也可以利用getProxyClass 方法获得这个类。</p>
<p>代理类一定是public 和final。如果代理类实现的所有接口都是public， 代理类就不属于某个特定的包；否则， 所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包。</p>
<p>可以通过调用Proxy 类中的isProxyClass 方法检测一个特定的Class 对象是否代表一个代理类。</p>

    </div>

    
    
    

    <footer class="post-footer">


          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>vane
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://vanehsiung.github.io/2021/04/26/06%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/" title="06接口、lambda表达式与内部类">https://vanehsiung.github.io/2021/04/26/06接口、lambda表达式与内部类/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9lbg=="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Programming/" rel="tag"># Programming</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/26/05%E7%BB%A7%E6%89%BF/" rel="prev" title="05继承">
                  <i class="fa fa-chevron-left"></i> 05继承
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/26/07%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/" rel="next" title="07异常、断言和日志">
                  07异常、断言和日志 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vane Hsiung</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span>
  </div>

<script src="https://cdn.jsdelivr.net/gh/suyin-long/activate-power-mode@1.0/dist/activate-power-mode.js"></script>
<script>
POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = false; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script>




    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
<script src="/js/local-search.js"></script>




<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.4/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>

  <script>
    NProgress.configure({
      showSpinner: false
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">


    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
